{"version":3,"file":"forward_ref_spec.js","sourceRoot":"","sources":["../../../../../../packages/examples/core/di/ts/forward_ref/forward_ref_spec.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;;;;;;;;;;AAEH,wCAAwF;AAExF;IACE,QAAQ,CAAC,qBAAqB,EAAE;QAC9B,EAAE,CAAC,4BAA4B,EAAE;YAC/B,4BAA4B;YAC5B,MAAM,GAAG,GAAG,iBAAU,CAAC,MAAM,IAAI,CAAC,CAAC;YACnC,gBAAgB;YAChB,MAAM,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,QAAQ,EAAE,CAAC;YAE3B;aAAa;QACf,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,6CAA6C,EAAE;YAChD,yBAAyB;YACzB,IAAM,IAAI,GAAV;gBAGE,kEAAkE;gBAClE,kCAAkC;gBAClC,YAA4C,IAAU,IAAI,IAAI,CAAC,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC;aAC9E,CAAA;YANK,IAAI;gBAKK,WAAA,aAAM,CAAC,iBAAU,CAAC,MAAM,IAAI,CAAC,CAAC,CAAA;eALvC,IAAI,CAMT;YAED,sCAAsC;YACtC;aAAa;YAEb,MAAM,QAAQ,GAAG,yBAAkB,CAAC,gBAAgB,CAAC,CAAC,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;YACnE,MAAM,IAAI,GAAG,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;YAChC,MAAM,CAAC,IAAI,YAAY,IAAI,CAAC,CAAC,UAAU,EAAE,CAAC;YAC1C,MAAM,CAAC,IAAI,CAAC,IAAI,YAAY,IAAI,CAAC,CAAC,UAAU,EAAE,CAAC;YAC/C,gBAAgB;QAClB,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,kBAAkB,EAAE;YACrB,iCAAiC;YACjC,MAAM,GAAG,GAAG,iBAAU,CAAC,MAAM,UAAU,CAAC,CAAC;YACzC,MAAM,CAAC,wBAAiB,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACnD,MAAM,CAAC,wBAAiB,CAAC,cAAc,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC;YAClE,gBAAgB;QAClB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AAvCD,oBAuCC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Inject, ReflectiveInjector, forwardRef, resolveForwardRef} from '@angular/core';\n\nexport function main() {\n  describe('forwardRef examples', () => {\n    it('ForwardRefFn example works', () => {\n      // #docregion forward_ref_fn\n      const ref = forwardRef(() => Lock);\n      // #enddocregion\n      expect(ref).not.toBeNull();\n\n      class Lock {}\n    });\n\n    it('can be used to inject a class defined later', () => {\n      // #docregion forward_ref\n      class Door {\n        lock: Lock;\n\n        // Door attempts to inject Lock, despite it not being defined yet.\n        // forwardRef makes this possible.\n        constructor(@Inject(forwardRef(() => Lock)) lock: Lock) { this.lock = lock; }\n      }\n\n      // Only at this point Lock is defined.\n      class Lock {}\n\n      const injector = ReflectiveInjector.resolveAndCreate([Door, Lock]);\n      const door = injector.get(Door);\n      expect(door instanceof Door).toBeTruthy();\n      expect(door.lock instanceof Lock).toBeTruthy();\n      // #enddocregion\n    });\n\n    it('can be unwrapped', () => {\n      // #docregion resolve_forward_ref\n      const ref = forwardRef(() => 'refValue');\n      expect(resolveForwardRef(ref)).toEqual('refValue');\n      expect(resolveForwardRef('regularValue')).toEqual('regularValue');\n      // #enddocregion\n    });\n  });\n}\n"]}