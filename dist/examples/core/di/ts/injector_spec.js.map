{"version":3,"file":"injector_spec.js","sourceRoot":"","sources":["../../../../../packages/examples/core/di/ts/injector_spec.ts"],"names":[],"mappings":";AAAA;;;;;;GAMG;;AAEH,wCAA2E;AAE3E;IACE,QAAQ,CAAC,4BAA4B,EAAE;QACrC,EAAE,CAAC,OAAO,EAAE;YACV,sBAAsB;YACtB,MAAM,QAAQ,GACV,yBAAkB,CAAC,gBAAgB,CAAC,CAAC,EAAC,OAAO,EAAE,YAAY,EAAE,QAAQ,EAAE,OAAO,EAAC,CAAC,CAAC,CAAC;YACtF,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;YACpD,MAAM,CAAC,MAAM,QAAQ,CAAC,GAAG,CAAC,cAAc,CAAC,CAAC,CAAC,YAAY,EAAE,CAAC;YAC1D,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,cAAc,EAAE,UAAU,CAAC,CAAC,CAAC,OAAO,CAAC,UAAU,CAAC,CAAC;YACrE,gBAAgB;QAClB,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,kBAAkB,EAAE;YACrB,4BAA4B;YAC5B,MAAM,QAAQ,GAAG,yBAAkB,CAAC,gBAAgB,CAAC,EAAE,CAAC,CAAC;YACzD,MAAM,CAAC,QAAQ,CAAC,GAAG,CAAC,eAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;YAC9C,gBAAgB;QAClB,CAAC,CAAC,CAAC;QAEH,EAAE,CAAC,mBAAmB,EAAE;YACtB,4BAA4B;YAC5B,MAAM,QAAQ,GAAG,IAAI,qBAAc,CAAS,SAAS,CAAC,CAAC;YACvD,MAAM,QAAQ,GACV,yBAAkB,CAAC,gBAAgB,CAAC,CAAC,EAAC,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,kBAAkB,EAAC,CAAC,CAAC,CAAC;YAC7F,MAAM,GAAG,GAAG,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;YACnC,wFAAwF;YACxF,MAAM,CAAC,GAAG,CAAC,CAAC,IAAI,CAAC,kBAAkB,CAAC,CAAC;YACrC,gBAAgB;QAClB,CAAC,CAAC,CAAC;IACL,CAAC,CAAC,CAAC;AACL,CAAC;AA9BD,oBA8BC","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {InjectionToken, Injector, ReflectiveInjector} from '@angular/core';\n\nexport function main() {\n  describe('injector metadata examples', () => {\n    it('works', () => {\n      // #docregion Injector\n      const injector: Injector =\n          ReflectiveInjector.resolveAndCreate([{provide: 'validToken', useValue: 'Value'}]);\n      expect(injector.get('validToken')).toEqual('Value');\n      expect(() => injector.get('invalidToken')).toThrowError();\n      expect(injector.get('invalidToken', 'notFound')).toEqual('notFound');\n      // #enddocregion\n    });\n\n    it('injects injector', () => {\n      // #docregion injectInjector\n      const injector = ReflectiveInjector.resolveAndCreate([]);\n      expect(injector.get(Injector)).toBe(injector);\n      // #enddocregion\n    });\n\n    it('should infer type', () => {\n      // #docregion InjectionToken\n      const BASE_URL = new InjectionToken<string>('BaseUrl');\n      const injector =\n          ReflectiveInjector.resolveAndCreate([{provide: BASE_URL, useValue: 'http://localhost'}]);\n      const url = injector.get(BASE_URL);\n      // here `url` is inferred to be `string` because `BASE_URL` is `InjectionToken<string>`.\n      expect(url).toBe('http://localhost');\n      // #enddocregion\n    });\n  });\n}\n"]}