{"version":3,"sources":["../../../../../../packages/platform-browser/src/security/url_sanitizer.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH;;;;;;GAMG;AAEH,OALO,EAAA,SAAE,EAAS,MAAA,eAAA,CAAA;AAOlB,OALO,EAAA,MAAE,EAAM,MAAA,oBAAA,CAAA;AAMf;;;;;;;;;;;;;;;;;;;;;;;;;GAyBG;AACH,IAHC,gBAAA,CAAK,gBAAA,GAAmB,6DAAA,CAA8D;AAKvF,+CAA+C;AAC/C,IAAM,gBAAgB,CAHhB,mBAAA,GAAsB,8CAAA,CAA+C;AAI3E;;GAEG;AACH,IAJC,gBAAA,CAAK,gBAAA,GAKF,sIAAsI,CAJC;AAK3I;;;GAGG;AACH,MAPC,sBAA2B,GAAK;IAQ/B,GAAG,GAPG,MAAA,CAAO,GAAC,CAAG,CAAC;IAQlB,EAAE,CAAC,CAAC,GAPC,CAAG,KAAC,CAAK,gBAAC,CAAgB,IAAI,GAAA,CAAI,KAAC,CAAK,gBAAC,CAAgB,CAAC;QAAC,MAAA,CAAO,GAAA,CAAI;IAS3E,EAAE,CAAC,CAAC,SAPC,EAAS,CAAE,CAAC,CAAA;QAQf,MAAM,EAPC,CAAE,GAAC,CAAG,0CAAC,GAAwC,uCAAG,CAAoC,CAAC;IAQhG,CAAC;IAED,MAAM,CAPC,SAAA,GAAY,GAAA,CAAI;AAQzB,CAAC;AACD;;;GAGG;AACH,MAVC,yBAA8B,MAAQ;IAWrC,MAAM,GAVG,MAAA,CAAO,MAAC,CAAM,CAAC;IAWxB,MAAM,CAVC,MAAA,CAAO,KAAC,CAAK,GAAC,CAAG,CAAC,GAAC,CAAG,UAAC,MAAC,IAAU,OAAA,WAAA,CAAY,MAAC,CAAM,IAAC,EAAI,CAAE,EAA1B,CAA0B,CAAC,CAAC,IAAC,CAAI,IAAC,CAAI,CAAC;AAWlF,CAAC","file":"url_sanitizer.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {isDevMode} from '@angular/core';\n\nimport {getDOM} from '../dom/dom_adapter';\n/**\n * A pattern that recognizes a commonly useful subset of URLs that are safe.\n * \n * This regular expression matches a subset of URLs that will not cause script\n * execution if used in URL context within a HTML document. Specifically, this\n * regular expression matches if (comment from here on and regex copied from\n * Soy's EscapingConventions):\n * (1) Either a protocol in a whitelist (http, https, mailto or ftp).\n * (2) or no protocol.  A protocol must be followed by a colon. The below\n *     allows that by allowing colons only after one of the characters [/?#].\n *     A colon after a hash (#) must be in the fragment.\n *     Otherwise, a colon after a (?) must be in a query.\n *     Otherwise, a colon after a single solidus (/) must be in a path.\n *     Otherwise, a colon after a double solidus (//) must be in the authority\n *     (before port).\n * \n * The pattern disallows &, used in HTML entity declarations before\n * one of the characters in [/?#]. This disallows HTML entities used in the\n * protocol name, which should never happen, e.g. \"h&#116;tp\" for \"http\".\n * It also disallows HTML entities in the first path part of a relative path,\n * e.g. \"foo&lt;bar/baz\".  Our existing escaping functions should not produce\n * that. More importantly, it disallows masking of a colon,\n * e.g. \"javascript&#58;...\".\n * \n * This regular expression was taken from the Closure sanitization library.\n */\nconst /** @type {?} */ SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n\n/* A pattern that matches safe srcset values */\nconst /** @type {?} */ SAFE_SRCSET_PATTERN = /^(?:(?:https?|file):|[^&:/?#]*(?:[/?#]|$))/gi;\n/**\n * A pattern that matches safe data URLs. Only matches image, video and audio types.\n */\nconst /** @type {?} */ DATA_URL_PATTERN =\n    /^data:(?:image\\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\\/(?:mpeg|mp4|ogg|webm)|audio\\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\\/]+=*$/i;\n/**\n * @param {?} url\n * @return {?}\n */\nexport function sanitizeUrl(url: string): string {\n  url = String(url);\n  if (url.match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN)) return url;\n\n  if (isDevMode()) {\n    getDOM().log(`WARNING: sanitizing unsafe URL value ${url} (see http://g.co/ng/security#xss)`);\n  }\n\n  return 'unsafe:' + url;\n}\n/**\n * @param {?} srcset\n * @return {?}\n */\nexport function sanitizeSrcset(srcset: string): string {\n  srcset = String(srcset);\n  return srcset.split(',').map((srcset) => sanitizeUrl(srcset.trim())).join(', ');\n}\n"]}