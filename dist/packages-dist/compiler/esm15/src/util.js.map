{"version":3,"sources":["../../../../packages/compiler/src/util.ts"],"names":[],"mappings":"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","file":"util.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ÉµisPromise as isPromise} from '@angular/core';\n\nimport * as o from './output/output_ast';\nimport {ParseError} from './parse_util';\n\nexport const /** @type {?} */ MODULE_SUFFIX = '';\n\nconst /** @type {?} */ CAMEL_CASE_REGEXP = /([A-Z])/g;\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function camelCaseToDashCase(input: string): string {\n  return input.replace(CAMEL_CASE_REGEXP, (...m: any[]) => '-' + m[1].toLowerCase());\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nexport function splitAtColon(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, ':', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} defaultValues\n * @return {?}\n */\nexport function splitAtPeriod(input: string, defaultValues: string[]): string[] {\n  return _splitAt(input, '.', defaultValues);\n}\n/**\n * @param {?} input\n * @param {?} character\n * @param {?} defaultValues\n * @return {?}\n */\nfunction _splitAt(input: string, character: string, defaultValues: string[]): string[] {\n  const /** @type {?} */ characterIndex = input.indexOf(character);\n  if (characterIndex == -1) return defaultValues;\n  return [input.slice(0, characterIndex).trim(), input.slice(characterIndex + 1).trim()];\n}\n/**\n * @param {?} value\n * @param {?} visitor\n * @param {?} context\n * @return {?}\n */\nexport function visitValue(value: any, visitor: ValueVisitor, context: any): any {\n  if (Array.isArray(value)) {\n    return visitor.visitArray( /** @type {?} */((<any[]>value)), context);\n  }\n\n  if (isStrictStringMap(value)) {\n    return visitor.visitStringMap( /** @type {?} */((<{[key: string]: any}>value)), context);\n  }\n\n  if (value == null || typeof value == 'string' || typeof value == 'number' ||\n      typeof value == 'boolean') {\n    return visitor.visitPrimitive(value, context);\n  }\n\n  return visitor.visitOther(value, context);\n}\n/**\n * @param {?} val\n * @return {?}\n */\nexport function isDefined(val: any): boolean {\n  return val !== null && val !== undefined;\n}\n/**\n * @template T\n * @param {?} val\n * @return {?}\n */\nexport function noUndefined<T>(val: T | undefined): T {\n  return val === undefined ? /** @type {?} */(( null)) : val;\n}\n/**\n * @record\n */\nexport function ValueVisitor() {}\n\n\nfunction ValueVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\nValueVisitor.prototype.visitArray;\n/** @type {?} */\nValueVisitor.prototype.visitStringMap;\n/** @type {?} */\nValueVisitor.prototype.visitPrimitive;\n/** @type {?} */\nValueVisitor.prototype.visitOther;\n}\n\n\nexport interface ValueVisitor {\n  visitArray(arr: any[], context: any): any;\n  visitStringMap(map: {[key: string]: any}, context: any): any;\n  visitPrimitive(value: any, context: any): any;\n  visitOther(value: any, context: any): any;\n}\nexport class ValueTransformer implements ValueVisitor {\n/**\n * @param {?} arr\n * @param {?} context\n * @return {?}\n */\nvisitArray(arr: any[], context: any): any {\n    return arr.map(value => visitValue(value, this, context));\n  }\n/**\n * @param {?} map\n * @param {?} context\n * @return {?}\n */\nvisitStringMap(map: {[key: string]: any}, context: any): any {\n    const /** @type {?} */ result: {[key: string]: any} = {};\n    Object.keys(map).forEach(key => { result[key] = visitValue(map[key], this, context); });\n    return result;\n  }\n/**\n * @param {?} value\n * @param {?} context\n * @return {?}\n */\nvisitPrimitive(value: any, context: any): any { return value; }\n/**\n * @param {?} value\n * @param {?} context\n * @return {?}\n */\nvisitOther(value: any, context: any): any { return value; }\n}\n\nexport type SyncAsync<T> = T | Promise<T>;\n\nexport const /** @type {?} */ SyncAsync = {\n  assertSync: <T>(value: SyncAsync<T>): T => {\n    if (isPromise(value)) {\n      throw new Error(`Illegal state: value cannot be a promise`);\n    }\n    return value;\n  },\n  then: <T, R>(value: SyncAsync<T>, cb: (value: T) => R | Promise<R>| SyncAsync<R>):\n            SyncAsync<R> => { return isPromise(value) ? value.then(cb) : cb(value);},\n  all: <T>(syncAsyncValues: SyncAsync<T>[]): SyncAsync<T[]> => {\n    return syncAsyncValues.some(isPromise) ? Promise.all(syncAsyncValues) : /** @type {?} */(( syncAsyncValues as T[]));\n  }\n};\n/**\n * @param {?} msg\n * @param {?=} parseErrors\n * @return {?}\n */\nexport function syntaxError(msg: string, parseErrors?: ParseError[]): Error {\n  const /** @type {?} */ error = Error(msg);\n  ( /** @type {?} */((error as any)))[ERROR_SYNTAX_ERROR] = true;\n  if (parseErrors) ( /** @type {?} */((error as any)))[ERROR_PARSE_ERRORS] = parseErrors;\n  return error;\n}\n\nconst /** @type {?} */ ERROR_SYNTAX_ERROR = 'ngSyntaxError';\nconst /** @type {?} */ ERROR_PARSE_ERRORS = 'ngParseErrors';\n/**\n * @param {?} error\n * @return {?}\n */\nexport function isSyntaxError(error: Error): boolean {\n  return ( /** @type {?} */((error as any)))[ERROR_SYNTAX_ERROR];\n}\n/**\n * @param {?} error\n * @return {?}\n */\nexport function getParseErrors(error: Error): ParseError[] {\n  return ( /** @type {?} */((error as any)))[ERROR_PARSE_ERRORS] || [];\n}\n/**\n * @param {?} s\n * @return {?}\n */\nexport function escapeRegExp(s: string): string {\n  return s.replace(/([.*+?^=!:${}()|[\\]\\/\\\\])/g, '\\\\$1');\n}\n\nconst /** @type {?} */ STRING_MAP_PROTO = Object.getPrototypeOf({});\n/**\n * @param {?} obj\n * @return {?}\n */\nfunction isStrictStringMap(obj: any): boolean {\n  return typeof obj === 'object' && obj !== null && Object.getPrototypeOf(obj) === STRING_MAP_PROTO;\n}\n/**\n * @param {?} str\n * @return {?}\n */\nexport function utf8Encode(str: string): string {\n  let /** @type {?} */ encoded = '';\n  for (let /** @type {?} */ index = 0; index < str.length; index++) {\n    let /** @type {?} */ codePoint = str.charCodeAt(index);\n\n    // decode surrogate\n    // see https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n    if (codePoint >= 0xd800 && codePoint <= 0xdbff && str.length > (index + 1)) {\n      const /** @type {?} */ low = str.charCodeAt(index + 1);\n      if (low >= 0xdc00 && low <= 0xdfff) {\n        index++;\n        codePoint = ((codePoint - 0xd800) << 10) + low - 0xdc00 + 0x10000;\n      }\n    }\n\n    if (codePoint <= 0x7f) {\n      encoded += String.fromCharCode(codePoint);\n    } else if (codePoint <= 0x7ff) {\n      encoded += String.fromCharCode(((codePoint >> 6) & 0x1F) | 0xc0, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0xffff) {\n      encoded += String.fromCharCode(\n          (codePoint >> 12) | 0xe0, ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    } else if (codePoint <= 0x1fffff) {\n      encoded += String.fromCharCode(\n          ((codePoint >> 18) & 0x07) | 0xf0, ((codePoint >> 12) & 0x3f) | 0x80,\n          ((codePoint >> 6) & 0x3f) | 0x80, (codePoint & 0x3f) | 0x80);\n    }\n  }\n\n  return encoded;\n}\n/**\n * @record\n */\nexport function OutputContext() {}\n\n\nfunction OutputContext_tsickle_Closure_declarations() {\n/** @type {?} */\nOutputContext.prototype.genFilePath;\n/** @type {?} */\nOutputContext.prototype.statements;\n/** @type {?} */\nOutputContext.prototype.importExpr;\n}\n\n\nexport interface OutputContext {\n  genFilePath: string;\n  statements: o.Statement[];\n  importExpr(reference: any, typeParams?: o.Type[]|null): o.Expression;\n}\n"]}