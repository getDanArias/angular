{"version":3,"sources":["../../../../../packages/compiler/src/template_parser/binding_parser.ts"],"names":[],"mappings":"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","file":"binding_parser.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SecurityContext} from '@angular/core';\n\nimport {CompileDirectiveSummary, CompilePipeSummary} from '../compile_metadata';\nimport {ASTWithSource, BindingPipe, EmptyExpr, ParserError, RecursiveAstVisitor, TemplateBinding} from '../expression_parser/ast';\nimport {Parser} from '../expression_parser/parser';\nimport {InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {mergeNsAndName} from '../ml_parser/tags';\nimport {ParseError, ParseErrorLevel, ParseSourceSpan} from '../parse_util';\nimport {ElementSchemaRegistry} from '../schema/element_schema_registry';\nimport {CssSelector} from '../selector';\nimport {splitAtColon, splitAtPeriod} from '../util';\n\nimport {BoundElementPropertyAst, BoundEventAst, PropertyBindingType, VariableAst} from './template_ast';\n\nconst /** @type {?} */ PROPERTY_PARTS_SEPARATOR = '.';\nconst /** @type {?} */ ATTRIBUTE_PREFIX = 'attr';\nconst /** @type {?} */ CLASS_PREFIX = 'class';\nconst /** @type {?} */ STYLE_PREFIX = 'style';\n\nconst /** @type {?} */ ANIMATE_PROP_PREFIX = 'animate-';\nexport type BoundPropertyType = number;\nexport let BoundPropertyType: any = {};\nBoundPropertyType.DEFAULT = 0;\nBoundPropertyType.LITERAL_ATTR = 1;\nBoundPropertyType.ANIMATION = 2;\nBoundPropertyType[BoundPropertyType.DEFAULT] = \"DEFAULT\";\nBoundPropertyType[BoundPropertyType.LITERAL_ATTR] = \"LITERAL_ATTR\";\nBoundPropertyType[BoundPropertyType.ANIMATION] = \"ANIMATION\";\n\n/**\n * Represents a parsed property.\n */\nexport class BoundProperty {\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} type\n * @param {?} sourceSpan\n */\nconstructor(\npublic name: string,\npublic expression: ASTWithSource,\npublic type: BoundPropertyType,\npublic sourceSpan: ParseSourceSpan) {}\n/**\n * @return {?}\n */\nget isLiteral() { return this.type === BoundPropertyType.LITERAL_ATTR; }\n/**\n * @return {?}\n */\nget isAnimation() { return this.type === BoundPropertyType.ANIMATION; }\n}\n\nfunction BoundProperty_tsickle_Closure_declarations() {\n/** @type {?} */\nBoundProperty.prototype.name;\n/** @type {?} */\nBoundProperty.prototype.expression;\n/** @type {?} */\nBoundProperty.prototype.type;\n/** @type {?} */\nBoundProperty.prototype.sourceSpan;\n}\n\n/**\n * Parses bindings in templates and in the directive host area.\n */\nexport class BindingParser {\n  pipesByName: Map<string, CompilePipeSummary> = new Map();\nprivate _usedPipes: Map<string, CompilePipeSummary> = new Map();\n/**\n * @param {?} _exprParser\n * @param {?} _interpolationConfig\n * @param {?} _schemaRegistry\n * @param {?} pipes\n * @param {?} _targetErrors\n */\nconstructor(\nprivate _exprParser: Parser,\nprivate _interpolationConfig: InterpolationConfig,\nprivate _schemaRegistry: ElementSchemaRegistry, pipes: CompilePipeSummary[],\nprivate _targetErrors: ParseError[]) {\n    pipes.forEach(pipe => this.pipesByName.set(pipe.name, pipe));\n  }\n/**\n * @return {?}\n */\ngetUsedPipes(): CompilePipeSummary[] { return Array.from(this._usedPipes.values()); }\n/**\n * @param {?} dirMeta\n * @param {?} elementSelector\n * @param {?} sourceSpan\n * @return {?}\n */\ncreateDirectiveHostPropertyAsts(\n      dirMeta: CompileDirectiveSummary, elementSelector: string,\n      sourceSpan: ParseSourceSpan): BoundElementPropertyAst[]|null {\n    if (dirMeta.hostProperties) {\n      const /** @type {?} */ boundProps: BoundProperty[] = [];\n      Object.keys(dirMeta.hostProperties).forEach(propName => {\n        const /** @type {?} */ expression = dirMeta.hostProperties[propName];\n        if (typeof expression === 'string') {\n          this.parsePropertyBinding(propName, expression, true, sourceSpan, [], boundProps);\n        } else {\n          this._reportError(\n              `Value of the host property binding \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return boundProps.map((prop) => this.createElementPropertyAst(elementSelector, prop));\n    }\n    return null;\n  }\n/**\n * @param {?} dirMeta\n * @param {?} sourceSpan\n * @return {?}\n */\ncreateDirectiveHostEventAsts(dirMeta: CompileDirectiveSummary, sourceSpan: ParseSourceSpan):\n      BoundEventAst[]|null {\n    if (dirMeta.hostListeners) {\n      const /** @type {?} */ targetEventAsts: BoundEventAst[] = [];\n      Object.keys(dirMeta.hostListeners).forEach(propName => {\n        const /** @type {?} */ expression = dirMeta.hostListeners[propName];\n        if (typeof expression === 'string') {\n          this.parseEvent(propName, expression, sourceSpan, [], targetEventAsts);\n        } else {\n          this._reportError(\n              `Value of the host listener \"${propName}\" needs to be a string representing an expression but got \"${expression}\" (${typeof expression})`,\n              sourceSpan);\n        }\n      });\n      return targetEventAsts;\n    }\n    return null;\n  }\n/**\n * @param {?} value\n * @param {?} sourceSpan\n * @return {?}\n */\nparseInterpolation(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ ast = /** @type {?} */((\n          this._exprParser.parseInterpolation(value, sourceInfo, this._interpolationConfig)));\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n/**\n * @param {?} prefixToken\n * @param {?} value\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @param {?} targetVars\n * @return {?}\n */\nparseInlineTemplateBinding(\n      prefixToken: string, value: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[], targetVars: VariableAst[]) {\n    const /** @type {?} */ bindings = this._parseTemplateBindings(prefixToken, value, sourceSpan);\n    for (let /** @type {?} */ i = 0; i < bindings.length; i++) {\n      const /** @type {?} */ binding = bindings[i];\n      if (binding.keyIsVar) {\n        targetVars.push(new VariableAst(binding.key, binding.name, sourceSpan));\n      } else if (binding.expression) {\n        this._parsePropertyAst(\n            binding.key, binding.expression, sourceSpan, targetMatchableAttrs, targetProps);\n      } else {\n        targetMatchableAttrs.push([binding.key, '']);\n        this.parseLiteralAttr(binding.key, null, sourceSpan, targetMatchableAttrs, targetProps);\n      }\n    }\n  }\n/**\n * @param {?} prefixToken\n * @param {?} value\n * @param {?} sourceSpan\n * @return {?}\n */\n\nprivate _parseTemplateBindings(prefixToken: string, value: string, sourceSpan: ParseSourceSpan):\n      TemplateBinding[] {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ bindingsResult = this._exprParser.parseTemplateBindings(prefixToken, value, sourceInfo);\n      this._reportExpressionParserErrors(bindingsResult.errors, sourceSpan);\n      bindingsResult.templateBindings.forEach((binding) => {\n        if (binding.expression) {\n          this._checkPipes(binding.expression, sourceSpan);\n        }\n      });\n      bindingsResult.warnings.forEach(\n          (warning) => { this._reportError(warning, sourceSpan, ParseErrorLevel.WARNING); });\n      return bindingsResult.templateBindings;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return [];\n    }\n  }\n/**\n * @param {?} name\n * @param {?} value\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nparseLiteralAttr(\n      name: string, value: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    if (_isAnimationLabel(name)) {\n      name = name.substring(1);\n      if (value) {\n        this._reportError(\n            `Assigning animation triggers via @prop=\"exp\" attributes with an expression is invalid.` +\n                ` Use property bindings (e.g. [@prop]=\"exp\") or use an attribute without a value (e.g. @prop) instead.`,\n            sourceSpan, ParseErrorLevel.ERROR);\n      }\n      this._parseAnimation(name, value, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      targetProps.push(new BoundProperty(\n          name, this._exprParser.wrapLiteralPrimitive(value, ''), BoundPropertyType.LITERAL_ATTR,\n          sourceSpan));\n    }\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} isHost\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nparsePropertyBinding(\n      name: string, expression: string, isHost: boolean, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    let /** @type {?} */ isAnimationProp = false;\n    if (name.startsWith(ANIMATE_PROP_PREFIX)) {\n      isAnimationProp = true;\n      name = name.substring(ANIMATE_PROP_PREFIX.length);\n    } else if (_isAnimationLabel(name)) {\n      isAnimationProp = true;\n      name = name.substring(1);\n    }\n\n    if (isAnimationProp) {\n      this._parseAnimation(name, expression, sourceSpan, targetMatchableAttrs, targetProps);\n    } else {\n      this._parsePropertyAst(\n          name, this._parseBinding(expression, isHost, sourceSpan), sourceSpan,\n          targetMatchableAttrs, targetProps);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} value\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\nparsePropertyInterpolation(\n      name: string, value: string, sourceSpan: ParseSourceSpan, targetMatchableAttrs: string[][],\n      targetProps: BoundProperty[]): boolean {\n    const /** @type {?} */ expr = this.parseInterpolation(value, sourceSpan);\n    if (expr) {\n      this._parsePropertyAst(name, expr, sourceSpan, targetMatchableAttrs, targetProps);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} name\n * @param {?} ast\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\n\nprivate _parsePropertyAst(\n      name: string, ast: ASTWithSource, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    targetMatchableAttrs.push([name, /** @type {?} */(( ast.source))]);\n    targetProps.push(new BoundProperty(name, ast, BoundPropertyType.DEFAULT, sourceSpan));\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetProps\n * @return {?}\n */\n\nprivate _parseAnimation(\n      name: string, expression: string|null, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetProps: BoundProperty[]) {\n    // This will occur when a @trigger is not paired with an expression.\n    // For animations it is valid to not have an expression since */void\n    // states will be applied by angular when the element is attached/detached\n    const /** @type {?} */ ast = this._parseBinding(expression || 'null', false, sourceSpan);\n    targetMatchableAttrs.push([name, /** @type {?} */(( ast.source))]);\n    targetProps.push(new BoundProperty(name, ast, BoundPropertyType.ANIMATION, sourceSpan));\n  }\n/**\n * @param {?} value\n * @param {?} isHostBinding\n * @param {?} sourceSpan\n * @return {?}\n */\n\nprivate _parseBinding(value: string, isHostBinding: boolean, sourceSpan: ParseSourceSpan):\n      ASTWithSource {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ ast = isHostBinding ?\n          this._exprParser.parseSimpleBinding(value, sourceInfo, this._interpolationConfig) :\n          this._exprParser.parseBinding(value, sourceInfo, this._interpolationConfig);\n      if (ast) this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n/**\n * @param {?} elementSelector\n * @param {?} boundProp\n * @return {?}\n */\ncreateElementPropertyAst(elementSelector: string, boundProp: BoundProperty):\n      BoundElementPropertyAst {\n    if (boundProp.isAnimation) {\n      return new BoundElementPropertyAst(\n          boundProp.name, PropertyBindingType.Animation, SecurityContext.NONE, boundProp.expression,\n          null, boundProp.sourceSpan);\n    }\n\n    let /** @type {?} */ unit: string|null = null;\n    let /** @type {?} */ bindingType: PropertyBindingType = /** @type {?} */(( undefined));\n    let /** @type {?} */ boundPropertyName: string|null = null;\n    const /** @type {?} */ parts = boundProp.name.split(PROPERTY_PARTS_SEPARATOR);\n    let /** @type {?} */ securityContexts: SecurityContext[] = /** @type {?} */(( undefined));\n\n    // Check check for special cases (prefix style, attr, class)\n    if (parts.length > 1) {\n      if (parts[0] == ATTRIBUTE_PREFIX) {\n        boundPropertyName = parts[1];\n        this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, true);\n        securityContexts = calcPossibleSecurityContexts(\n            this._schemaRegistry, elementSelector, boundPropertyName, true);\n\n        const /** @type {?} */ nsSeparatorIdx = boundPropertyName.indexOf(':');\n        if (nsSeparatorIdx > -1) {\n          const /** @type {?} */ ns = boundPropertyName.substring(0, nsSeparatorIdx);\n          const /** @type {?} */ name = boundPropertyName.substring(nsSeparatorIdx + 1);\n          boundPropertyName = mergeNsAndName(ns, name);\n        }\n\n        bindingType = PropertyBindingType.Attribute;\n      } else if (parts[0] == CLASS_PREFIX) {\n        boundPropertyName = parts[1];\n        bindingType = PropertyBindingType.Class;\n        securityContexts = [SecurityContext.NONE];\n      } else if (parts[0] == STYLE_PREFIX) {\n        unit = parts.length > 2 ? parts[2] : null;\n        boundPropertyName = parts[1];\n        bindingType = PropertyBindingType.Style;\n        securityContexts = [SecurityContext.STYLE];\n      }\n    }\n\n    // If not a special case, use the full property name\n    if (boundPropertyName === null) {\n      boundPropertyName = this._schemaRegistry.getMappedPropName(boundProp.name);\n      securityContexts = calcPossibleSecurityContexts(\n          this._schemaRegistry, elementSelector, boundPropertyName, false);\n      bindingType = PropertyBindingType.Property;\n      this._validatePropertyOrAttributeName(boundPropertyName, boundProp.sourceSpan, false);\n    }\n\n    return new BoundElementPropertyAst(\n        boundPropertyName, bindingType, securityContexts[0], boundProp.expression, unit,\n        boundProp.sourceSpan);\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetEvents\n * @return {?}\n */\nparseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: BoundEventAst[]) {\n    if (_isAnimationLabel(name)) {\n      name = name.substr(1);\n      this._parseAnimationEvent(name, expression, sourceSpan, targetEvents);\n    } else {\n      this._parseEvent(name, expression, sourceSpan, targetMatchableAttrs, targetEvents);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetEvents\n * @return {?}\n */\n\nprivate _parseAnimationEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetEvents: BoundEventAst[]) {\n    const /** @type {?} */ matches = splitAtPeriod(name, [name, '']);\n    const /** @type {?} */ eventName = matches[0];\n    const /** @type {?} */ phase = matches[1].toLowerCase();\n    if (phase) {\n      switch (phase) {\n        case 'start':\n        case 'done':\n          const /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n          targetEvents.push(new BoundEventAst(eventName, null, phase, ast, sourceSpan));\n          break;\n\n        default:\n          this._reportError(\n              `The provided animation output phase value \"${phase}\" for \"@${eventName}\" is not supported (use start or done)`,\n              sourceSpan);\n          break;\n      }\n    } else {\n      this._reportError(\n          `The animation trigger output event (@${eventName}) is missing its phase value name (start or done are currently supported)`,\n          sourceSpan);\n    }\n  }\n/**\n * @param {?} name\n * @param {?} expression\n * @param {?} sourceSpan\n * @param {?} targetMatchableAttrs\n * @param {?} targetEvents\n * @return {?}\n */\n\nprivate _parseEvent(\n      name: string, expression: string, sourceSpan: ParseSourceSpan,\n      targetMatchableAttrs: string[][], targetEvents: BoundEventAst[]) {\n    // long format: 'target: eventName'\n    const [target, eventName] = splitAtColon(name, [ /** @type {?} */((null)), name]);\n    const /** @type {?} */ ast = this._parseAction(expression, sourceSpan);\n    targetMatchableAttrs.push([ /** @type {?} */((name)), /** @type {?} */(( ast.source))]);\n    targetEvents.push(new BoundEventAst(eventName, target, null, ast, sourceSpan));\n    // Don't detect directives for event names for now,\n    // so don't add the event name to the matchableAttrs\n  }\n/**\n * @param {?} value\n * @param {?} sourceSpan\n * @return {?}\n */\n\nprivate _parseAction(value: string, sourceSpan: ParseSourceSpan): ASTWithSource {\n    const /** @type {?} */ sourceInfo = sourceSpan.start.toString();\n\n    try {\n      const /** @type {?} */ ast = this._exprParser.parseAction(value, sourceInfo, this._interpolationConfig);\n      if (ast) {\n        this._reportExpressionParserErrors(ast.errors, sourceSpan);\n      }\n      if (!ast || ast.ast instanceof EmptyExpr) {\n        this._reportError(`Empty expressions are not allowed`, sourceSpan);\n        return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n      }\n      this._checkPipes(ast, sourceSpan);\n      return ast;\n    } catch ( /** @type {?} */e) {\n      this._reportError(`${e}`, sourceSpan);\n      return this._exprParser.wrapLiteralPrimitive('ERROR', sourceInfo);\n    }\n  }\n/**\n * @param {?} message\n * @param {?} sourceSpan\n * @param {?=} level\n * @return {?}\n */\n\nprivate _reportError(\n      message: string, sourceSpan: ParseSourceSpan,\n      level: ParseErrorLevel = ParseErrorLevel.ERROR) {\n    this._targetErrors.push(new ParseError(sourceSpan, message, level));\n  }\n/**\n * @param {?} errors\n * @param {?} sourceSpan\n * @return {?}\n */\n\nprivate _reportExpressionParserErrors(errors: ParserError[], sourceSpan: ParseSourceSpan) {\n    for (const /** @type {?} */ error of errors) {\n      this._reportError(error.message, sourceSpan);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} sourceSpan\n * @return {?}\n */\n\nprivate _checkPipes(ast: ASTWithSource, sourceSpan: ParseSourceSpan) {\n    if (ast) {\n      const /** @type {?} */ collector = new PipeCollector();\n      ast.visit(collector);\n      collector.pipes.forEach((ast, pipeName) => {\n        const /** @type {?} */ pipeMeta = this.pipesByName.get(pipeName);\n        if (!pipeMeta) {\n          this._reportError(\n              `The pipe '${pipeName}' could not be found`,\n              new ParseSourceSpan(\n                  sourceSpan.start.moveBy(ast.span.start), sourceSpan.start.moveBy(ast.span.end)));\n        } else {\n          this._usedPipes.set(pipeName, pipeMeta);\n        }\n      });\n    }\n  }\n/**\n * @param {?} propName the name of the property / attribute\n * @param {?} sourceSpan\n * @param {?} isAttr true when binding to an attribute\n * @return {?}\n */\n\nprivate _validatePropertyOrAttributeName(\n      propName: string, sourceSpan: ParseSourceSpan, isAttr: boolean): void {\n    const /** @type {?} */ report = isAttr ? this._schemaRegistry.validateAttribute(propName) :\n                            this._schemaRegistry.validateProperty(propName);\n    if (report.error) {\n      this._reportError( /** @type {?} */((report.msg)), sourceSpan, ParseErrorLevel.ERROR);\n    }\n  }\n}\n\nfunction BindingParser_tsickle_Closure_declarations() {\n/** @type {?} */\nBindingParser.prototype.pipesByName;\n/** @type {?} */\nBindingParser.prototype._usedPipes;\n/** @type {?} */\nBindingParser.prototype._exprParser;\n/** @type {?} */\nBindingParser.prototype._interpolationConfig;\n/** @type {?} */\nBindingParser.prototype._schemaRegistry;\n/** @type {?} */\nBindingParser.prototype._targetErrors;\n}\n\nexport class PipeCollector extends RecursiveAstVisitor {\n  pipes = new Map<string, BindingPipe>();\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPipe(ast: BindingPipe, context: any): any {\n    this.pipes.set(ast.name, ast);\n    ast.exp.visit(this);\n    this.visitAll(ast.args, context);\n    return null;\n  }\n}\n\nfunction PipeCollector_tsickle_Closure_declarations() {\n/** @type {?} */\nPipeCollector.prototype.pipes;\n}\n\n/**\n * @param {?} name\n * @return {?}\n */\nfunction _isAnimationLabel(name: string): boolean {\n  return name[0] == '@';\n}\n/**\n * @param {?} registry\n * @param {?} selector\n * @param {?} propName\n * @param {?} isAttribute\n * @return {?}\n */\nexport function calcPossibleSecurityContexts(\n    registry: ElementSchemaRegistry, selector: string, propName: string,\n    isAttribute: boolean): SecurityContext[] {\n  const /** @type {?} */ ctxs: SecurityContext[] = [];\n  CssSelector.parse(selector).forEach((selector) => {\n    const /** @type {?} */ elementNames = selector.element ? [selector.element] : registry.allKnownElementNames();\n    const /** @type {?} */ notElementNames =\n        new Set(selector.notSelectors.filter(selector => selector.isElementSelector())\n                    .map((selector) => selector.element));\n    const /** @type {?} */ possibleElementNames =\n        elementNames.filter(elementName => !notElementNames.has(elementName));\n\n    ctxs.push(...possibleElementNames.map(\n        elementName => registry.securityContext(elementName, propName, isAttribute)));\n  });\n  return ctxs.length === 0 ? [SecurityContext.NONE] : Array.from(new Set(ctxs)).sort();\n}\n"]}