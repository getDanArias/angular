{"version":3,"sources":["../../../../../packages/compiler/src/aot/static_symbol_resolver.ts"],"names":[],"mappings":"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","file":"static_symbol_resolver.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {SummaryResolver} from '../summary_resolver';\nimport {ValueTransformer, visitValue} from '../util';\n\nimport {StaticSymbol, StaticSymbolCache} from './static_symbol';\nimport {isGeneratedFile, stripSummaryForJitFileSuffix, stripSummaryForJitNameSuffix, summaryForJitFileName, summaryForJitName} from './util';\nexport class ResolvedStaticSymbol {\n/**\n * @param {?} symbol\n * @param {?} metadata\n */\nconstructor(public symbol: StaticSymbol,\npublic metadata: any) {}\n}\n\nfunction ResolvedStaticSymbol_tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedStaticSymbol.prototype.symbol;\n/** @type {?} */\nResolvedStaticSymbol.prototype.metadata;\n}\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n * @record\n */\nexport function StaticSymbolResolverHost() {}\n\n\nfunction StaticSymbolResolverHost_tsickle_Closure_declarations() {\n/**\n * Return a ModuleMetadata for the given module.\n * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n * produced and the module has exported variables or classes with decorators. Module metadata can\n * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n * \n * \\@param modulePath is a string identifier for a module as an absolute path.\n * \\@return the metadata for the given module.\n * @type {?}\n */\nStaticSymbolResolverHost.prototype.getMetadataFor;\n/**\n * Converts a module name that is used in an `import` to a file path.\n * I.e.\n * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n * @type {?}\n */\nStaticSymbolResolverHost.prototype.moduleNameToFileName;\n/**\n * Converts a file path to a module name that can be used as an `import.\n * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n * \n * See ImportResolver.\n * @type {?}\n */\nStaticSymbolResolverHost.prototype.fileNameToModuleName;\n}\n\n\n/**\n * The host of the SymbolResolverHost disconnects the implementation from TypeScript / other\n * language\n * services and from underlying file systems.\n */\nexport interface StaticSymbolResolverHost {\n  /**\n   * Return a ModuleMetadata for the given module.\n   * Angular CLI will produce this metadata for a module whenever a .d.ts files is\n   * produced and the module has exported variables or classes with decorators. Module metadata can\n   * also be produced directly from TypeScript sources by using MetadataCollector in tools/metadata.\n   *\n   * @param modulePath is a string identifier for a module as an absolute path.\n   * @returns the metadata for the given module.\n   */\n  getMetadataFor(modulePath: string): {[key: string]: any}[]|undefined;\n\n  /**\n   * Converts a module name that is used in an `import` to a file path.\n   * I.e.\n   * `path/to/containingFile.ts` containing `import {...} from 'module-name'`.\n   */\n  moduleNameToFileName(moduleName: string, containingFile?: string): string|null;\n  /**\n   * Converts a file path to a module name that can be used as an `import.\n   * I.e. `path/to/importedFile.ts` should be imported by `path/to/containingFile.ts`.\n   *\n   * See ImportResolver.\n   */\n  fileNameToModuleName(importedFilePath: string, containingFilePath: string): string|null;\n}\n\nconst /** @type {?} */ SUPPORTED_SCHEMA_VERSION = 3;\n/**\n * This class is responsible for loading metadata per symbol,\n * and normalizing references between symbols.\n * \n * Internally, it only uses symbols without members,\n * and deduces the values for symbols with members based\n * on these symbols.\n */\nexport class StaticSymbolResolver {\nprivate metadataCache = new Map<string, {[key: string]: any}>();\nprivate resolvedSymbols = new Map<StaticSymbol, ResolvedStaticSymbol>();\nprivate resolvedFilePaths = new Set<string>();\nprivate importAs = new Map<StaticSymbol, StaticSymbol>();\nprivate symbolResourcePaths = new Map<StaticSymbol, string>();\nprivate symbolFromFile = new Map<string, StaticSymbol[]>();\nprivate knownFileNameToModuleNames = new Map<string, string>();\n/**\n * @param {?} host\n * @param {?} staticSymbolCache\n * @param {?} summaryResolver\n * @param {?=} errorRecorder\n */\nconstructor(\nprivate host: StaticSymbolResolverHost,\nprivate staticSymbolCache: StaticSymbolCache,\nprivate summaryResolver: SummaryResolver<StaticSymbol>,\nprivate errorRecorder?: (error: any, fileName?: string) => void) {}\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\nresolveSymbol(staticSymbol: StaticSymbol): ResolvedStaticSymbol {\n    if (staticSymbol.members.length > 0) {\n      return /** @type {?} */(( this._resolveSymbolMembers(staticSymbol)));\n    }\n    let /** @type {?} */ result = this.resolvedSymbols.get(staticSymbol);\n    if (result) {\n      return result;\n    }\n    result = /** @type {?} */(( this._resolveSymbolFromSummary(staticSymbol)));\n    if (result) {\n      return result;\n    }\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    this._createSymbolsOf(staticSymbol.filePath);\n    result = /** @type {?} */(( this.resolvedSymbols.get(staticSymbol)));\n    return result;\n  }\n/**\n * getImportAs produces a symbol that can be used to import the given symbol.\n * The import might be different than the symbol if the symbol is exported from\n * a library with a summary; in which case we want to import the symbol from the\n * ngfactory re-export instead of directly to avoid introducing a direct dependency\n * on an otherwise indirect dependency.\n * \n * @param {?} staticSymbol the symbol for which to generate a import symbol\n * @return {?}\n */\ngetImportAs(staticSymbol: StaticSymbol): StaticSymbol|null {\n    if (staticSymbol.members.length) {\n      const /** @type {?} */ baseSymbol = this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name);\n      const /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n      return baseImportAs ?\n          this.getStaticSymbol(baseImportAs.filePath, baseImportAs.name, staticSymbol.members) :\n          null;\n    }\n    const /** @type {?} */ summarizedFileName = stripSummaryForJitFileSuffix(staticSymbol.filePath);\n    if (summarizedFileName !== staticSymbol.filePath) {\n      const /** @type {?} */ summarizedName = stripSummaryForJitNameSuffix(staticSymbol.name);\n      const /** @type {?} */ baseSymbol =\n          this.getStaticSymbol(summarizedFileName, summarizedName, staticSymbol.members);\n      const /** @type {?} */ baseImportAs = this.getImportAs(baseSymbol);\n      return baseImportAs ?\n          this.getStaticSymbol(\n              summaryForJitFileName(baseImportAs.filePath), summaryForJitName(baseImportAs.name),\n              baseSymbol.members) :\n          null;\n    }\n    let /** @type {?} */ result = this.summaryResolver.getImportAs(staticSymbol);\n    if (!result) {\n      result = /** @type {?} */(( this.importAs.get(staticSymbol)));\n    }\n    return result;\n  }\n/**\n * getResourcePath produces the path to the original location of the symbol and should\n * be used to determine the relative location of resource references recorded in\n * symbol metadata.\n * @param {?} staticSymbol\n * @return {?}\n */\ngetResourcePath(staticSymbol: StaticSymbol): string {\n    return this.symbolResourcePaths.get(staticSymbol) || staticSymbol.filePath;\n  }\n/**\n * getTypeArity returns the number of generic type parameters the given symbol\n * has. If the symbol is not a type the result is null.\n * @param {?} staticSymbol\n * @return {?}\n */\ngetTypeArity(staticSymbol: StaticSymbol): number|null {\n    // If the file is a factory/ngsummary file, don't resolve the symbol as doing so would\n    // cause the metadata for an factory/ngsummary file to be loaded which doesn't exist.\n    // All references to generated classes must include the correct arity whenever\n    // generating code.\n    if (isGeneratedFile(staticSymbol.filePath)) {\n      return null;\n    }\n    let /** @type {?} */ resolvedSymbol = this.resolveSymbol(staticSymbol);\n    while (resolvedSymbol && resolvedSymbol.metadata instanceof StaticSymbol) {\n      resolvedSymbol = this.resolveSymbol(resolvedSymbol.metadata);\n    }\n    return (resolvedSymbol && resolvedSymbol.metadata && resolvedSymbol.metadata.arity) || null;\n  }\n/**\n * Converts a file path to a module name that can be used as an `import`.\n * @param {?} importedFilePath\n * @param {?} containingFilePath\n * @return {?}\n */\nfileNameToModuleName(importedFilePath: string, containingFilePath: string): string|null {\n    return this.knownFileNameToModuleNames.get(importedFilePath) ||\n        this.host.fileNameToModuleName(importedFilePath, containingFilePath);\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} targetSymbol\n * @return {?}\n */\nrecordImportAs(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol) {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    this.importAs.set(sourceSymbol, targetSymbol);\n  }\n/**\n * Invalidate all information derived from the given file.\n * \n * @param {?} fileName the file to invalidate\n * @return {?}\n */\ninvalidateFile(fileName: string) {\n    this.metadataCache.delete(fileName);\n    this.resolvedFilePaths.delete(fileName);\n    const /** @type {?} */ symbols = this.symbolFromFile.get(fileName);\n    if (symbols) {\n      this.symbolFromFile.delete(fileName);\n      for (const /** @type {?} */ symbol of symbols) {\n        this.resolvedSymbols.delete(symbol);\n        this.importAs.delete(symbol);\n        this.symbolResourcePaths.delete(symbol);\n      }\n    }\n  }\n/**\n * @template T\n * @param {?} cb\n * @return {?}\n */\nignoreErrorsFor<T>(cb: () => T) {\n    const /** @type {?} */ recorder = this.errorRecorder;\n    this.errorRecorder = () => {};\n    try {\n      return cb();\n    } finally {\n      this.errorRecorder = recorder;\n    }\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\n\nprivate _resolveSymbolMembers(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const /** @type {?} */ members = staticSymbol.members;\n    const /** @type {?} */ baseResolvedSymbol =\n        this.resolveSymbol(this.getStaticSymbol(staticSymbol.filePath, staticSymbol.name));\n    if (!baseResolvedSymbol) {\n      return null;\n    }\n    const /** @type {?} */ baseMetadata = baseResolvedSymbol.metadata;\n    if (baseMetadata instanceof StaticSymbol) {\n      return new ResolvedStaticSymbol(\n          staticSymbol, this.getStaticSymbol(baseMetadata.filePath, baseMetadata.name, members));\n    } else if (baseMetadata && baseMetadata.__symbolic === 'class') {\n      if (baseMetadata.statics && members.length === 1) {\n        return new ResolvedStaticSymbol(staticSymbol, baseMetadata.statics[members[0]]);\n      }\n    } else {\n      let /** @type {?} */ value = baseMetadata;\n      for (let /** @type {?} */ i = 0; i < members.length && value; i++) {\n        value = value[members[i]];\n      }\n      return new ResolvedStaticSymbol(staticSymbol, value);\n    }\n    return null;\n  }\n/**\n * @param {?} staticSymbol\n * @return {?}\n */\n\nprivate _resolveSymbolFromSummary(staticSymbol: StaticSymbol): ResolvedStaticSymbol|null {\n    const /** @type {?} */ summary = this.summaryResolver.resolveSummary(staticSymbol);\n    return summary ? new ResolvedStaticSymbol(staticSymbol, summary.metadata) : null;\n  }\n/**\n * getStaticSymbol produces a Type whose metadata is known but whose implementation is not loaded.\n * All types passed to the StaticResolver should be pseudo-types returned by this method.\n * \n * @param {?} declarationFile the absolute path of the file where the symbol is declared\n * @param {?} name the name of the type.\n * @param {?=} members a symbol for a static member of the named type\n * @return {?}\n */\ngetStaticSymbol(declarationFile: string, name: string, members?: string[]): StaticSymbol {\n    return this.staticSymbolCache.get(declarationFile, name, members);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\ngetSymbolsOf(filePath: string): StaticSymbol[] {\n    // Note: Some users use libraries that were not compiled with ngc, i.e. they don't\n    // have summaries, only .d.ts files. So we always need to check both, the summary\n    // and metadata.\n    let /** @type {?} */ symbols = new Set<StaticSymbol>(this.summaryResolver.getSymbolsOf(filePath));\n    this._createSymbolsOf(filePath);\n    this.resolvedSymbols.forEach((resolvedSymbol) => {\n      if (resolvedSymbol.symbol.filePath === filePath) {\n        symbols.add(resolvedSymbol.symbol);\n      }\n    });\n    return Array.from(symbols);\n  }\n/**\n * @param {?} filePath\n * @return {?}\n */\n\nprivate _createSymbolsOf(filePath: string) {\n    if (this.resolvedFilePaths.has(filePath)) {\n      return;\n    }\n    this.resolvedFilePaths.add(filePath);\n    const /** @type {?} */ resolvedSymbols: ResolvedStaticSymbol[] = [];\n    const /** @type {?} */ metadata = this.getModuleMetadata(filePath);\n    if (metadata['importAs']) {\n      // Index bundle indices should use the importAs module name defined\n      // in the bundle.\n      this.knownFileNameToModuleNames.set(filePath, metadata['importAs']);\n    }\n    if (metadata['metadata']) {\n      // handle direct declarations of the symbol\n      const /** @type {?} */ topLevelSymbolNames =\n          new Set<string>(Object.keys(metadata['metadata']).map(unescapeIdentifier));\n      const /** @type {?} */ origins: {[index: string]: string} = metadata['origins'] || {};\n      Object.keys(metadata['metadata']).forEach((metadataKey) => {\n        const /** @type {?} */ symbolMeta = metadata['metadata'][metadataKey];\n        const /** @type {?} */ name = unescapeIdentifier(metadataKey);\n\n        const /** @type {?} */ symbol = this.getStaticSymbol(filePath, name);\n\n        const /** @type {?} */ origin = origins.hasOwnProperty(metadataKey) && origins[metadataKey];\n        if (origin) {\n          // If the symbol is from a bundled index, use the declaration location of the\n          // symbol so relative references (such as './my.html') will be calculated\n          // correctly.\n          const /** @type {?} */ originFilePath = this.resolveModule(origin, filePath);\n          if (!originFilePath) {\n            this.reportError(\n                new Error(`Couldn't resolve original symbol for ${origin} from ${filePath}`));\n          } else {\n            this.symbolResourcePaths.set(symbol, originFilePath);\n          }\n        }\n        resolvedSymbols.push(\n            this.createResolvedSymbol(symbol, filePath, topLevelSymbolNames, symbolMeta));\n      });\n    }\n\n    // handle the symbols in one of the re-export location\n    if (metadata['exports']) {\n      for (const /** @type {?} */ moduleExport of metadata['exports']) {\n        // handle the symbols in the list of explicitly re-exported symbols.\n        if (moduleExport.export) {\n          moduleExport.export.forEach((exportSymbol: any) => {\n            let /** @type {?} */ symbolName: string;\n            if (typeof exportSymbol === 'string') {\n              symbolName = exportSymbol;\n            } else {\n              symbolName = exportSymbol.as;\n            }\n            symbolName = unescapeIdentifier(symbolName);\n            let /** @type {?} */ symName = symbolName;\n            if (typeof exportSymbol !== 'string') {\n              symName = unescapeIdentifier(exportSymbol.name);\n            }\n            const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n            if (resolvedModule) {\n              const /** @type {?} */ targetSymbol = this.getStaticSymbol(resolvedModule, symName);\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, symbolName);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            }\n          });\n        } else {\n          // handle the symbols via export * directives.\n          const /** @type {?} */ resolvedModule = this.resolveModule(moduleExport.from, filePath);\n          if (resolvedModule) {\n            const /** @type {?} */ nestedExports = this.getSymbolsOf(resolvedModule);\n            nestedExports.forEach((targetSymbol) => {\n              const /** @type {?} */ sourceSymbol = this.getStaticSymbol(filePath, targetSymbol.name);\n              resolvedSymbols.push(this.createExport(sourceSymbol, targetSymbol));\n            });\n          }\n        }\n      }\n    }\n    resolvedSymbols.forEach(\n        (resolvedSymbol) => this.resolvedSymbols.set(resolvedSymbol.symbol, resolvedSymbol));\n    this.symbolFromFile.set(filePath, resolvedSymbols.map(resolvedSymbol => resolvedSymbol.symbol));\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} topLevelPath\n * @param {?} topLevelSymbolNames\n * @param {?} metadata\n * @return {?}\n */\n\nprivate createResolvedSymbol(\n      sourceSymbol: StaticSymbol, topLevelPath: string, topLevelSymbolNames: Set<string>,\n      metadata: any): ResolvedStaticSymbol {\n    // For classes that don't have Angular summaries / metadata,\n    // we only keep their arity, but nothing else\n    // (e.g. their constructor parameters).\n    // We do this to prevent introducing deep imports\n    // as we didn't generate .ngfactory.ts files with proper reexports.\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath) && metadata &&\n        metadata['__symbolic'] === 'class') {\n      const /** @type {?} */ transformedMeta = {__symbolic: 'class', arity: metadata.arity};\n      return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n    }\n\n    const /** @type {?} */ self = this;\nclass ReferenceTransformer extends ValueTransformer {\n/**\n * @param {?} map\n * @param {?} functionParams\n * @return {?}\n */\nvisitStringMap(map: {[key: string]: any}, functionParams: string[]): any {\n        const /** @type {?} */ symbolic = map['__symbolic'];\n        if (symbolic === 'function') {\n          const /** @type {?} */ oldLen = functionParams.length;\n          functionParams.push(...(map['parameters'] || []));\n          const /** @type {?} */ result = super.visitStringMap(map, functionParams);\n          functionParams.length = oldLen;\n          return result;\n        } else if (symbolic === 'reference') {\n          const /** @type {?} */ module = map['module'];\n          const /** @type {?} */ name = map['name'] ? unescapeIdentifier(map['name']) : map['name'];\n          if (!name) {\n            return null;\n          }\n          let /** @type {?} */ filePath: string;\n          if (module) {\n            filePath = /** @type {?} */(( self.resolveModule(module, sourceSymbol.filePath)));\n            if (!filePath) {\n              return {\n                __symbolic: 'error',\n                message: `Could not resolve ${module} relative to ${sourceSymbol.filePath}.`\n              };\n            }\n            return self.getStaticSymbol(filePath, name);\n          } else if (functionParams.indexOf(name) >= 0) {\n            // reference to a function parameter\n            return {__symbolic: 'reference', name: name};\n          } else {\n            if (topLevelSymbolNames.has(name)) {\n              return self.getStaticSymbol(topLevelPath, name);\n            }\n            // ambient value\n            null;\n          }\n        } else {\n          return super.visitStringMap(map, functionParams);\n        }\n      }\n    }\n    const /** @type {?} */ transformedMeta = visitValue(metadata, new ReferenceTransformer(), []);\n    if (transformedMeta instanceof StaticSymbol) {\n      return this.createExport(sourceSymbol, transformedMeta);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, transformedMeta);\n  }\n/**\n * @param {?} sourceSymbol\n * @param {?} targetSymbol\n * @return {?}\n */\n\nprivate createExport(sourceSymbol: StaticSymbol, targetSymbol: StaticSymbol):\n      ResolvedStaticSymbol {\n    sourceSymbol.assertNoMembers();\n    targetSymbol.assertNoMembers();\n    if (this.summaryResolver.isLibraryFile(sourceSymbol.filePath)) {\n      // This case is for an ng library importing symbols from a plain ts library\n      // transitively.\n      // Note: We rely on the fact that we discover symbols in the direction\n      // from source files to library files\n      this.importAs.set(targetSymbol, this.getImportAs(sourceSymbol) || sourceSymbol);\n    }\n    return new ResolvedStaticSymbol(sourceSymbol, targetSymbol);\n  }\n/**\n * @param {?} error\n * @param {?=} context\n * @param {?=} path\n * @return {?}\n */\n\nprivate reportError(error: Error, context?: StaticSymbol, path?: string) {\n    if (this.errorRecorder) {\n      this.errorRecorder(error, (context && context.filePath) || path);\n    } else {\n      throw error;\n    }\n  }\n/**\n * @param {?} module an absolute path to a module file.\n * @return {?}\n */\n\nprivate getModuleMetadata(module: string): {[key: string]: any} {\n    let /** @type {?} */ moduleMetadata = this.metadataCache.get(module);\n    if (!moduleMetadata) {\n      const /** @type {?} */ moduleMetadatas = this.host.getMetadataFor(module);\n      if (moduleMetadatas) {\n        let /** @type {?} */ maxVersion = -1;\n        moduleMetadatas.forEach((md) => {\n          if (md['version'] > maxVersion) {\n            maxVersion = md['version'];\n            moduleMetadata = md;\n          }\n        });\n      }\n      if (!moduleMetadata) {\n        moduleMetadata =\n            {__symbolic: 'module', version: SUPPORTED_SCHEMA_VERSION, module: module, metadata: {}};\n      }\n      if (moduleMetadata['version'] != SUPPORTED_SCHEMA_VERSION) {\n        const /** @type {?} */ errorMessage = moduleMetadata['version'] == 2 ?\n            `Unsupported metadata version ${moduleMetadata['version']} for module ${module}. This module should be compiled with a newer version of ngc` :\n            `Metadata version mismatch for module ${module}, found version ${moduleMetadata['version']}, expected ${SUPPORTED_SCHEMA_VERSION}`;\n        this.reportError(new Error(errorMessage));\n      }\n      this.metadataCache.set(module, moduleMetadata);\n    }\n    return moduleMetadata;\n  }\n/**\n * @param {?} module\n * @param {?} symbolName\n * @param {?=} containingFile\n * @return {?}\n */\ngetSymbolByModule(module: string, symbolName: string, containingFile?: string): StaticSymbol {\n    const /** @type {?} */ filePath = this.resolveModule(module, containingFile);\n    if (!filePath) {\n      this.reportError(\n          new Error(`Could not resolve module ${module}${containingFile ? ` relative to $ {\n            containingFile\n          } `: ''}`));\n      return this.getStaticSymbol(`ERROR:${module}`, symbolName);\n    }\n    return this.getStaticSymbol(filePath, symbolName);\n  }\n/**\n * @param {?} module\n * @param {?=} containingFile\n * @return {?}\n */\n\nprivate resolveModule(module: string, containingFile?: string): string|null {\n    try {\n      return this.host.moduleNameToFileName(module, containingFile);\n    } catch ( /** @type {?} */e) {\n      console.error(`Could not resolve module '${module}' relative to file ${containingFile}`);\n      this.reportError(e, undefined, containingFile);\n    }\n    return null;\n  }\n}\n\nfunction StaticSymbolResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nStaticSymbolResolver.prototype.metadataCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedSymbols;\n/** @type {?} */\nStaticSymbolResolver.prototype.resolvedFilePaths;\n/** @type {?} */\nStaticSymbolResolver.prototype.importAs;\n/** @type {?} */\nStaticSymbolResolver.prototype.symbolResourcePaths;\n/** @type {?} */\nStaticSymbolResolver.prototype.symbolFromFile;\n/** @type {?} */\nStaticSymbolResolver.prototype.knownFileNameToModuleNames;\n/** @type {?} */\nStaticSymbolResolver.prototype.host;\n/** @type {?} */\nStaticSymbolResolver.prototype.staticSymbolCache;\n/** @type {?} */\nStaticSymbolResolver.prototype.summaryResolver;\n/** @type {?} */\nStaticSymbolResolver.prototype.errorRecorder;\n}\n\n/**\n * @param {?} identifier\n * @return {?}\n */\nexport function unescapeIdentifier(identifier: string): string {\n  return identifier.startsWith('___') ? identifier.substr(1) : identifier;\n}\n"]}