{"version":3,"sources":["../../../../../../packages/compiler/src/expression_parser/lexer.ts"],"names":[],"mappings":"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","file":"lexer.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {CompilerInjectable} from '../injectable';\nexport type TokenType = number;\nexport let TokenType: any = {};\nTokenType.Character = 0;\nTokenType.Identifier = 1;\nTokenType.Keyword = 2;\nTokenType.String = 3;\nTokenType.Operator = 4;\nTokenType.Number = 5;\nTokenType.Error = 6;\nTokenType[TokenType.Character] = \"Character\";\nTokenType[TokenType.Identifier] = \"Identifier\";\nTokenType[TokenType.Keyword] = \"Keyword\";\nTokenType[TokenType.String] = \"String\";\nTokenType[TokenType.Operator] = \"Operator\";\nTokenType[TokenType.Number] = \"Number\";\nTokenType[TokenType.Error] = \"Error\";\n\n\nconst /** @type {?} */ KEYWORDS = ['var', 'let', 'as', 'null', 'undefined', 'true', 'false', 'if', 'else', 'this'];\nexport class Lexer {\n/**\n * @param {?} text\n * @return {?}\n */\ntokenize(text: string): Token[] {\n    const /** @type {?} */ scanner = new _Scanner(text);\n    const /** @type {?} */ tokens: Token[] = [];\n    let /** @type {?} */ token = scanner.scanToken();\n    while (token != null) {\n      tokens.push(token);\n      token = scanner.scanToken();\n    }\n    return tokens;\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: CompilerInjectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction Lexer_tsickle_Closure_declarations() {\n/** @type {?} */\nLexer.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nLexer.ctorParameters;\n}\n\nexport class Token {\n/**\n * @param {?} index\n * @param {?} type\n * @param {?} numValue\n * @param {?} strValue\n */\nconstructor(\npublic index: number,\npublic type: TokenType,\npublic numValue: number,\npublic strValue: string) {}\n/**\n * @param {?} code\n * @return {?}\n */\nisCharacter(code: number): boolean {\n    return this.type == TokenType.Character && this.numValue == code;\n  }\n/**\n * @return {?}\n */\nisNumber(): boolean { return this.type == TokenType.Number; }\n/**\n * @return {?}\n */\nisString(): boolean { return this.type == TokenType.String; }\n/**\n * @param {?} operater\n * @return {?}\n */\nisOperator(operater: string): boolean {\n    return this.type == TokenType.Operator && this.strValue == operater;\n  }\n/**\n * @return {?}\n */\nisIdentifier(): boolean { return this.type == TokenType.Identifier; }\n/**\n * @return {?}\n */\nisKeyword(): boolean { return this.type == TokenType.Keyword; }\n/**\n * @return {?}\n */\nisKeywordLet(): boolean { return this.type == TokenType.Keyword && this.strValue == 'let'; }\n/**\n * @return {?}\n */\nisKeywordAs(): boolean { return this.type == TokenType.Keyword && this.strValue == 'as'; }\n/**\n * @return {?}\n */\nisKeywordNull(): boolean { return this.type == TokenType.Keyword && this.strValue == 'null'; }\n/**\n * @return {?}\n */\nisKeywordUndefined(): boolean {\n    return this.type == TokenType.Keyword && this.strValue == 'undefined';\n  }\n/**\n * @return {?}\n */\nisKeywordTrue(): boolean { return this.type == TokenType.Keyword && this.strValue == 'true'; }\n/**\n * @return {?}\n */\nisKeywordFalse(): boolean { return this.type == TokenType.Keyword && this.strValue == 'false'; }\n/**\n * @return {?}\n */\nisKeywordThis(): boolean { return this.type == TokenType.Keyword && this.strValue == 'this'; }\n/**\n * @return {?}\n */\nisError(): boolean { return this.type == TokenType.Error; }\n/**\n * @return {?}\n */\ntoNumber(): number { return this.type == TokenType.Number ? this.numValue : -1; }\n/**\n * @return {?}\n */\ntoString(): string|null {\n    switch (this.type) {\n      case TokenType.Character:\n      case TokenType.Identifier:\n      case TokenType.Keyword:\n      case TokenType.Operator:\n      case TokenType.String:\n      case TokenType.Error:\n        return this.strValue;\n      case TokenType.Number:\n        return this.numValue.toString();\n      default:\n        return null;\n    }\n  }\n}\n\nfunction Token_tsickle_Closure_declarations() {\n/** @type {?} */\nToken.prototype.index;\n/** @type {?} */\nToken.prototype.type;\n/** @type {?} */\nToken.prototype.numValue;\n/** @type {?} */\nToken.prototype.strValue;\n}\n\n/**\n * @param {?} index\n * @param {?} code\n * @return {?}\n */\nfunction newCharacterToken(index: number, code: number): Token {\n  return new Token(index, TokenType.Character, code, String.fromCharCode(code));\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newIdentifierToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Identifier, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newKeywordToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Keyword, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newOperatorToken(index: number, text: string): Token {\n  return new Token(index, TokenType.Operator, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} text\n * @return {?}\n */\nfunction newStringToken(index: number, text: string): Token {\n  return new Token(index, TokenType.String, 0, text);\n}\n/**\n * @param {?} index\n * @param {?} n\n * @return {?}\n */\nfunction newNumberToken(index: number, n: number): Token {\n  return new Token(index, TokenType.Number, n, '');\n}\n/**\n * @param {?} index\n * @param {?} message\n * @return {?}\n */\nfunction newErrorToken(index: number, message: string): Token {\n  return new Token(index, TokenType.Error, 0, message);\n}\n\nexport const /** @type {?} */ EOF: Token = new Token(-1, TokenType.Character, 0, '');\nclass _Scanner {\n  length: number;\n  peek: number = 0;\n  index: number = -1;\n/**\n * @param {?} input\n */\nconstructor(public input: string) {\n    this.length = input.length;\n    this.advance();\n  }\n/**\n * @return {?}\n */\nadvance() {\n    this.peek = ++this.index >= this.length ? chars.$EOF : this.input.charCodeAt(this.index);\n  }\n/**\n * @return {?}\n */\nscanToken(): Token|null {\n    const /** @type {?} */ input = this.input, /** @type {?} */ length = this.length;\n    let /** @type {?} */ peek = this.peek, /** @type {?} */ index = this.index;\n\n    // Skip whitespace.\n    while (peek <= chars.$SPACE) {\n      if (++index >= length) {\n        peek = chars.$EOF;\n        break;\n      } else {\n        peek = input.charCodeAt(index);\n      }\n    }\n\n    this.peek = peek;\n    this.index = index;\n\n    if (index >= length) {\n      return null;\n    }\n\n    // Handle identifiers and numbers.\n    if (isIdentifierStart(peek)) return this.scanIdentifier();\n    if (chars.isDigit(peek)) return this.scanNumber(index);\n\n    const /** @type {?} */ start: number = index;\n    switch (peek) {\n      case chars.$PERIOD:\n        this.advance();\n        return chars.isDigit(this.peek) ? this.scanNumber(start) :\n                                          newCharacterToken(start, chars.$PERIOD);\n      case chars.$LPAREN:\n      case chars.$RPAREN:\n      case chars.$LBRACE:\n      case chars.$RBRACE:\n      case chars.$LBRACKET:\n      case chars.$RBRACKET:\n      case chars.$COMMA:\n      case chars.$COLON:\n      case chars.$SEMICOLON:\n        return this.scanCharacter(start, peek);\n      case chars.$SQ:\n      case chars.$DQ:\n        return this.scanString();\n      case chars.$HASH:\n      case chars.$PLUS:\n      case chars.$MINUS:\n      case chars.$STAR:\n      case chars.$SLASH:\n      case chars.$PERCENT:\n      case chars.$CARET:\n        return this.scanOperator(start, String.fromCharCode(peek));\n      case chars.$QUESTION:\n        return this.scanComplexOperator(start, '?', chars.$PERIOD, '.');\n      case chars.$LT:\n      case chars.$GT:\n        return this.scanComplexOperator(start, String.fromCharCode(peek), chars.$EQ, '=');\n      case chars.$BANG:\n      case chars.$EQ:\n        return this.scanComplexOperator(\n            start, String.fromCharCode(peek), chars.$EQ, '=', chars.$EQ, '=');\n      case chars.$AMPERSAND:\n        return this.scanComplexOperator(start, '&', chars.$AMPERSAND, '&');\n      case chars.$BAR:\n        return this.scanComplexOperator(start, '|', chars.$BAR, '|');\n      case chars.$NBSP:\n        while (chars.isWhitespace(this.peek)) this.advance();\n        return this.scanToken();\n    }\n\n    this.advance();\n    return this.error(`Unexpected character [${String.fromCharCode(peek)}]`, 0);\n  }\n/**\n * @param {?} start\n * @param {?} code\n * @return {?}\n */\nscanCharacter(start: number, code: number): Token {\n    this.advance();\n    return newCharacterToken(start, code);\n  }\n/**\n * @param {?} start\n * @param {?} str\n * @return {?}\n */\nscanOperator(start: number, str: string): Token {\n    this.advance();\n    return newOperatorToken(start, str);\n  }\n/**\n * Tokenize a 2/3 char long operator\n * \n * @param {?} start start index in the expression\n * @param {?} one first symbol (always part of the operator)\n * @param {?} twoCode code point for the second symbol\n * @param {?} two second symbol (part of the operator when the second code point matches)\n * @param {?=} threeCode code point for the third symbol\n * @param {?=} three third symbol (part of the operator when provided and matches source expression)\n * @return {?}\n */\nscanComplexOperator(\n      start: number, one: string, twoCode: number, two: string, threeCode?: number,\n      three?: string): Token {\n    this.advance();\n    let /** @type {?} */ str: string = one;\n    if (this.peek == twoCode) {\n      this.advance();\n      str += two;\n    }\n    if (threeCode != null && this.peek == threeCode) {\n      this.advance();\n      str += three;\n    }\n    return newOperatorToken(start, str);\n  }\n/**\n * @return {?}\n */\nscanIdentifier(): Token {\n    const /** @type {?} */ start: number = this.index;\n    this.advance();\n    while (isIdentifierPart(this.peek)) this.advance();\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    return KEYWORDS.indexOf(str) > -1 ? newKeywordToken(start, str) :\n                                        newIdentifierToken(start, str);\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nscanNumber(start: number): Token {\n    let /** @type {?} */ simple: boolean = (this.index === start);\n    this.advance();  // Skip initial digit.\n    while (true) {\n      if (chars.isDigit(this.peek)) {\n        // Do nothing.\n      } else if (this.peek == chars.$PERIOD) {\n        simple = false;\n      } else if (isExponentStart(this.peek)) {\n        this.advance();\n        if (isExponentSign(this.peek)) this.advance();\n        if (!chars.isDigit(this.peek)) return this.error('Invalid exponent', -1);\n        simple = false;\n      } else {\n        break;\n      }\n      this.advance();\n    }\n    const /** @type {?} */ str: string = this.input.substring(start, this.index);\n    const /** @type {?} */ value: number = simple ? parseIntAutoRadix(str) : parseFloat(str);\n    return newNumberToken(start, value);\n  }\n/**\n * @return {?}\n */\nscanString(): Token {\n    const /** @type {?} */ start: number = this.index;\n    const /** @type {?} */ quote: number = this.peek;\n    this.advance();  // Skip initial quote.\n\n    let /** @type {?} */ buffer: string = '';\n    let /** @type {?} */ marker: number = this.index;\n    const /** @type {?} */ input: string = this.input;\n\n    while (this.peek != quote) {\n      if (this.peek == chars.$BACKSLASH) {\n        buffer += input.substring(marker, this.index);\n        this.advance();\n        let /** @type {?} */ unescapedCode: number;\n        // Workaround for TS2.1-introduced type strictness\n        this.peek = this.peek;\n        if (this.peek == chars.$u) {\n          // 4 character hex code for unicode character.\n          const /** @type {?} */ hex: string = input.substring(this.index + 1, this.index + 5);\n          if (/^[0-9a-f]+$/i.test(hex)) {\n            unescapedCode = parseInt(hex, 16);\n          } else {\n            return this.error(`Invalid unicode escape [\\\\u${hex}]`, 0);\n          }\n          for (let /** @type {?} */ i: number = 0; i < 5; i++) {\n            this.advance();\n          }\n        } else {\n          unescapedCode = unescape(this.peek);\n          this.advance();\n        }\n        buffer += String.fromCharCode(unescapedCode);\n        marker = this.index;\n      } else if (this.peek == chars.$EOF) {\n        return this.error('Unterminated quote', 0);\n      } else {\n        this.advance();\n      }\n    }\n\n    const /** @type {?} */ last: string = input.substring(marker, this.index);\n    this.advance();  // Skip terminating quote.\n\n    return newStringToken(start, buffer + last);\n  }\n/**\n * @param {?} message\n * @param {?} offset\n * @return {?}\n */\nerror(message: string, offset: number): Token {\n    const /** @type {?} */ position: number = this.index + offset;\n    return newErrorToken(\n        position, `Lexer Error: ${message} at column ${position} in expression [${this.input}]`);\n  }\n}\n\nfunction _Scanner_tsickle_Closure_declarations() {\n/** @type {?} */\n_Scanner.prototype.length;\n/** @type {?} */\n_Scanner.prototype.peek;\n/** @type {?} */\n_Scanner.prototype.index;\n/** @type {?} */\n_Scanner.prototype.input;\n}\n\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierStart(code: number): boolean {\n  return (chars.$a <= code && code <= chars.$z) || (chars.$A <= code && code <= chars.$Z) ||\n      (code == chars.$_) || (code == chars.$$);\n}\n/**\n * @param {?} input\n * @return {?}\n */\nexport function isIdentifier(input: string): boolean {\n  if (input.length == 0) return false;\n  const /** @type {?} */ scanner = new _Scanner(input);\n  if (!isIdentifierStart(scanner.peek)) return false;\n  scanner.advance();\n  while (scanner.peek !== chars.$EOF) {\n    if (!isIdentifierPart(scanner.peek)) return false;\n    scanner.advance();\n  }\n  return true;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isIdentifierPart(code: number): boolean {\n  return chars.isAsciiLetter(code) || chars.isDigit(code) || (code == chars.$_) ||\n      (code == chars.$$);\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentStart(code: number): boolean {\n  return code == chars.$e || code == chars.$E;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction isExponentSign(code: number): boolean {\n  return code == chars.$MINUS || code == chars.$PLUS;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nexport function isQuote(code: number): boolean {\n  return code === chars.$SQ || code === chars.$DQ || code === chars.$BT;\n}\n/**\n * @param {?} code\n * @return {?}\n */\nfunction unescape(code: number): number {\n  switch (code) {\n    case chars.$n:\n      return chars.$LF;\n    case chars.$f:\n      return chars.$FF;\n    case chars.$r:\n      return chars.$CR;\n    case chars.$t:\n      return chars.$TAB;\n    case chars.$v:\n      return chars.$VTAB;\n    default:\n      return code;\n  }\n}\n/**\n * @param {?} text\n * @return {?}\n */\nfunction parseIntAutoRadix(text: string): number {\n  const /** @type {?} */ result: number = parseInt(text);\n  if (isNaN(result)) {\n    throw new Error('Invalid integer literal when parsing ' + text);\n  }\n  return result;\n}\n"]}