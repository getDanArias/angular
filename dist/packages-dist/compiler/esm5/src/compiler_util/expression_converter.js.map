{"version":3,"sources":["../../../../../../packages/compiler/src/compiler_util/expression_converter.ts"],"names":[],"mappings":"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","file":"expression_converter.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport * as cdAst from '../expression_parser/ast';\nimport {Identifiers} from '../identifiers';\nimport * as o from '../output/output_ast';\nexport class EventHandlerVars { static event = o.variable('$event'); }\n\nfunction EventHandlerVars_tsickle_Closure_declarations() {\n/** @type {?} */\nEventHandlerVars.event;\n}\n\n/**\n * @record\n */\nexport function LocalResolver() {}\n\n\nfunction LocalResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nLocalResolver.prototype.getLocal;\n}\n\n\nexport interface LocalResolver { getLocal(name: string): o.Expression|null; }\nexport class ConvertActionBindingResult {\n/**\n * @param {?} stmts\n * @param {?} allowDefault\n */\nconstructor(public stmts: o.Statement[],\npublic allowDefault: o.ReadVarExpr) {}\n}\n\nfunction ConvertActionBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nConvertActionBindingResult.prototype.stmts;\n/** @type {?} */\nConvertActionBindingResult.prototype.allowDefault;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression is\n * used in an action binding (e.g. an event handler).\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} action\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertActionBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression, action: cdAst.AST,\n    bindingId: string): ConvertActionBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const /** @type {?} */ actionWithoutBuiltins = convertPropertyBindingBuiltins(\n      {\n        createLiteralArrayConverter: (argCount: number) => {\n          // Note: no caching for literal arrays in actions.\n          return (args: o.Expression[]) => o.literalArr(args);\n        },\n        createLiteralMapConverter: (keys: {key: string, quoted: boolean}[]) => {\n          // Note: no caching for literal maps in actions.\n          return (values: o.Expression[]) => {\n            const /** @type {?} */ entries = keys.map((k, i) => ({\n                                       key: k.key,\n                                       value: values[i],\n                                       quoted: k.quoted,\n                                     }));\n            return o.literalMap(entries);\n          };\n        },\n        createPipeConverter: (name: string) => {\n          throw new Error(`Illegal State: Actions are not allowed to contain pipes. Pipe: ${name}`);\n        }\n      },\n      action);\n\n  const /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n  const /** @type {?} */ actionStmts: o.Statement[] = [];\n  flattenStatements(actionWithoutBuiltins.visit(visitor, _Mode.Statement), actionStmts);\n  prependTemporaryDecls(visitor.temporaryCount, bindingId, actionStmts);\n  const /** @type {?} */ lastIndex = actionStmts.length - 1;\n  let /** @type {?} */ preventDefaultVar: o.ReadVarExpr = /** @type {?} */(( null));\n  if (lastIndex >= 0) {\n    const /** @type {?} */ lastStatement = actionStmts[lastIndex];\n    const /** @type {?} */ returnExpr = convertStmtIntoExpression(lastStatement);\n    if (returnExpr) {\n      // Note: We need to cast the result of the method call to dynamic,\n      // as it might be a void method!\n      preventDefaultVar = createPreventDefaultVar(bindingId);\n      actionStmts[lastIndex] =\n          preventDefaultVar.set(returnExpr.cast(o.DYNAMIC_TYPE).notIdentical(o.literal(false)))\n              .toDeclStmt(null, [o.StmtModifier.Final]);\n    }\n  }\n  return new ConvertActionBindingResult(actionStmts, preventDefaultVar);\n}\n/**\n * @record\n */\nexport function BuiltinConverter() {}\n\n\nfunction BuiltinConverter_tsickle_Closure_declarations() {\n/* TODO: handle strange member:\n(args: o.Expression[]): o.Expression;\n*/\n}\n\n\nexport interface BuiltinConverter { (args: o.Expression[]): o.Expression; }\n/**\n * @record\n */\nexport function BuiltinConverterFactory() {}\n\n\nfunction BuiltinConverterFactory_tsickle_Closure_declarations() {\n/** @type {?} */\nBuiltinConverterFactory.prototype.createLiteralArrayConverter;\n/** @type {?} */\nBuiltinConverterFactory.prototype.createLiteralMapConverter;\n/** @type {?} */\nBuiltinConverterFactory.prototype.createPipeConverter;\n}\n\n\nexport interface BuiltinConverterFactory {\n  createLiteralArrayConverter(argCount: number): BuiltinConverter;\n  createLiteralMapConverter(keys: {key: string, quoted: boolean}[]): BuiltinConverter;\n  createPipeConverter(name: string, argCount: number): BuiltinConverter;\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nexport function convertPropertyBindingBuiltins(\n    converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  return convertBuiltins(converterFactory, ast);\n}\nexport class ConvertPropertyBindingResult {\n/**\n * @param {?} stmts\n * @param {?} currValExpr\n */\nconstructor(public stmts: o.Statement[],\npublic currValExpr: o.Expression) {}\n}\n\nfunction ConvertPropertyBindingResult_tsickle_Closure_declarations() {\n/** @type {?} */\nConvertPropertyBindingResult.prototype.stmts;\n/** @type {?} */\nConvertPropertyBindingResult.prototype.currValExpr;\n}\n\n/**\n * Converts the given expression AST into an executable output AST, assuming the expression\n * is used in property binding. The expression has to be preprocessed via\n * `convertPropertyBindingBuiltins`.\n * @param {?} localResolver\n * @param {?} implicitReceiver\n * @param {?} expressionWithoutBuiltins\n * @param {?} bindingId\n * @return {?}\n */\nexport function convertPropertyBinding(\n    localResolver: LocalResolver | null, implicitReceiver: o.Expression,\n    expressionWithoutBuiltins: cdAst.AST, bindingId: string): ConvertPropertyBindingResult {\n  if (!localResolver) {\n    localResolver = new DefaultLocalResolver();\n  }\n  const /** @type {?} */ currValExpr = createCurrValueExpr(bindingId);\n  const /** @type {?} */ stmts: o.Statement[] = [];\n  const /** @type {?} */ visitor = new _AstToIrVisitor(localResolver, implicitReceiver, bindingId);\n  const /** @type {?} */ outputExpr: o.Expression = expressionWithoutBuiltins.visit(visitor, _Mode.Expression);\n\n  if (visitor.temporaryCount) {\n    for (let /** @type {?} */ i = 0; i < visitor.temporaryCount; i++) {\n      stmts.push(temporaryDeclaration(bindingId, i));\n    }\n  }\n\n  stmts.push(currValExpr.set(outputExpr).toDeclStmt(null, [o.StmtModifier.Final]));\n  return new ConvertPropertyBindingResult(stmts, currValExpr);\n}\n/**\n * @param {?} converterFactory\n * @param {?} ast\n * @return {?}\n */\nfunction convertBuiltins(converterFactory: BuiltinConverterFactory, ast: cdAst.AST): cdAst.AST {\n  const /** @type {?} */ visitor = new _BuiltinAstConverter(converterFactory);\n  return ast.visit(visitor);\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nfunction temporaryName(bindingId: string, temporaryNumber: number): string {\n  return `tmp_${bindingId}_${temporaryNumber}`;\n}\n/**\n * @param {?} bindingId\n * @param {?} temporaryNumber\n * @return {?}\n */\nexport function temporaryDeclaration(bindingId: string, temporaryNumber: number): o.Statement {\n  return new o.DeclareVarStmt(temporaryName(bindingId, temporaryNumber), o.NULL_EXPR);\n}\n/**\n * @param {?} temporaryCount\n * @param {?} bindingId\n * @param {?} statements\n * @return {?}\n */\nfunction prependTemporaryDecls(\n    temporaryCount: number, bindingId: string, statements: o.Statement[]) {\n  for (let /** @type {?} */ i = temporaryCount - 1; i >= 0; i--) {\n    statements.unshift(temporaryDeclaration(bindingId, i));\n  }\n}\ntype _Mode = number;\nlet _Mode: any = {};\n_Mode.Statement = 0;\n_Mode.Expression = 1;\n_Mode[_Mode.Statement] = \"Statement\";\n_Mode[_Mode.Expression] = \"Expression\";\n\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureStatementMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Statement) {\n    throw new Error(`Expected a statement, but saw ${ast}`);\n  }\n}\n/**\n * @param {?} mode\n * @param {?} ast\n * @return {?}\n */\nfunction ensureExpressionMode(mode: _Mode, ast: cdAst.AST) {\n  if (mode !== _Mode.Expression) {\n    throw new Error(`Expected an expression, but saw ${ast}`);\n  }\n}\n/**\n * @param {?} mode\n * @param {?} expr\n * @return {?}\n */\nfunction convertToStatementIfNeeded(mode: _Mode, expr: o.Expression): o.Expression|o.Statement {\n  if (mode === _Mode.Statement) {\n    return expr.toStmt();\n  } else {\n    return expr;\n  }\n}\nclass _BuiltinAstConverter extends cdAst.AstTransformer {\n/**\n * @param {?} _converterFactory\n */\nconstructor(private _converterFactory: BuiltinConverterFactory) { super(); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe, context: any): any {\n    const /** @type {?} */ args = [ast.exp, ...ast.args].map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createPipeConverter(ast.name, args.length));\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray, context: any): any {\n    const /** @type {?} */ args = ast.expressions.map(ast => ast.visit(this, context));\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralArrayConverter(ast.expressions.length));\n  }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap, context: any): any {\n    const /** @type {?} */ args = ast.values.map(ast => ast.visit(this, context));\n\n    return new BuiltinFunctionCall(\n        ast.span, args, this._converterFactory.createLiteralMapConverter(ast.keys));\n  }\n}\n\nfunction _BuiltinAstConverter_tsickle_Closure_declarations() {\n/** @type {?} */\n_BuiltinAstConverter.prototype._converterFactory;\n}\n\nclass _AstToIrVisitor implements cdAst.AstVisitor {\nprivate _nodeMap = new Map<cdAst.AST, cdAst.AST>();\nprivate _resultMap = new Map<cdAst.AST, o.Expression>();\nprivate _currentTemporary: number = 0;\npublic temporaryCount: number = 0;\n/**\n * @param {?} _localResolver\n * @param {?} _implicitReceiver\n * @param {?} bindingId\n */\nconstructor(\nprivate _localResolver: LocalResolver,\nprivate _implicitReceiver: o.Expression,\nprivate bindingId: string) {}\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary, mode: _Mode): any {\n    let /** @type {?} */ op: o.BinaryOperator;\n    switch (ast.operation) {\n      case '+':\n        op = o.BinaryOperator.Plus;\n        break;\n      case '-':\n        op = o.BinaryOperator.Minus;\n        break;\n      case '*':\n        op = o.BinaryOperator.Multiply;\n        break;\n      case '/':\n        op = o.BinaryOperator.Divide;\n        break;\n      case '%':\n        op = o.BinaryOperator.Modulo;\n        break;\n      case '&&':\n        op = o.BinaryOperator.And;\n        break;\n      case '||':\n        op = o.BinaryOperator.Or;\n        break;\n      case '==':\n        op = o.BinaryOperator.Equals;\n        break;\n      case '!=':\n        op = o.BinaryOperator.NotEquals;\n        break;\n      case '===':\n        op = o.BinaryOperator.Identical;\n        break;\n      case '!==':\n        op = o.BinaryOperator.NotIdentical;\n        break;\n      case '<':\n        op = o.BinaryOperator.Lower;\n        break;\n      case '>':\n        op = o.BinaryOperator.Bigger;\n        break;\n      case '<=':\n        op = o.BinaryOperator.LowerEquals;\n        break;\n      case '>=':\n        op = o.BinaryOperator.BiggerEquals;\n        break;\n      default:\n        throw new Error(`Unsupported operation ${ast.operation}`);\n    }\n\n    return convertToStatementIfNeeded(\n        mode,\n        new o.BinaryOperatorExpr(\n            op, this._visit(ast.left, _Mode.Expression), this._visit(ast.right, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain, mode: _Mode): any {\n    ensureStatementMode(mode, ast);\n    return this.visitAll(ast.expressions, mode);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional, mode: _Mode): any {\n    const /** @type {?} */ value: o.Expression = this._visit(ast.condition, _Mode.Expression);\n    return convertToStatementIfNeeded(\n        mode, value.conditional(\n                  this._visit(ast.trueExp, _Mode.Expression),\n                  this._visit(ast.falseExp, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe, mode: _Mode): any {\n    throw new Error(\n        `Illegal state: Pipes should have been converted into functions. Pipe: ${ast.name}`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall, mode: _Mode): any {\n    const /** @type {?} */ convertedArgs = this.visitAll(ast.args, _Mode.Expression);\n    let /** @type {?} */ fnResult: o.Expression;\n    if (ast instanceof BuiltinFunctionCall) {\n      fnResult = ast.converter(convertedArgs);\n    } else {\n      fnResult = this._visit( /** @type {?} */((ast.target)), _Mode.Expression).callFn(convertedArgs);\n    }\n    return convertToStatementIfNeeded(mode, fnResult);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    return this._implicitReceiver;\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation, mode: _Mode): any {\n    ensureExpressionMode(mode, ast);\n    const /** @type {?} */ args = [o.literal(ast.expressions.length)];\n    for (let /** @type {?} */ i = 0; i < ast.strings.length - 1; i++) {\n      args.push(o.literal(ast.strings[i]));\n      args.push(this._visit(ast.expressions[i], _Mode.Expression));\n    }\n    args.push(o.literal(ast.strings[ast.strings.length - 1]));\n\n    return ast.expressions.length <= 9 ?\n        o.importExpr(Identifiers.inlineInterpolate).callFn(args) :\n        o.importExpr(Identifiers.interpolate).callFn([args[0], o.literalArr(args.slice(1))]);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      return convertToStatementIfNeeded(\n          mode, this._visit(ast.obj, _Mode.Expression).key(this._visit(ast.key, _Mode.Expression)));\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite, mode: _Mode): any {\n    const /** @type {?} */ obj: o.Expression = this._visit(ast.obj, _Mode.Expression);\n    const /** @type {?} */ key: o.Expression = this._visit(ast.key, _Mode.Expression);\n    const /** @type {?} */ value: o.Expression = this._visit(ast.value, _Mode.Expression);\n    return convertToStatementIfNeeded(mode, obj.key(key).set(value));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray, mode: _Mode): any {\n    throw new Error(`Illegal State: literal arrays should have been converted into functions`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap, mode: _Mode): any {\n    throw new Error(`Illegal State: literal maps should have been converted into functions`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.literal(ast.value));\n  }\n/**\n * @param {?} name\n * @return {?}\n */\n\nprivate _getLocal(name: string): o.Expression|null { return this._localResolver.getLocal(name); }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      const /** @type {?} */ args = this.visitAll(ast.args, _Mode.Expression);\n      let /** @type {?} */ result: any = null;\n      const /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        const /** @type {?} */ varExpr = this._getLocal(ast.name);\n        if (varExpr) {\n          result = varExpr.callFn(args);\n        }\n      }\n      if (result == null) {\n        result = receiver.callMethod(ast.name, args);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot, mode: _Mode): any {\n    return convertToStatementIfNeeded(mode, o.not(this._visit(ast.expression, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitNonNullAssert(ast: cdAst.NonNullAssert, mode: _Mode): any {\n    return convertToStatementIfNeeded(\n        mode, o.assertNotNull(this._visit(ast.expression, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead, mode: _Mode): any {\n    const /** @type {?} */ leftMostSafe = this.leftMostSafeNode(ast);\n    if (leftMostSafe) {\n      return this.convertSafeAccess(ast, leftMostSafe, mode);\n    } else {\n      let /** @type {?} */ result: any = null;\n      const /** @type {?} */ receiver = this._visit(ast.receiver, _Mode.Expression);\n      if (receiver === this._implicitReceiver) {\n        result = this._getLocal(ast.name);\n      }\n      if (result == null) {\n        result = receiver.prop(ast.name);\n      }\n      return convertToStatementIfNeeded(mode, result);\n    }\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite, mode: _Mode): any {\n    const /** @type {?} */ receiver: o.Expression = this._visit(ast.receiver, _Mode.Expression);\n    if (receiver === this._implicitReceiver) {\n      const /** @type {?} */ varExpr = this._getLocal(ast.name);\n      if (varExpr) {\n        throw new Error('Cannot assign to a reference or variable!');\n      }\n    }\n    return convertToStatementIfNeeded(\n        mode, receiver.prop(ast.name).set(this._visit(ast.value, _Mode.Expression)));\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall, mode: _Mode): any {\n    return this.convertSafeAccess(ast, this.leftMostSafeNode(ast), mode);\n  }\n/**\n * @param {?} asts\n * @param {?} mode\n * @return {?}\n */\nvisitAll(asts: cdAst.AST[], mode: _Mode): any { return asts.map(ast => this._visit(ast, mode)); }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote, mode: _Mode): any {\n    throw new Error(`Quotes are not supported for evaluation!\n        Statement: ${ast.uninterpretedExpression} located at ${ast.location}`);\n  }\n/**\n * @param {?} ast\n * @param {?} mode\n * @return {?}\n */\n\nprivate _visit(ast: cdAst.AST, mode: _Mode): any {\n    const /** @type {?} */ result = this._resultMap.get(ast);\n    if (result) return result;\n    return (this._nodeMap.get(ast) || ast).visit(this, mode);\n  }\n/**\n * @param {?} ast\n * @param {?} leftMostSafe\n * @param {?} mode\n * @return {?}\n */\n\nprivate convertSafeAccess(\n      ast: cdAst.AST, leftMostSafe: cdAst.SafeMethodCall|cdAst.SafePropertyRead, mode: _Mode): any {\n    // If the expression contains a safe access node on the left it needs to be converted to\n    // an expression that guards the access to the member by checking the receiver for blank. As\n    // execution proceeds from left to right, the left most part of the expression must be guarded\n    // first but, because member access is left associative, the right side of the expression is at\n    // the top of the AST. The desired result requires lifting a copy of the the left part of the\n    // expression up to test it for blank before generating the unguarded version.\n\n    // Consider, for example the following expression: a?.b.c?.d.e\n\n    // This results in the ast:\n    //         .\n    //        / \\\n    //       ?.   e\n    //      /  \\\n    //     .    d\n    //    / \\\n    //   ?.  c\n    //  /  \\\n    // a    b\n\n    // The following tree should be generated:\n    //\n    //        /---- ? ----\\\n    //       /      |      \\\n    //     a   /--- ? ---\\  null\n    //        /     |     \\\n    //       .      .     null\n    //      / \\    / \\\n    //     .  c   .   e\n    //    / \\    / \\\n    //   a   b  ,   d\n    //         / \\\n    //        .   c\n    //       / \\\n    //      a   b\n    //\n    // Notice that the first guard condition is the left hand of the left most safe access node\n    // which comes in as leftMostSafe to this routine.\n\n    let /** @type {?} */ guardedExpression = this._visit(leftMostSafe.receiver, _Mode.Expression);\n    let /** @type {?} */ temporary: o.ReadVarExpr = /** @type {?} */(( undefined));\n    if (this.needsTemporary(leftMostSafe.receiver)) {\n      // If the expression has method calls or pipes then we need to save the result into a\n      // temporary variable to avoid calling stateful or impure code more than once.\n      temporary = this.allocateTemporary();\n\n      // Preserve the result in the temporary variable\n      guardedExpression = temporary.set(guardedExpression);\n\n      // Ensure all further references to the guarded expression refer to the temporary instead.\n      this._resultMap.set(leftMostSafe.receiver, temporary);\n    }\n    const /** @type {?} */ condition = guardedExpression.isBlank();\n\n    // Convert the ast to an unguarded access to the receiver's member. The map will substitute\n    // leftMostNode with its unguarded version in the call to `this.visit()`.\n    if (leftMostSafe instanceof cdAst.SafeMethodCall) {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.MethodCall(\n              leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name, leftMostSafe.args));\n    } else {\n      this._nodeMap.set(\n          leftMostSafe,\n          new cdAst.PropertyRead(leftMostSafe.span, leftMostSafe.receiver, leftMostSafe.name));\n    }\n\n    // Recursively convert the node now without the guarded member access.\n    const /** @type {?} */ access = this._visit(ast, _Mode.Expression);\n\n    // Remove the mapping. This is not strictly required as the converter only traverses each node\n    // once but is safer if the conversion is changed to traverse the nodes more than once.\n    this._nodeMap.delete(leftMostSafe);\n\n    // If we allocated a temporary, release it.\n    if (temporary) {\n      this.releaseTemporary(temporary);\n    }\n\n    // Produce the conditional\n    return convertToStatementIfNeeded(mode, condition.conditional(o.literal(null), access));\n  }\n/**\n * @param {?} ast\n * @return {?}\n */\n\nprivate leftMostSafeNode(ast: cdAst.AST): cdAst.SafePropertyRead|cdAst.SafeMethodCall {\n    const /** @type {?} */ visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): any => {\n      return (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    return ast.visit({\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead) { return visit(this, ast.obj); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall) { return visit(this, ast.receiver); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitNonNullAssert(ast: cdAst.NonNullAssert) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead) { return visit(this, ast.receiver); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote) { return null; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall) { return visit(this, ast.receiver) || ast; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead) {\n        return visit(this, ast.receiver) || ast;\n      }\n    });\n  }\n/**\n * @param {?} ast\n * @return {?}\n */\n\nprivate needsTemporary(ast: cdAst.AST): boolean {\n    const /** @type {?} */ visit = (visitor: cdAst.AstVisitor, ast: cdAst.AST): boolean => {\n      return ast && (this._nodeMap.get(ast) || ast).visit(visitor);\n    };\n    const /** @type {?} */ visitSome = (visitor: cdAst.AstVisitor, ast: cdAst.AST[]): boolean => {\n      return ast.some(ast => visit(visitor, ast));\n    };\n    return ast.visit({\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitBinary(ast: cdAst.Binary):\n          boolean{return visit(this, ast.left) || visit(this, ast.right);},\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitChain(ast: cdAst.Chain) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitConditional(ast: cdAst.Conditional):\n          boolean{return visit(this, ast.condition) || visit(this, ast.trueExp) ||\n                      visit(this, ast.falseExp);},\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitFunctionCall(ast: cdAst.FunctionCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitImplicitReceiver(ast: cdAst.ImplicitReceiver) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitInterpolation(ast: cdAst.Interpolation) { return visitSome(this, ast.expressions); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedRead(ast: cdAst.KeyedRead) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitKeyedWrite(ast: cdAst.KeyedWrite) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralArray(ast: cdAst.LiteralArray) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralMap(ast: cdAst.LiteralMap) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitLiteralPrimitive(ast: cdAst.LiteralPrimitive) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitMethodCall(ast: cdAst.MethodCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPipe(ast: cdAst.BindingPipe) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPrefixNot(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitNonNullAssert(ast: cdAst.PrefixNot) { return visit(this, ast.expression); },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyRead(ast: cdAst.PropertyRead) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitPropertyWrite(ast: cdAst.PropertyWrite) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitQuote(ast: cdAst.Quote) { return false; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafeMethodCall(ast: cdAst.SafeMethodCall) { return true; },\n/**\n * @param {?} ast\n * @return {?}\n */\nvisitSafePropertyRead(ast: cdAst.SafePropertyRead) { return false; }\n    });\n  }\n/**\n * @return {?}\n */\n\nprivate allocateTemporary(): o.ReadVarExpr {\n    const /** @type {?} */ tempNumber = this._currentTemporary++;\n    this.temporaryCount = Math.max(this._currentTemporary, this.temporaryCount);\n    return new o.ReadVarExpr(temporaryName(this.bindingId, tempNumber));\n  }\n/**\n * @param {?} temporary\n * @return {?}\n */\n\nprivate releaseTemporary(temporary: o.ReadVarExpr) {\n    this._currentTemporary--;\n    if (temporary.name != temporaryName(this.bindingId, this._currentTemporary)) {\n      throw new Error(`Temporary ${temporary.name} released out of order`);\n    }\n  }\n}\n\nfunction _AstToIrVisitor_tsickle_Closure_declarations() {\n/** @type {?} */\n_AstToIrVisitor.prototype._nodeMap;\n/** @type {?} */\n_AstToIrVisitor.prototype._resultMap;\n/** @type {?} */\n_AstToIrVisitor.prototype._currentTemporary;\n/** @type {?} */\n_AstToIrVisitor.prototype.temporaryCount;\n/** @type {?} */\n_AstToIrVisitor.prototype._localResolver;\n/** @type {?} */\n_AstToIrVisitor.prototype._implicitReceiver;\n/** @type {?} */\n_AstToIrVisitor.prototype.bindingId;\n}\n\n/**\n * @param {?} arg\n * @param {?} output\n * @return {?}\n */\nfunction flattenStatements(arg: any, output: o.Statement[]) {\n  if (Array.isArray(arg)) {\n    ( /** @type {?} */((<any[]>arg))).forEach((entry) => flattenStatements(entry, output));\n  } else {\n    output.push(arg);\n  }\n}\nclass DefaultLocalResolver implements LocalResolver {\n/**\n * @param {?} name\n * @return {?}\n */\ngetLocal(name: string): o.Expression|null {\n    if (name === EventHandlerVars.event.name) {\n      return EventHandlerVars.event;\n    }\n    return null;\n  }\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createCurrValueExpr(bindingId: string): o.ReadVarExpr {\n  return o.variable(`currVal_${bindingId}`);  // fix syntax highlighting: `\n}\n/**\n * @param {?} bindingId\n * @return {?}\n */\nfunction createPreventDefaultVar(bindingId: string): o.ReadVarExpr {\n  return o.variable(`pd_${bindingId}`);\n}\n/**\n * @param {?} stmt\n * @return {?}\n */\nfunction convertStmtIntoExpression(stmt: o.Statement): o.Expression|null {\n  if (stmt instanceof o.ExpressionStatement) {\n    return stmt.expr;\n  } else if (stmt instanceof o.ReturnStatement) {\n    return stmt.value;\n  }\n  return null;\n}\nclass BuiltinFunctionCall extends cdAst.FunctionCall {\n/**\n * @param {?} span\n * @param {?} args\n * @param {?} converter\n */\nconstructor(span: cdAst.ParseSpan,\npublic args: cdAst.AST[],\npublic converter: BuiltinConverter) {\n    super(span, null, args);\n  }\n}\n\nfunction BuiltinFunctionCall_tsickle_Closure_declarations() {\n/** @type {?} */\nBuiltinFunctionCall.prototype.args;\n/** @type {?} */\nBuiltinFunctionCall.prototype.converter;\n}\n\n"]}