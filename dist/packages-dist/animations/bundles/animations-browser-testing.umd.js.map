{"version":3,"file":"animations-browser-testing.umd.js","sources":["../../../../node_modules/tslib/tslib.es6.js","../../../../packages/animations/browser/src/render/shared.ts","../../../../packages/animations/browser/src/util.ts","../../../../packages/animations/browser/testing/src/mock_animation_driver.ts","../../../../packages/animations/browser/testing/src/testing.ts","../../../../packages/animations/browser/testing/public_api.ts","../../../../packages/animations/browser/testing/index.ts"],"sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = Object.setPrototypeOf ||\r\n    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = Object.assign || function __assign(t) {\r\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n        s = arguments[i];\r\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n    }\r\n    return t;\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\r\n            t[p[i]] = s[p[i]];\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = y[op[0] & 2 ? \"return\" : op[0] ? \"throw\" : \"next\"]) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [0, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; }; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator];\r\n    return m ? m.call(o) : typeof __values === \"function\" ? __values(o) : o[Symbol.iterator]();\r\n}","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationEvent, AnimationPlayer, NoopAnimationPlayer, ɵAnimationGroupPlayer, ɵPRE_STYLE as PRE_STYLE, ɵStyleData} from '@angular/animations';\n\nimport {AnimationStyleNormalizer} from '../../src/dsl/style_normalization/animation_style_normalizer';\nimport {AnimationDriver} from '../../src/render/animation_driver';\n/**\n * @param {?} players\n * @return {?}\n */\nexport function optimizeGroupPlayer(players: AnimationPlayer[]): AnimationPlayer {\n  switch (players.length) {\n    case 0:\n      return new NoopAnimationPlayer();\n    case 1:\n      return players[0];\n    default:\n      return new ɵAnimationGroupPlayer(players);\n  }\n}\n/**\n * @param {?} driver\n * @param {?} normalizer\n * @param {?} element\n * @param {?} keyframes\n * @param {?=} preStyles\n * @param {?=} postStyles\n * @return {?}\n */\nexport function normalizeKeyframes(\n    driver: AnimationDriver, normalizer: AnimationStyleNormalizer, element: any,\n    keyframes: ɵStyleData[], preStyles: ɵStyleData = {},\n    postStyles: ɵStyleData = {}): ɵStyleData[] {\n  const /** @type {?} */ errors: string[] = [];\n  const /** @type {?} */ normalizedKeyframes: ɵStyleData[] = [];\n  let /** @type {?} */ previousOffset = -1;\n  let /** @type {?} */ previousKeyframe: ɵStyleData|null = null;\n  keyframes.forEach(kf => {\n    const /** @type {?} */ offset = /** @type {?} */(( kf['offset'] as number));\n    const /** @type {?} */ isSameOffset = offset == previousOffset;\n    const /** @type {?} */ normalizedKeyframe: ɵStyleData = (isSameOffset && previousKeyframe) || {};\n    Object.keys(kf).forEach(prop => {\n      let /** @type {?} */ normalizedProp = prop;\n      let /** @type {?} */ normalizedValue = kf[prop];\n      if (prop !== 'offset') {\n        normalizedProp = normalizer.normalizePropertyName(normalizedProp, errors);\n        switch (normalizedValue) {\n          case PRE_STYLE:\n            normalizedValue = preStyles[prop];\n            break;\n\n          case AUTO_STYLE:\n            normalizedValue = postStyles[prop];\n            break;\n\n          default:\n            normalizedValue =\n                normalizer.normalizeStyleValue(prop, normalizedProp, normalizedValue, errors);\n            break;\n        }\n      }\n      normalizedKeyframe[normalizedProp] = normalizedValue;\n    });\n    if (!isSameOffset) {\n      normalizedKeyframes.push(normalizedKeyframe);\n    }\n    previousKeyframe = normalizedKeyframe;\n    previousOffset = offset;\n  });\n  if (errors.length) {\n    const /** @type {?} */ LINE_START = '\\n - ';\n    throw new Error(\n        `Unable to animate due to the following errors:${LINE_START}${errors.join(LINE_START)}`);\n  }\n\n  return normalizedKeyframes;\n}\n/**\n * @param {?} player\n * @param {?} eventName\n * @param {?} event\n * @param {?} callback\n * @return {?}\n */\nexport function listenOnPlayer(\n    player: AnimationPlayer, eventName: string, event: AnimationEvent | undefined,\n    callback: (event: any) => any) {\n  switch (eventName) {\n    case 'start':\n      player.onStart(() => callback(event && copyAnimationEvent(event, 'start', player.totalTime)));\n      break;\n    case 'done':\n      player.onDone(() => callback(event && copyAnimationEvent(event, 'done', player.totalTime)));\n      break;\n    case 'destroy':\n      player.onDestroy(\n          () => callback(event && copyAnimationEvent(event, 'destroy', player.totalTime)));\n      break;\n  }\n}\n/**\n * @param {?} e\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @return {?}\n */\nexport function copyAnimationEvent(\n    e: AnimationEvent, phaseName?: string, totalTime?: number): AnimationEvent {\n  const /** @type {?} */ event = makeAnimationEvent(\n      e.element, e.triggerName, e.fromState, e.toState, phaseName || e.phaseName,\n      totalTime == undefined ? e.totalTime : totalTime);\n  const /** @type {?} */ data = ( /** @type {?} */((e as any)))['_data'];\n  if (data != null) {\n    ( /** @type {?} */((event as any)))['_data'] = data;\n  }\n  return event;\n}\n/**\n * @param {?} element\n * @param {?} triggerName\n * @param {?} fromState\n * @param {?} toState\n * @param {?=} phaseName\n * @param {?=} totalTime\n * @return {?}\n */\nexport function makeAnimationEvent(\n    element: any, triggerName: string, fromState: string, toState: string, phaseName: string = '',\n    totalTime: number = 0): AnimationEvent {\n  return {element, triggerName, fromState, toState, phaseName, totalTime};\n}\n/**\n * @param {?} map\n * @param {?} key\n * @param {?} defaultValue\n * @return {?}\n */\nexport function getOrSetAsInMap(\n    map: Map<any, any>| {[key: string]: any}, key: any, defaultValue: any) {\n  let /** @type {?} */ value: any;\n  if (map instanceof Map) {\n    value = map.get(key);\n    if (!value) {\n      map.set(key, value = defaultValue);\n    }\n  } else {\n    value = map[key];\n    if (!value) {\n      value = map[key] = defaultValue;\n    }\n  }\n  return value;\n}\n/**\n * @param {?} command\n * @return {?}\n */\nexport function parseTimelineCommand(command: string): [string, string] {\n  const /** @type {?} */ separatorPos = command.indexOf(':');\n  const /** @type {?} */ id = command.substring(1, separatorPos);\n  const /** @type {?} */ action = command.substr(separatorPos + 1);\n  return [id, action];\n}\n\nlet /** @type {?} */ _contains: (elm1: any, elm2: any) => boolean = (elm1: any, elm2: any) => false;\nlet /** @type {?} */ _matches: (element: any, selector: string) => boolean = (element: any, selector: string) =>\n    false;\nlet /** @type {?} */ _query: (element: any, selector: string, multi: boolean) => any[] =\n    (element: any, selector: string, multi: boolean) => {\n      return [];\n    };\n\nif (typeof Element != 'undefined') {\n  // this is well supported in all browsers\n  _contains = (elm1: any, elm2: any) => { return /** @type {?} */(( elm1.contains(elm2) as boolean)); };\n\n  if (Element.prototype.matches) {\n    _matches = (element: any, selector: string) => element.matches(selector);\n  } else {\n    const /** @type {?} */ proto = /** @type {?} */(( Element.prototype as any));\n    const /** @type {?} */ fn = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector ||\n        proto.oMatchesSelector || proto.webkitMatchesSelector;\n    if (fn) {\n      _matches = (element: any, selector: string) => fn.apply(element, [selector]);\n    }\n  }\n\n  _query = (element: any, selector: string, multi: boolean): any[] => {\n    let /** @type {?} */ results: any[] = [];\n    if (multi) {\n      results.push(...element.querySelectorAll(selector));\n    } else {\n      const /** @type {?} */ elm = element.querySelector(selector);\n      if (elm) {\n        results.push(elm);\n      }\n    }\n    return results;\n  };\n}\n\nexport const /** @type {?} */ matchesElement = _matches;\nexport const /** @type {?} */ containsElement = _contains;\nexport const /** @type {?} */ invokeQuery = _query;\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AnimateTimings, AnimationMetadata, AnimationOptions, sequence, ɵStyleData} from '@angular/animations';\n\nexport const /** @type {?} */ ONE_SECOND = 1000;\n\nexport const /** @type {?} */ SUBSTITUTION_EXPR_START = '{{';\nexport const /** @type {?} */ SUBSTITUTION_EXPR_END = '}}';\nexport const /** @type {?} */ ENTER_CLASSNAME = 'ng-enter';\nexport const /** @type {?} */ LEAVE_CLASSNAME = 'ng-leave';\nexport const /** @type {?} */ ENTER_SELECTOR = '.ng-enter';\nexport const /** @type {?} */ LEAVE_SELECTOR = '.ng-leave';\nexport const /** @type {?} */ NG_TRIGGER_CLASSNAME = 'ng-trigger';\nexport const /** @type {?} */ NG_TRIGGER_SELECTOR = '.ng-trigger';\nexport const /** @type {?} */ NG_ANIMATING_CLASSNAME = 'ng-animating';\nexport const /** @type {?} */ NG_ANIMATING_SELECTOR = '.ng-animating';\n/**\n * @param {?} value\n * @return {?}\n */\nexport function resolveTimingValue(value: string | number) {\n  if (typeof value == 'number') return value;\n\n  const /** @type {?} */ matches = ( /** @type {?} */((value as string))).match(/^(-?[\\.\\d]+)(m?s)/);\n  if (!matches || matches.length < 2) return 0;\n\n  return _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n}\n/**\n * @param {?} value\n * @param {?} unit\n * @return {?}\n */\nfunction _convertTimeValueToMS(value: number, unit: string): number {\n  switch (unit) {\n    case 's':\n      return value * ONE_SECOND;\n    default:  // ms or something else\n      return value;\n  }\n}\n/**\n * @param {?} timings\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nexport function resolveTiming(\n    timings: string | number | AnimateTimings, errors: any[], allowNegativeValues?: boolean) {\n  return timings.hasOwnProperty('duration') ? /** @type {?} */((\n      <AnimateTimings>timings)) :\n      parseTimeExpression( /** @type {?} */((<string|number>timings)), errors, allowNegativeValues);\n}\n/**\n * @param {?} exp\n * @param {?} errors\n * @param {?=} allowNegativeValues\n * @return {?}\n */\nfunction parseTimeExpression(\n    exp: string | number, errors: string[], allowNegativeValues?: boolean): AnimateTimings {\n  const /** @type {?} */ regex = /^(-?[\\.\\d]+)(m?s)(?:\\s+(-?[\\.\\d]+)(m?s))?(?:\\s+([-a-z]+(?:\\(.+?\\))?))?$/i;\n  let /** @type {?} */ duration: number;\n  let /** @type {?} */ delay: number = 0;\n  let /** @type {?} */ easing: string = '';\n  if (typeof exp === 'string') {\n    const /** @type {?} */ matches = exp.match(regex);\n    if (matches === null) {\n      errors.push(`The provided timing value \"${exp}\" is invalid.`);\n      return {duration: 0, delay: 0, easing: ''};\n    }\n\n    duration = _convertTimeValueToMS(parseFloat(matches[1]), matches[2]);\n\n    const /** @type {?} */ delayMatch = matches[3];\n    if (delayMatch != null) {\n      delay = _convertTimeValueToMS(Math.floor(parseFloat(delayMatch)), matches[4]);\n    }\n\n    const /** @type {?} */ easingVal = matches[5];\n    if (easingVal) {\n      easing = easingVal;\n    }\n  } else {\n    duration = /** @type {?} */(( <number>exp));\n  }\n\n  if (!allowNegativeValues) {\n    let /** @type {?} */ containsErrors = false;\n    let /** @type {?} */ startIndex = errors.length;\n    if (duration < 0) {\n      errors.push(`Duration values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (delay < 0) {\n      errors.push(`Delay values below 0 are not allowed for this animation step.`);\n      containsErrors = true;\n    }\n    if (containsErrors) {\n      errors.splice(startIndex, 0, `The provided timing value \"${exp}\" is invalid.`);\n    }\n  }\n\n  return {duration, delay, easing};\n}\n/**\n * @param {?} obj\n * @param {?=} destination\n * @return {?}\n */\nexport function copyObj(\n    obj: {[key: string]: any}, destination: {[key: string]: any} = {}): {[key: string]: any} {\n  Object.keys(obj).forEach(prop => { destination[prop] = obj[prop]; });\n  return destination;\n}\n/**\n * @param {?} styles\n * @return {?}\n */\nexport function normalizeStyles(styles: ɵStyleData | ɵStyleData[]): ɵStyleData {\n  const /** @type {?} */ normalizedStyles: ɵStyleData = {};\n  if (Array.isArray(styles)) {\n    styles.forEach(data => copyStyles(data, false, normalizedStyles));\n  } else {\n    copyStyles(styles, false, normalizedStyles);\n  }\n  return normalizedStyles;\n}\n/**\n * @param {?} styles\n * @param {?} readPrototype\n * @param {?=} destination\n * @return {?}\n */\nexport function copyStyles(\n    styles: ɵStyleData, readPrototype: boolean, destination: ɵStyleData = {}): ɵStyleData {\n  if (readPrototype) {\n    // we make use of a for-in loop so that the\n    // prototypically inherited properties are\n    // revealed from the backFill map\n    for (let /** @type {?} */ prop in styles) {\n      destination[prop] = styles[prop];\n    }\n  } else {\n    copyObj(styles, destination);\n  }\n  return destination;\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function setStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      const /** @type {?} */ camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = styles[prop];\n    });\n  }\n}\n/**\n * @param {?} element\n * @param {?} styles\n * @return {?}\n */\nexport function eraseStyles(element: any, styles: ɵStyleData) {\n  if (element['style']) {\n    Object.keys(styles).forEach(prop => {\n      const /** @type {?} */ camelProp = dashCaseToCamelCase(prop);\n      element.style[camelProp] = '';\n    });\n  }\n}\n/**\n * @param {?} steps\n * @return {?}\n */\nexport function normalizeAnimationEntry(steps: AnimationMetadata | AnimationMetadata[]):\n    AnimationMetadata {\n  if (Array.isArray(steps)) {\n    if (steps.length == 1) return steps[0];\n    return sequence(steps);\n  }\n  return /** @type {?} */(( steps as AnimationMetadata));\n}\n/**\n * @param {?} value\n * @param {?} options\n * @param {?} errors\n * @return {?}\n */\nexport function validateStyleParams(\n    value: string | number, options: AnimationOptions, errors: any[]) {\n  const /** @type {?} */ params = options.params || {};\n  const /** @type {?} */ matches = extractStyleParams(value);\n  if (matches.length) {\n    matches.forEach(varName => {\n      if (!params.hasOwnProperty(varName)) {\n        errors.push(\n            `Unable to resolve the local animation param ${varName} in the given list of values`);\n      }\n    });\n  }\n}\n\nconst /** @type {?} */ PARAM_REGEX =\n    new RegExp(`${SUBSTITUTION_EXPR_START}\\\\s*(.+?)\\\\s*${SUBSTITUTION_EXPR_END}`, 'g');\n/**\n * @param {?} value\n * @return {?}\n */\nexport function extractStyleParams(value: string | number): string[] {\n  let /** @type {?} */ params: string[] = [];\n  if (typeof value === 'string') {\n    const /** @type {?} */ val = value.toString();\n\n    let /** @type {?} */ match: any;\n    while (match = PARAM_REGEX.exec(val)) {\n      params.push( /** @type {?} */((match[1] as string)));\n    }\n    PARAM_REGEX.lastIndex = 0;\n  }\n  return params;\n}\n/**\n * @param {?} value\n * @param {?} params\n * @param {?} errors\n * @return {?}\n */\nexport function interpolateParams(\n    value: string | number, params: {[name: string]: any}, errors: any[]): string|number {\n  const /** @type {?} */ original = value.toString();\n  const /** @type {?} */ str = original.replace(PARAM_REGEX, (_, varName) => {\n    let /** @type {?} */ localVal = params[varName];\n    // this means that the value was never overidden by the data passed in by the user\n    if (!params.hasOwnProperty(varName)) {\n      errors.push(`Please provide a value for the animation param ${varName}`);\n      localVal = '';\n    }\n    return localVal.toString();\n  });\n\n  // we do this to assert that numeric values stay as they are\n  return str == original ? value : str;\n}\n/**\n * @param {?} iterator\n * @return {?}\n */\nexport function iteratorToArray(iterator: any): any[] {\n  const /** @type {?} */ arr: any[] = [];\n  let /** @type {?} */ item = iterator.next();\n  while (!item.done) {\n    arr.push(item.value);\n    item = iterator.next();\n  }\n  return arr;\n}\n/**\n * @param {?} source\n * @param {?} destination\n * @return {?}\n */\nexport function mergeAnimationOptions(\n    source: AnimationOptions, destination: AnimationOptions): AnimationOptions {\n  if (source.params) {\n    const /** @type {?} */ p0 = source.params;\n    if (!destination.params) {\n      destination.params = {};\n    }\n    const /** @type {?} */ p1 = destination.params;\n    Object.keys(p0).forEach(param => {\n      if (!p1.hasOwnProperty(param)) {\n        p1[param] = p0[param];\n      }\n    });\n  }\n  return destination;\n}\n\nconst /** @type {?} */ DASH_CASE_REGEXP = /-+([a-z0-9])/g;\n/**\n * @param {?} input\n * @return {?}\n */\nexport function dashCaseToCamelCase(input: string): string {\n  return input.replace(DASH_CASE_REGEXP, (...m: any[]) => m[1].toUpperCase());\n}\n/**\n * @param {?} duration\n * @param {?} delay\n * @return {?}\n */\nexport function allowPreviousPlayerStylesMerge(duration: number, delay: number) {\n  return duration === 0 || delay === 0;\n}\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nimport {AUTO_STYLE, AnimationPlayer, NoopAnimationPlayer, ɵStyleData} from '@angular/animations';\n\nimport {AnimationDriver} from '../../src/render/animation_driver';\nimport {containsElement, invokeQuery, matchesElement} from '../../src/render/shared';\nimport {allowPreviousPlayerStylesMerge} from '../../src/util';\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class MockAnimationDriver implements AnimationDriver {\n  static log: AnimationPlayer[] = [];\n/**\n * @param {?} element\n * @param {?} selector\n * @return {?}\n */\nmatchesElement(element: any, selector: string): boolean {\n    return matchesElement(element, selector);\n  }\n/**\n * @param {?} elm1\n * @param {?} elm2\n * @return {?}\n */\ncontainsElement(elm1: any, elm2: any): boolean { return containsElement(elm1, elm2); }\n/**\n * @param {?} element\n * @param {?} selector\n * @param {?} multi\n * @return {?}\n */\nquery(element: any, selector: string, multi: boolean): any[] {\n    return invokeQuery(element, selector, multi);\n  }\n/**\n * @param {?} element\n * @param {?} prop\n * @param {?=} defaultValue\n * @return {?}\n */\ncomputeStyle(element: any, prop: string, defaultValue?: string): string {\n    return defaultValue || '';\n  }\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @param {?=} previousPlayers\n * @return {?}\n */\nanimate(\n      element: any, keyframes: {[key: string]: string | number}[], duration: number, delay: number,\n      easing: string, previousPlayers: any[] = []): MockAnimationPlayer {\n    const /** @type {?} */ player =\n        new MockAnimationPlayer(element, keyframes, duration, delay, easing, previousPlayers);\n    MockAnimationDriver.log.push( /** @type {?} */((<AnimationPlayer>player)));\n    return player;\n  }\n}\n\nfunction MockAnimationDriver_tsickle_Closure_declarations() {\n/** @type {?} */\nMockAnimationDriver.log;\n}\n\n/**\n * \\@experimental Animation support is experimental.\n */\nexport class MockAnimationPlayer extends NoopAnimationPlayer {\nprivate __finished = false;\nprivate __started = false;\npublic previousStyles: {[key: string]: string | number} = {};\nprivate _onInitFns: (() => any)[] = [];\npublic currentSnapshot: ɵStyleData = {};\n/**\n * @param {?} element\n * @param {?} keyframes\n * @param {?} duration\n * @param {?} delay\n * @param {?} easing\n * @param {?} previousPlayers\n */\nconstructor(\npublic element: any,\npublic keyframes: {[key: string]: string | number}[],\npublic duration: number,\npublic delay: number,\npublic easing: string,\npublic previousPlayers: any[]) {\n    super();\n\n    if (allowPreviousPlayerStylesMerge(duration, delay)) {\n      previousPlayers.forEach(player => {\n        if (player instanceof MockAnimationPlayer) {\n          const /** @type {?} */ styles = player.currentSnapshot;\n          Object.keys(styles).forEach(prop => this.previousStyles[prop] = styles[prop]);\n        }\n      });\n    }\n\n    this.totalTime = delay + duration;\n  }\n/**\n * @param {?} fn\n * @return {?}\n */\nonInit(fn: () => any) { this._onInitFns.push(fn); }\n/**\n * @return {?}\n */\ninit() {\n    super.init();\n    this._onInitFns.forEach(fn => fn());\n    this._onInitFns = [];\n  }\n/**\n * @return {?}\n */\nfinish(): void {\n    super.finish();\n    this.__finished = true;\n  }\n/**\n * @return {?}\n */\ndestroy(): void {\n    super.destroy();\n    this.__finished = true;\n  }\n/**\n * @return {?}\n */\ntriggerMicrotask() {}\n/**\n * @return {?}\n */\nplay(): void {\n    super.play();\n    this.__started = true;\n  }\n/**\n * @return {?}\n */\nhasStarted() { return this.__started; }\n/**\n * @return {?}\n */\nbeforeDestroy() {\n    const /** @type {?} */ captures: ɵStyleData = {};\n\n    Object.keys(this.previousStyles).forEach(prop => {\n      captures[prop] = this.previousStyles[prop];\n    });\n\n    if (this.hasStarted()) {\n      // when assembling the captured styles, it's important that\n      // we build the keyframe styles in the following order:\n      // {other styles within keyframes, ... previousStyles }\n      this.keyframes.forEach(kf => {\n        Object.keys(kf).forEach(prop => {\n          if (prop != 'offset') {\n            captures[prop] = this.__finished ? kf[prop] : AUTO_STYLE;\n          }\n        });\n      });\n    }\n\n    this.currentSnapshot = captures;\n  }\n}\n\nfunction MockAnimationPlayer_tsickle_Closure_declarations() {\n/** @type {?} */\nMockAnimationPlayer.prototype.__finished;\n/** @type {?} */\nMockAnimationPlayer.prototype.__started;\n/** @type {?} */\nMockAnimationPlayer.prototype.previousStyles;\n/** @type {?} */\nMockAnimationPlayer.prototype._onInitFns;\n/** @type {?} */\nMockAnimationPlayer.prototype.currentSnapshot;\n/** @type {?} */\nMockAnimationPlayer.prototype.element;\n/** @type {?} */\nMockAnimationPlayer.prototype.keyframes;\n/** @type {?} */\nMockAnimationPlayer.prototype.duration;\n/** @type {?} */\nMockAnimationPlayer.prototype.delay;\n/** @type {?} */\nMockAnimationPlayer.prototype.easing;\n/** @type {?} */\nMockAnimationPlayer.prototype.previousPlayers;\n}\n\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport {MockAnimationDriver, MockAnimationPlayer} from './mock_animation_driver';\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @module\n * @description\n * Entry point for all public APIs of this package.\n */\nexport {MockAnimationDriver,MockAnimationPlayer} from './src/testing';\n","/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport {MockAnimationDriver,MockAnimationPlayer} from './public_api';\n"],"names":["tslib_1.__extends","AUTO_STYLE","NoopAnimationPlayer"],"mappings":"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"}