{"version":3,"sources":["../../../../../../../packages/platform-webworker/src/web_workers/shared/message_bus.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAWH;;;;;;;;GAQG;AACH;IAAA;IA8BA,CAHC;IAGD,iBAHC;AAGD,CA9BA,AA2BC,IAAA;;AAKD;IAEA;;;;;;;;;;;OAWG;IACH,UAAU,CAAC,SAAS,CAAC,WAAW,GAAG,UAAS,OAAO,EAAE,SAAS,IAAG,CAAC,CAAC;IAEnE;;;;;;;OAOG;IACH,UAAU,CAAC,SAAS,CAAC,YAAY,GAAG,UAAS,IAAI,IAAG,CAAC,CAAC;IAEtD;;;;;;OAMG;IACH,UAAU,CAAC,SAAS,CAAC,IAAI,GAAG,UAAS,OAAO,IAAG,CAAC,CAAC;IAEjD;;;;;;OAMG;IACH,UAAU,CAAC,SAAS,CAAC,EAAE,GAAG,UAAS,OAAO,IAAG,CAAC,CAAC;AAC/C,CAAC;AAED;;;GAGG;AACH,MAAM,+BAA8B,CAAC;AAGrC;IACA;;;;;;OAMG;IACH,gBAAgB,CAAC,SAAS,CAAC,WAAW,CAAC;IACvC;;;;;OAKG;IACH,gBAAgB,CAAC,SAAS,CAAC,YAAY,CAAC;IACxC;;;;OAIG;IACH,gBAAgB,CAAC,SAAS,CAAC,IAAI,CAAC;AAChC,CAAC;AA4BD;;;GAGG;AACH,MAAM,6BAA4B,CAAC;AAGnC;IACA;;;;;;OAMG;IACH,cAAc,CAAC,SAAS,CAAC,WAAW,CAAC;IACrC;;;;;OAKG;IACH,cAAc,CAAC,SAAS,CAAC,YAAY,CAAC;IACtC;;;;OAIG;IACH,cAAc,CAAC,SAAS,CAAC,EAAE,CAAC;AAC5B,CAAC","file":"message_bus.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {EventEmitter, NgZone} from '@angular/core';\n/**\n * Message Bus is a low level API used to communicate between the UI and the background.\n * Communication is based on a channel abstraction. Messages published in a\n * given channel to one MessageBusSink are received on the same channel\n * by the corresponding MessageBusSource.\n * \n * \\@experimental WebWorker support in Angular is currenlty experimental.\n * @abstract\n */\nexport abstract class MessageBus implements MessageBusSource, MessageBusSink {\n  /**\n   * Sets up a new channel on the MessageBus.\n   * MUST be called before calling from or to on the channel.\n   * If runInZone is true then the source will emit events inside the angular zone\n   * and the sink will buffer messages and send only once the zone exits.\n   * if runInZone is false then the source will emit events inside the global zone\n   * and the sink will send messages immediately.\n   */\n  abstract initChannel(channel: string, runInZone?: boolean): void;\n\n  /**\n   * Assigns this bus to the given zone.\n   * Any callbacks attached to channels where runInZone was set to true on initialization\n   * will be executed in the given zone.\n   */\n  abstract attachToZone(zone: NgZone): void;\n\n  /**\n   * Returns an {@link EventEmitter} that emits every time a message\n   * is received on the given channel.\n   */\n  abstract from(channel: string): EventEmitter<any>;\n\n\n  /**\n   * Returns an {@link EventEmitter} for the given channel\n   * To publish methods to that channel just call next on the returned emitter\n   */\n  abstract to(channel: string): EventEmitter<any>;\n}\n\nfunction MessageBus_tsickle_Closure_declarations() {\n\n/**\n * Sets up a new channel on the MessageBus.\n * MUST be called before calling from or to on the channel.\n * If runInZone is true then the source will emit events inside the angular zone\n * and the sink will buffer messages and send only once the zone exits.\n * if runInZone is false then the source will emit events inside the global zone\n * and the sink will send messages immediately.\n * @abstract\n * @param {?} channel\n * @param {?=} runInZone\n * @return {?}\n */\nMessageBus.prototype.initChannel = function(channel, runInZone) {};\n\n/**\n * Assigns this bus to the given zone.\n * Any callbacks attached to channels where runInZone was set to true on initialization\n * will be executed in the given zone.\n * @abstract\n * @param {?} zone\n * @return {?}\n */\nMessageBus.prototype.attachToZone = function(zone) {};\n\n/**\n * Returns an {\\@link EventEmitter} that emits every time a message\n * is received on the given channel.\n * @abstract\n * @param {?} channel\n * @return {?}\n */\nMessageBus.prototype.from = function(channel) {};\n\n/**\n * Returns an {\\@link EventEmitter} for the given channel\n * To publish methods to that channel just call next on the returned emitter\n * @abstract\n * @param {?} channel\n * @return {?}\n */\nMessageBus.prototype.to = function(channel) {};\n}\n\n/**\n * \\@experimental WebWorker support in Angular is currenlty experimental.\n * @record\n */\nexport function MessageBusSource() {}\n\n\nfunction MessageBusSource_tsickle_Closure_declarations() {\n/**\n * Sets up a new channel on the MessageBusSource.\n * MUST be called before calling from on the channel.\n * If runInZone is true then the source will emit events inside the angular zone.\n * if runInZone is false then the source will emit events inside the global zone.\n * @type {?}\n */\nMessageBusSource.prototype.initChannel;\n/**\n * Assigns this source to the given zone.\n * Any channels which are initialized with runInZone set to true will emit events that will be\n * executed within the given zone.\n * @type {?}\n */\nMessageBusSource.prototype.attachToZone;\n/**\n * Returns an {\\@link EventEmitter} that emits every time a message\n * is received on the given channel.\n * @type {?}\n */\nMessageBusSource.prototype.from;\n}\n\n\n/**\n * @experimental WebWorker support in Angular is currenlty experimental.\n */\nexport interface MessageBusSource {\n  /**\n   * Sets up a new channel on the MessageBusSource.\n   * MUST be called before calling from on the channel.\n   * If runInZone is true then the source will emit events inside the angular zone.\n   * if runInZone is false then the source will emit events inside the global zone.\n   */\n  initChannel(channel: string, runInZone: boolean): void;\n\n  /**\n   * Assigns this source to the given zone.\n   * Any channels which are initialized with runInZone set to true will emit events that will be\n   * executed within the given zone.\n   */\n  attachToZone(zone: NgZone): void;\n\n  /**\n   * Returns an {@link EventEmitter} that emits every time a message\n   * is received on the given channel.\n   */\n  from(channel: string): EventEmitter<any>;\n}\n/**\n * \\@experimental WebWorker support in Angular is currenlty experimental.\n * @record\n */\nexport function MessageBusSink() {}\n\n\nfunction MessageBusSink_tsickle_Closure_declarations() {\n/**\n * Sets up a new channel on the MessageBusSink.\n * MUST be called before calling to on the channel.\n * If runInZone is true the sink will buffer messages and send only once the zone exits.\n * if runInZone is false the sink will send messages immediately.\n * @type {?}\n */\nMessageBusSink.prototype.initChannel;\n/**\n * Assigns this sink to the given zone.\n * Any channels which are initialized with runInZone set to true will wait for the given zone\n * to exit before sending messages.\n * @type {?}\n */\nMessageBusSink.prototype.attachToZone;\n/**\n * Returns an {\\@link EventEmitter} for the given channel\n * To publish methods to that channel just call next on the returned emitter\n * @type {?}\n */\nMessageBusSink.prototype.to;\n}\n\n\n/**\n * @experimental WebWorker support in Angular is currenlty experimental.\n */\nexport interface MessageBusSink {\n  /**\n   * Sets up a new channel on the MessageBusSink.\n   * MUST be called before calling to on the channel.\n   * If runInZone is true the sink will buffer messages and send only once the zone exits.\n   * if runInZone is false the sink will send messages immediately.\n   */\n  initChannel(channel: string, runInZone: boolean): void;\n\n  /**\n   * Assigns this sink to the given zone.\n   * Any channels which are initialized with runInZone set to true will wait for the given zone\n   * to exit before sending messages.\n   */\n  attachToZone(zone: NgZone): void;\n\n  /**\n   * Returns an {@link EventEmitter} for the given channel\n   * To publish methods to that channel just call next on the returned emitter\n   */\n  to(channel: string): EventEmitter<any>;\n}\n"]}