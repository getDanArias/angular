{"version":3,"sources":["../../../../../packages/common/http/src/jsonp.ts"],"names":[],"mappings":"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","file":"jsonp.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT} from '@angular/common';\nimport {Inject, Injectable, InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend, HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpErrorResponse, HttpEvent, HttpEventType, HttpResponse} from './response';\n\n// Every request made through JSONP needs a callback name that's unique across the\n// whole page. Each request is assigned an id and the callback name is constructed\n// from that. The next id to be assigned is tracked in a global variable here that\n// is shared among all applications on the page.\nlet /** @type {?} */ nextRequestId: number = 0;\n\n// Error text given when a JSONP script is injected, but doesn't invoke the callback\n// passed in its URL.\nexport const /** @type {?} */ JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';\n\n// Error text given when a request is passed to the JsonpClientBackend that doesn't\n// have a request method JSONP.\nexport const /** @type {?} */ JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';\nexport const /** @type {?} */ JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';\n/**\n * DI token/abstract type representing a map of JSONP callbacks.\n * \n * In the browser, this should always be the `window` object.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class JsonpCallbackContext { [key: string]: (data: any) => void; }\n/**\n * `HttpBackend` that only processes `HttpRequest` with the JSONP method,\n * by performing JSONP style requests.\n * \n * \\@experimental\n */\nexport class JsonpClientBackend implements HttpBackend {\n/**\n * @param {?} callbackMap\n * @param {?} document\n */\nconstructor(private callbackMap: JsonpCallbackContext,\nprivate document: any) {}\n/**\n * Get the name of the next callback method, by incrementing the global `nextRequestId`.\n * @return {?}\n */\n\nprivate nextCallback(): string { return `ng_jsonp_callback_${nextRequestId++}`; }\n/**\n * Process a JSONP request and return an event stream of the results.\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<never>): Observable<HttpEvent<any>> {\n    // Firstly, check both the method and response type. If either doesn't match\n    // then the request was improperly routed here and cannot be handled.\n    if (req.method !== 'JSONP') {\n      throw new Error(JSONP_ERR_WRONG_METHOD);\n    } else if (req.responseType !== 'json') {\n      throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);\n    }\n\n    // Everything else happens inside the Observable boundary.\n    return new Observable<HttpEvent<any>>((observer: Observer<HttpEvent<any>>) => {\n      // The first step to make a request is to generate the callback name, and replace the\n      // callback placeholder in the URL with the name. Care has to be taken here to ensure\n      // a trailing &, if matched, gets inserted back into the URL in the correct place.\n      const /** @type {?} */ callback = this.nextCallback();\n      const /** @type {?} */ url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, `=${callback}$1`);\n\n      // Construct the <script> tag and point it at the URL.\n      const /** @type {?} */ node = this.document.createElement('script');\n      node.src = url;\n\n      // A JSONP request requires waiting for multiple callbacks. These variables\n      // are closed over and track state across those callbacks.\n\n      // The response object, if one has been received, or null otherwise.\n      let /** @type {?} */ body: any|null = null;\n\n      // Whether the response callback has been called.\n      let /** @type {?} */ finished: boolean = false;\n\n      // Whether the request has been cancelled (and thus any other callbacks)\n      // should be ignored.\n      let /** @type {?} */ cancelled: boolean = false;\n\n      // Set the response callback in this.callbackMap (which will be the window\n      // object in the browser. The script being loaded via the <script> tag will\n      // eventually call this callback.\n      this.callbackMap[callback] = (data?: any) => {\n        // Data has been received from the JSONP script. Firstly, delete this callback.\n        delete this.callbackMap[callback];\n\n        // Next, make sure the request wasn't cancelled in the meantime.\n        if (cancelled) {\n          return;\n        }\n\n        // Set state to indicate data was received.\n        body = data;\n        finished = true;\n      };\n\n      // cleanup() is a utility closure that removes the <script> from the page and\n      // the response callback from the window. This logic is used in both the\n      // success, error, and cancellation paths, so it's extracted out for convenience.\n      const /** @type {?} */ cleanup = () => {\n        // Remove the <script> tag if it's still on the page.\n        if (node.parentNode) {\n          node.parentNode.removeChild(node);\n        }\n\n        // Remove the response callback from the callbackMap (window object in the\n        // browser).\n        delete this.callbackMap[callback];\n      };\n\n      // onLoad() is the success callback which runs after the response callback\n      // if the JSONP script loads successfully. The event itself is unimportant.\n      // If something went wrong, onLoad() may run without the response callback\n      // having been invoked.\n      const /** @type {?} */ onLoad = (event: Event) => {\n        // Do nothing if the request has been cancelled.\n        if (cancelled) {\n          return;\n        }\n\n        // Cleanup the page.\n        cleanup();\n\n        // Check whether the response callback has run.\n        if (!finished) {\n          // It hasn't, something went wrong with the request. Return an error via\n          // the Observable error path. All JSONP errors have status 0.\n          observer.error(new HttpErrorResponse({\n            url,\n            status: 0,\n            statusText: 'JSONP Error',\n            error: new Error(JSONP_ERR_NO_CALLBACK),\n          }));\n          return;\n        }\n\n        // Success. body either contains the response body or null if none was\n        // returned.\n        observer.next(new HttpResponse({\n          body,\n          status: 200,\n          statusText: 'OK', url,\n        }));\n\n        // Complete the stream, the resposne is over.\n        observer.complete();\n      };\n\n      // onError() is the error callback, which runs if the script returned generates\n      // a Javascript error. It emits the error via the Observable error channel as\n      // a HttpErrorResponse.\n      const /** @type {?} */ onError: any = (error: Error) => {\n        // If the request was already cancelled, no need to emit anything.\n        if (cancelled) {\n          return;\n        }\n        cleanup();\n\n        // Wrap the error in a HttpErrorResponse.\n        observer.error(new HttpErrorResponse({\n          error,\n          status: 0,\n          statusText: 'JSONP Error', url,\n        }));\n      };\n\n      // Subscribe to both the success (load) and error events on the <script> tag,\n      // and add it to the page.\n      node.addEventListener('load', onLoad);\n      node.addEventListener('error', onError);\n      this.document.body.appendChild(node);\n\n      // The request has now been successfully sent.\n      observer.next({type: HttpEventType.Sent});\n\n      // Cancellation handler.\n      return () => {\n        // Track the cancellation so event listeners won't do anything even if already scheduled.\n        cancelled = true;\n\n        // Remove the event listeners so they won't run if the events later fire.\n        node.removeEventListener('load', onLoad);\n        node.removeEventListener('error', onError);\n\n        // And finally, clean up the page.\n        cleanup();\n      };\n    });\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: JsonpCallbackContext, },\n{type: undefined, decorators: [{ type: Inject, args: [DOCUMENT, ] }, ]},\n];\n}\n\nfunction JsonpClientBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonpClientBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonpClientBackend.ctorParameters;\n/** @type {?} */\nJsonpClientBackend.prototype.callbackMap;\n/** @type {?} */\nJsonpClientBackend.prototype.document;\n}\n\n/**\n * An `HttpInterceptor` which identifies requests with the method JSONP and\n * shifts them to the `JsonpClientBackend`.\n * \n * \\@experimental\n */\nexport class JsonpInterceptor {\n/**\n * @param {?} jsonp\n */\nconstructor(private jsonp: JsonpClientBackend) {}\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    if (req.method === 'JSONP') {\n      return this.jsonp.handle( /** @type {?} */((req as HttpRequest<never>)));\n    }\n    // Fall through for normal HTTP requests.\n    return next.handle(req);\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: JsonpClientBackend, },\n];\n}\n\nfunction JsonpInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nJsonpInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nJsonpInterceptor.ctorParameters;\n/** @type {?} */\nJsonpInterceptor.prototype.jsonp;\n}\n\n"]}