{"version":3,"sources":["../../../../../../packages/common/http/src/xsrf.ts"],"names":[],"mappings":"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","file":"xsrf.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {DOCUMENT, ÉµparseCookieValue as parseCookieValue} from '@angular/common';\nimport {Inject, Injectable, InjectionToken, PLATFORM_ID} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\n\nimport {HttpHandler} from './backend';\nimport {HttpInterceptor} from './interceptor';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n\nexport const /** @type {?} */ XSRF_COOKIE_NAME = new InjectionToken<string>('XSRF_COOKIE_NAME');\nexport const /** @type {?} */ XSRF_HEADER_NAME = new InjectionToken<string>('XSRF_HEADER_NAME');\n/**\n * Retrieves the current XSRF token to use with the next outgoing request.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class HttpXsrfTokenExtractor {\n  /**\n   * Get the XSRF token to use with an outgoing request.\n   *\n   * Will be called for every request, so the token may change between requests.\n   */\n  abstract getToken(): string|null;\n}\n\nfunction HttpXsrfTokenExtractor_tsickle_Closure_declarations() {\n\n/**\n * Get the XSRF token to use with an outgoing request.\n * \n * Will be called for every request, so the token may change between requests.\n * @abstract\n * @return {?}\n */\nHttpXsrfTokenExtractor.prototype.getToken = function() {};\n}\n\n/**\n * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.\n */\nexport class HttpXsrfCookieExtractor implements HttpXsrfTokenExtractor {\nprivate lastCookieString: string = '';\nprivate lastToken: string|null = null;\n/**\n * \\@internal for testing\n */\nparseCount: number = 0;\n/**\n * @param {?} doc\n * @param {?} platform\n * @param {?} cookieName\n */\nconstructor(\nprivate doc: any,\nprivate platform: string,\nprivate cookieName: string) {}\n/**\n * @return {?}\n */\ngetToken(): string|null {\n    if (this.platform === 'server') {\n      return null;\n    }\n    const /** @type {?} */ cookieString = this.doc.cookie || '';\n    if (cookieString !== this.lastCookieString) {\n      this.parseCount++;\n      this.lastToken = parseCookieValue(cookieString, this.cookieName);\n      this.lastCookieString = cookieString;\n    }\n    return this.lastToken;\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: undefined, decorators: [{ type: Inject, args: [DOCUMENT, ] }, ]},\n{type: undefined, decorators: [{ type: Inject, args: [PLATFORM_ID, ] }, ]},\n{type: undefined, decorators: [{ type: Inject, args: [XSRF_COOKIE_NAME, ] }, ]},\n];\n}\n\nfunction HttpXsrfCookieExtractor_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXsrfCookieExtractor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXsrfCookieExtractor.ctorParameters;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.lastCookieString;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.lastToken;\n/**\n * \\@internal for testing\n * @type {?}\n */\nHttpXsrfCookieExtractor.prototype.parseCount;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.doc;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.platform;\n/** @type {?} */\nHttpXsrfCookieExtractor.prototype.cookieName;\n}\n\n/**\n * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.\n */\nexport class HttpXsrfInterceptor implements HttpInterceptor {\n/**\n * @param {?} tokenService\n * @param {?} headerName\n */\nconstructor(\nprivate tokenService: HttpXsrfTokenExtractor,\nprivate headerName: string) {}\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const /** @type {?} */ lcUrl = req.url.toLowerCase();\n    // Skip both non-mutating requests and absolute URLs.\n    // Non-mutating requests don't require a token, and absolute URLs require special handling\n    // anyway as the cookie set\n    // on our origin is not the same as the token expected by another origin.\n    if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||\n        lcUrl.startsWith('https://')) {\n      return next.handle(req);\n    }\n    const /** @type {?} */ token = this.tokenService.getToken();\n\n    // Be careful not to overwrite an existing header of the same name.\n    if (token !== null && !req.headers.has(this.headerName)) {\n      req = req.clone({headers: req.headers.set(this.headerName, token)});\n    }\n    return next.handle(req);\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: HttpXsrfTokenExtractor, },\n{type: undefined, decorators: [{ type: Inject, args: [XSRF_HEADER_NAME, ] }, ]},\n];\n}\n\nfunction HttpXsrfInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXsrfInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXsrfInterceptor.ctorParameters;\n/** @type {?} */\nHttpXsrfInterceptor.prototype.tokenService;\n/** @type {?} */\nHttpXsrfInterceptor.prototype.headerName;\n}\n\n"]}