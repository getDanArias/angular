{"version":3,"sources":["../../../../../../packages/common/http/src/interceptor.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH;;;;;;GAMG;AAEH,OALO,EAAA,UAAE,EAAW,cAAA,EAAe,MAAA,eAAA,CAAA;AAWnC;;;;;;;;;;;GAWG;AACH,MAAM,8BAA6B,CAAC;AAGpC;IACA;;;;;;;;;;;;;;;;OAgBC;IACD,eAAe,CAAA,SAAO,CAAA,SAAM,CAAA;AAC5B,CAAC;AAiCD;;;;GAIG;AACH;IACA;;;OAGG;IACH,gCA5CsB,IAAM,EAAqB,WAAa;QAAxC,SAAA,GAAA,IAAA,CAAM;QAAqB,gBAAA,GAAA,WAAA,CAAa;IAAiB,CAAA;IA8C/E;;;OAGG;IACH,uCAhDG,GAgDH,UAhDS,GAAqB;QAiD1B,MAAM,CAhDC,IAAA,CAAK,WAAC,CAAW,SAAC,CAAS,GAAC,EAAI,IAAA,CAAK,IAAC,CAAI,CAAC;IAiDpD,CAAC;IACH,6BAhDC;AAgDD,CAdA,AAlCC,IAAA;;AAkDD;IACA,gBAAgB;IAChB,sBAAsB,CAAC,SAAS,CAAC,IAAI,CAAC;IACtC,gBAAgB;IAChB,sBAAsB,CAAC,SAAS,CAAC,WAAW,CAAC;AAC7C,CAAC;AAED;;;;;GAKG;AACH,MAvDC,CAAM,IAAA,gBAAA,CAAM,iBAAA,GAAoB,IAAI,cAAA,CAAiC,mBAAE,CAAmB,CAAC;AAwD5F;IAAA;IAeA,CAhEC;IAkDD;;;;OAIG;IACH,mCA1DG,GA0DH,UA1DY,GAAqB,EAAE,IAAM;QA2DrC,MAAM,CA1DC,IAAA,CAAK,MAAC,CAAM,GAAC,CAAG,CAAC;IA2D1B,CAAC;IAOH,sBAhEC;AAgED,CAfA,AAjDC;;AAAM,0BAAA,GAA+C;IA2DtD,EA1DE,IAAA,EAAM,UAAA,EANN;CAiED,CA1DC;AA2DF,kBAAkB;AAzDX,8BAAA,GAA4F,cAAM,OAAA,EA2DxG,EA3DwG,CA2DxG,CA1DC;AA6DF;IACA,gBAAgB;IAChB,eAAe,CAAC,UAAU,CAAC;IAC3B;;;OAGG;IACH,eAAe,CAAC,cAAc,CAAC;AAC/B,CAAC","file":"interceptor.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable, InjectionToken} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\n\nimport {HttpHandler} from './backend';\nimport {HttpRequest} from './request';\nimport {HttpEvent} from './response';\n/**\n * Intercepts `HttpRequest` and handles them.\n * \n * Most interceptors will transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n * \n * In rare cases, interceptors may wish to completely handle a request themselves,\n * and not delegate to the remainder of the chain. This behavior is allowed.\n * \n * \\@experimental\n * @record\n */\nexport function HttpInterceptor() {}\n\n\nfunction HttpInterceptor_tsickle_Closure_declarations() {\n/**\n * Intercept an outgoing `HttpRequest` and optionally transform it or the\n * response.\n * \n * Typically an interceptor will transform the outgoing request before returning\n * `next.handle(transformedReq)`. An interceptor may choose to transform the\n * response event stream as well, by applying additional Rx operators on the stream\n * returned by `next.handle()`.\n * \n * More rarely, an interceptor may choose to completely handle the request itself,\n * and compose a new event stream instead of invoking `next.handle()`. This is\n * acceptable behavior, but keep in mind further interceptors will be skipped entirely.\n * \n * It is also rare but valid for an interceptor to return multiple responses on the\n * event stream for a single request.\n * @type {?}\n */\nHttpInterceptor.prototype.intercept;\n}\n\n\n/**\n * Intercepts `HttpRequest` and handles them.\n *\n * Most interceptors will transform the outgoing request before passing it to the\n * next interceptor in the chain, by calling `next.handle(transformedReq)`.\n *\n * In rare cases, interceptors may wish to completely handle a request themselves,\n * and not delegate to the remainder of the chain. This behavior is allowed.\n *\n * @experimental\n */\nexport interface HttpInterceptor {\n  /**\n   * Intercept an outgoing `HttpRequest` and optionally transform it or the\n   * response.\n   *\n   * Typically an interceptor will transform the outgoing request before returning\n   * `next.handle(transformedReq)`. An interceptor may choose to transform the\n   * response event stream as well, by applying additional Rx operators on the stream\n   * returned by `next.handle()`.\n   *\n   * More rarely, an interceptor may choose to completely handle the request itself,\n   * and compose a new event stream instead of invoking `next.handle()`. This is\n   * acceptable behavior, but keep in mind further interceptors will be skipped entirely.\n   *\n   * It is also rare but valid for an interceptor to return multiple responses on the\n   * event stream for a single request.\n   */\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>>;\n}\n/**\n * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.\n * \n * \\@experimental\n */\nexport class HttpInterceptorHandler implements HttpHandler {\n/**\n * @param {?} next\n * @param {?} interceptor\n */\nconstructor(private next: HttpHandler,\nprivate interceptor: HttpInterceptor) {}\n/**\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    return this.interceptor.intercept(req, this.next);\n  }\n}\n\nfunction HttpInterceptorHandler_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpInterceptorHandler.prototype.next;\n/** @type {?} */\nHttpInterceptorHandler.prototype.interceptor;\n}\n\n/**\n * A multi-provider token which represents the array of `HttpInterceptor`s that\n * are registered.\n * \n * \\@experimental\n */\nexport const /** @type {?} */ HTTP_INTERCEPTORS = new InjectionToken<HttpInterceptor[]>('HTTP_INTERCEPTORS');\nexport class NoopInterceptor implements HttpInterceptor {\n/**\n * @param {?} req\n * @param {?} next\n * @return {?}\n */\nintercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    return next.handle(req);\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction NoopInterceptor_tsickle_Closure_declarations() {\n/** @type {?} */\nNoopInterceptor.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nNoopInterceptor.ctorParameters;\n}\n\n"]}