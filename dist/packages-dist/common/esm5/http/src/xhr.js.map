{"version":3,"sources":["../../../../../../packages/common/http/src/xhr.ts"],"names":[],"mappings":"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","file":"xhr.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {Observer} from 'rxjs/Observer';\n\nimport {HttpBackend} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpRequest} from './request';\nimport {HttpDownloadProgressEvent, HttpErrorResponse, HttpEvent, HttpEventType, HttpHeaderResponse, HttpJsonParseError, HttpResponse, HttpUploadProgressEvent} from './response';\n\nconst /** @type {?} */ XSSI_PREFIX = /^\\)\\]\\}',?\\n/;\n/**\n * Determine an appropriate URL for the response, by checking either\n * XMLHttpRequest.responseURL or the X-Request-URL header.\n * @param {?} xhr\n * @return {?}\n */\nfunction getResponseUrl(xhr: any): string|null {\n  if ('responseURL' in xhr && xhr.responseURL) {\n    return xhr.responseURL;\n  }\n  if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {\n    return xhr.getResponseHeader('X-Request-URL');\n  }\n  return null;\n}\n/**\n * A wrapper around the `XMLHttpRequest` constructor.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class XhrFactory { abstract build(): XMLHttpRequest; }\n\nfunction XhrFactory_tsickle_Closure_declarations() {\n\n/**\n * @abstract\n * @return {?}\n */\nXhrFactory.prototype.build = function() {};\n}\n\n/**\n * A factory for \\@{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.\n * \n * \\@experimental\n */\nexport class BrowserXhr implements XhrFactory {\nconstructor() {}\n/**\n * @return {?}\n */\nbuild(): any { return /** @type {?} */(( <any>(new XMLHttpRequest()))); }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n];\n}\n\nfunction BrowserXhr_tsickle_Closure_declarations() {\n/** @type {?} */\nBrowserXhr.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nBrowserXhr.ctorParameters;\n}\n\n/**\n * Tracks a response from the server that does not yet have a body.\n * @record\n */\nfunction PartialResponse() {}\n\n\nfunction PartialResponse_tsickle_Closure_declarations() {\n/** @type {?} */\nPartialResponse.prototype.headers;\n/** @type {?} */\nPartialResponse.prototype.status;\n/** @type {?} */\nPartialResponse.prototype.statusText;\n/** @type {?} */\nPartialResponse.prototype.url;\n}\n\n\n/**\n * Tracks a response from the server that does not yet have a body.\n */\ninterface PartialResponse {\n  headers: HttpHeaders;\n  status: number;\n  statusText: string;\n  url: string;\n}\n/**\n * An `HttpBackend` which uses the XMLHttpRequest API to send\n * requests to a backend server.\n * \n * \\@experimental\n */\nexport class HttpXhrBackend implements HttpBackend {\n/**\n * @param {?} xhrFactory\n */\nconstructor(private xhrFactory: XhrFactory) {}\n/**\n * Process a request and return a stream of response events.\n * @param {?} req\n * @return {?}\n */\nhandle(req: HttpRequest<any>): Observable<HttpEvent<any>> {\n    // Quick check to give a better error message when a user attempts to use\n    // HttpClient.jsonp() without installing the JsonpClientModule\n    if (req.method === 'JSONP') {\n      throw new Error(`Attempted to construct Jsonp request without JsonpClientModule installed.`);\n    }\n\n    // Everything happens on Observable subscription.\n    return new Observable((observer: Observer<HttpEvent<any>>) => {\n      // Start by setting up the XHR object with request method, URL, and withCredentials flag.\n      const /** @type {?} */ xhr = this.xhrFactory.build();\n      xhr.open(req.method, req.urlWithParams);\n      if (!!req.withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      // Add all the requested headers.\n      req.headers.forEach((name, values) => xhr.setRequestHeader(name, values.join(',')));\n\n      // Add an Accept header if one isn't present already.\n      if (!req.headers.has('Accept')) {\n        xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');\n      }\n\n      // Auto-detect the Content-Type header if one isn't present already.\n      if (!req.headers.has('Content-Type')) {\n        const /** @type {?} */ detectedType = req.detectContentTypeHeader();\n        // Sometimes Content-Type detection fails.\n        if (detectedType !== null) {\n          xhr.setRequestHeader('Content-Type', detectedType);\n        }\n      }\n\n      // Set the responseType if one was requested.\n      if (req.responseType) {\n        xhr.responseType = /** @type {?} */(( req.responseType.toLowerCase() as any));\n      }\n\n      // Serialize the request body if one is present. If not, this will be set to null.\n      const /** @type {?} */ reqBody = req.serializeBody();\n\n      // If progress events are enabled, response headers will be delivered\n      // in two events - the HttpHeaderResponse event and the full HttpResponse\n      // event. However, since response headers don't change in between these\n      // two events, it doesn't make sense to parse them twice. So headerResponse\n      // caches the data extracted from the response whenever it's first parsed,\n      // to ensure parsing isn't duplicated.\n      let /** @type {?} */ headerResponse: HttpHeaderResponse|null = null;\n\n      // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest\n      // state, and memoizes it into headerResponse.\n      const /** @type {?} */ partialFromXhr = (): HttpHeaderResponse => {\n        if (headerResponse !== null) {\n          return headerResponse;\n        }\n\n        // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).\n        const /** @type {?} */ status: number = xhr.status === 1223 ? 204 : xhr.status;\n        const /** @type {?} */ statusText = xhr.statusText || 'OK';\n\n        // Parse headers from XMLHttpRequest - this step is lazy.\n        const /** @type {?} */ headers = new HttpHeaders(xhr.getAllResponseHeaders());\n\n        // Read the response URL from the XMLHttpResponse instance and fall back on the\n        // request URL.\n        const /** @type {?} */ url = getResponseUrl(xhr) || req.url;\n\n        // Construct the HttpHeaderResponse and memoize it.\n        headerResponse = new HttpHeaderResponse({headers, status, statusText, url});\n        return headerResponse;\n      };\n\n      // Next, a few closures are defined for the various events which XMLHttpRequest can\n      // emit. This allows them to be unregistered as event listeners later.\n\n      // First up is the load event, which represents a response being fully available.\n      const /** @type {?} */ onLoad = () => {\n        // Read response state from the memoized partial data.\n        let {headers, status, statusText, url} = partialFromXhr();\n\n        // The body will be read out if present.\n        let /** @type {?} */ body: any|null = null;\n\n        if (status !== 204) {\n          // Use XMLHttpRequest.response if set, responseText otherwise.\n          body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;\n\n          // Strip a common XSSI prefix from string responses.\n          // TODO: determine if this behavior should be optional and moved to an interceptor.\n          if (typeof body === 'string') {\n            body = body.replace(XSSI_PREFIX, '');\n          }\n        }\n\n        // Normalize another potential bug (this one comes from CORS).\n        if (status === 0) {\n          status = !!body ? 200 : 0;\n        }\n\n        // ok determines whether the response will be transmitted on the event or\n        // error channel. Unsuccessful status codes (not 2xx) will always be errors,\n        // but a successful status code can still result in an error if the user\n        // asked for JSON data and the body cannot be parsed as such.\n        let /** @type {?} */ ok = status >= 200 && status < 300;\n\n        // Check whether the body needs to be parsed as JSON (in many cases the browser\n        // will have done that already).\n        if (ok && typeof body === 'string' && req.responseType === 'json') {\n          // Attempt the parse. If it fails, a parse error should be delivered to the user.\n          try {\n            body = JSON.parse(body);\n          } catch ( /** @type {?} */error) {\n            // Even though the response status was 2xx, this is still an error.\n            ok = false;\n            // The parse error contains the text of the body that failed to parse.\n            body = /** @type {?} */(( { error, text: body } as HttpJsonParseError));\n          }\n        }\n\n        if (ok) {\n          // A successful response is delivered on the event stream.\n          observer.next(new HttpResponse({\n            body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n          // The full body has been received and delivered, no further events\n          // are possible. This request is complete.\n          observer.complete();\n        } else {\n          // An unsuccessful request is delivered on the error channel.\n          observer.error(new HttpErrorResponse({\n            // The error in this case is the response body (error from the server).\n            error: body,\n            headers,\n            status,\n            statusText,\n            url: url || undefined,\n          }));\n        }\n      };\n\n      // The onError callback is called when something goes wrong at the network level.\n      // Connection timeout, DNS error, offline, etc. These are actual errors, and are\n      // transmitted on the error channel.\n      const /** @type {?} */ onError = (error: ErrorEvent) => {\n        const /** @type {?} */ res = new HttpErrorResponse({\n          error,\n          status: xhr.status || 0,\n          statusText: xhr.statusText || 'Unknown Error',\n        });\n        observer.error(res);\n      };\n\n      // The sentHeaders flag tracks whether the HttpResponseHeaders event\n      // has been sent on the stream. This is necessary to track if progress\n      // is enabled since the event will be sent on only the first download\n      // progerss event.\n      let /** @type {?} */ sentHeaders = false;\n\n      // The download progress event handler, which is only registered if\n      // progress events are enabled.\n      const /** @type {?} */ onDownProgress = (event: ProgressEvent) => {\n        // Send the HttpResponseHeaders event if it hasn't been sent already.\n        if (!sentHeaders) {\n          observer.next(partialFromXhr());\n          sentHeaders = true;\n        }\n\n        // Start building the download progress event to deliver on the response\n        // event stream.\n        let /** @type {?} */ progressEvent: HttpDownloadProgressEvent = {\n          type: HttpEventType.DownloadProgress,\n          loaded: event.loaded,\n        };\n\n        // Set the total number of bytes in the event if it's available.\n        if (event.lengthComputable) {\n          progressEvent.total = event.total;\n        }\n\n        // If the request was for text content and a partial response is\n        // available on XMLHttpRequest, include it in the progress event\n        // to allow for streaming reads.\n        if (req.responseType === 'text' && !!xhr.responseText) {\n          progressEvent.partialText = xhr.responseText;\n        }\n\n        // Finally, fire the event.\n        observer.next(progressEvent);\n      };\n\n      // The upload progress event handler, which is only registered if\n      // progress events are enabled.\n      const /** @type {?} */ onUpProgress = (event: ProgressEvent) => {\n        // Upload progress events are simpler. Begin building the progress\n        // event.\n        let /** @type {?} */ progress: HttpUploadProgressEvent = {\n          type: HttpEventType.UploadProgress,\n          loaded: event.loaded,\n        };\n\n        // If the total number of bytes being uploaded is available, include\n        // it.\n        if (event.lengthComputable) {\n          progress.total = event.total;\n        }\n\n        // Send the event.\n        observer.next(progress);\n      };\n\n      // By default, register for load and error events.\n      xhr.addEventListener('load', onLoad);\n      xhr.addEventListener('error', onError);\n\n      // Progress events are only enabled if requested.\n      if (req.reportProgress) {\n        // Download progress is always enabled if requested.\n        xhr.addEventListener('progress', onDownProgress);\n\n        // Upload progress depends on whether there is a body to upload.\n        if (reqBody !== null && xhr.upload) {\n          xhr.upload.addEventListener('progress', onUpProgress);\n        }\n      }\n\n      // Fire the request, and notify the event stream that it was fired.\n      xhr.send(reqBody);\n      observer.next({type: HttpEventType.Sent});\n\n      // This is the return from the Observable function, which is the\n      // request cancellation handler.\n      return () => {\n        // On a cancellation, remove all registered event listeners.\n        xhr.removeEventListener('error', onError);\n        xhr.removeEventListener('load', onLoad);\n        if (req.reportProgress) {\n          xhr.removeEventListener('progress', onDownProgress);\n          if (reqBody !== null && xhr.upload) {\n            xhr.upload.removeEventListener('progress', onUpProgress);\n          }\n        }\n\n        // Finally, abort the in-flight request.\n        xhr.abort();\n      };\n    });\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: XhrFactory, },\n];\n}\n\nfunction HttpXhrBackend_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpXhrBackend.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpXhrBackend.ctorParameters;\n/** @type {?} */\nHttpXhrBackend.prototype.xhrFactory;\n}\n\n"]}