{"version":3,"sources":["../../../../../../packages/common/http/src/client.ts"],"names":[],"mappings":"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","file":"client.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injectable} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {of } from 'rxjs/observable/of';\nimport {concatMap} from 'rxjs/operator/concatMap';\nimport {filter} from 'rxjs/operator/filter';\nimport {map} from 'rxjs/operator/map';\n\nimport {HttpHandler} from './backend';\nimport {HttpHeaders} from './headers';\nimport {HttpParams} from './params';\nimport {HttpRequest} from './request';\nimport {HttpEvent, HttpResponse} from './response';\n/**\n * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and\n * the given `body`. Basically, this clones the object and adds the body.\n * @template T\n * @param {?} options\n * @param {?} body\n * @return {?}\n */\nfunction addBody<T>(\n    options: {\n      headers?: HttpHeaders,\n      observe?: HttpObserve,\n      params?: HttpParams,\n      reportProgress?: boolean,\n      responseType?: 'arraybuffer' | 'blob' | 'json' | 'text',\n      withCredentials?: boolean,\n    },\n    body: T | null): any {\n  return {\n    body,\n    headers: options.headers,\n    observe: options.observe,\n    params: options.params,\n    reportProgress: options.reportProgress,\n    responseType: options.responseType,\n    withCredentials: options.withCredentials,\n  };\n}\n\n/**\n * @experimental\n */\nexport type HttpObserve = 'body' | 'events' | 'response';\n/**\n * Perform HTTP requests.\n * \n * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.\n * Each request method has multiple signatures, and the return type varies according to which\n * signature is called (mainly the values of `observe` and `responseType`).\n * \n * \\@experimental\n */\nexport class HttpClient {\n/**\n * @param {?} handler\n */\nconstructor(private handler: HttpHandler) {}\n\n  /**\n   * Send the given `HttpRequest` and return a stream of `HttpEvents`.\n   */\n  request<R>(req: HttpRequest<any>): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    params?: HttpParams,\n    observe: 'events', reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as an `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'events', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<any>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'events', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<R>>;\n\n  /**\n   * Construct a request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'response', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    reportProgress?: boolean,\n    observe: 'response', params?: HttpParams, responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpResponse<R>>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `R`.\n   */\n  request<R>(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    responseType?: 'json',\n    reportProgress?: boolean,\n    withCredentials?: boolean,\n  }): Observable<R>;\n\n  /**\n   * Construct a request in a manner where response type and requested `Observable` are not known\n   * statically.\n   *\n   * @return an `Observable` of whatever was requested, typed to `any`.\n   */\n  request(method: string, url: string, options?: {\n    body?: any,\n    headers?: HttpHeaders,\n    params?: HttpParams,\n    observe?: HttpObserve,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  }): Observable<any>;\n/**\n * Constructs an `Observable` for a particular HTTP request that, when subscribed,\n * fires the request through the chain of registered interceptors and on to the\n * server.\n * \n * This method can be called in one of two ways. Either an `HttpRequest`\n * instance can be passed directly as the only parameter, or a method can be\n * passed as the first parameter, a string URL as the second, and an\n * options hash as the third.\n * \n * If a `HttpRequest` object is passed directly, an `Observable` of the\n * raw `HttpEvent` stream will be returned.\n * \n * If a request is instead built by providing a URL, the options object\n * determines the return type of `request()`. In addition to configuring\n * request parameters such as the outgoing headers and/or the body, the options\n * hash specifies two key pieces of information about the request: the\n * `responseType` and what to `observe`.\n * \n * The `responseType` value determines how a successful response body will be\n * parsed. If `responseType` is the default `json`, a type interface for the\n * resulting object may be passed as a type parameter to `request()`.\n * \n * The `observe` value determines the return type of `request()`, based on what\n * the consumer is interested in observing. A value of `events` will return an\n * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,\n * including progress events by default. A value of `response` will return an\n * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`\n * depends on the `responseType` and any optionally provided type parameter.\n * A value of `body` will return an `Observable<T>` with the same `T` body type.\n * @param {?} first\n * @param {?=} url\n * @param {?=} options\n * @return {?}\n */\nrequest(first: string|HttpRequest<any>, url?: string, options: {\n    body?: any,\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    let /** @type {?} */ req: HttpRequest<any>;\n    // Firstly, check whether the primary argument is an instance of `HttpRequest`.\n    if (first instanceof HttpRequest) {\n      // It is. The other arguments must be undefined (per the signatures) and can be\n      // ignored.\n      req = /** @type {?} */(( first as HttpRequest<any>));\n    } else {\n      // It's a string, so it represents a URL. Construct a request based on it,\n      // and incorporate the remaining arguments (assuming GET unless a method is\n      // provided.\n      req = new HttpRequest(first, /** @type {?} */(( url)), options.body || null, {\n        headers: options.headers,\n        params: options.params,\n        reportProgress: options.reportProgress,\n        // By default, JSON is assumed to be returned for all calls.\n        responseType: options.responseType || 'json',\n        withCredentials: options.withCredentials,\n      });\n    }\n\n    // Start with an Observable.of() the initial request, and run the handler (which\n    // includes all interceptors) inside a concatMap(). This way, the handler runs\n    // inside an Observable chain, which causes interceptors to be re-run on every\n    // subscription (this also makes retries re-run the handler, including interceptors).\n    const /** @type {?} */ events$: Observable<HttpEvent<any>> =\n        concatMap.call(of (req), (req: HttpRequest<any>) => this.handler.handle(req));\n\n    // If coming via the API signature which accepts a previously constructed HttpRequest,\n    // the only option is to get the event stream. Otherwise, return the event stream if\n    // that is what was requested.\n    if (first instanceof HttpRequest || options.observe === 'events') {\n      return events$;\n    }\n\n    // The requested stream contains either the full response or the body. In either\n    // case, the first step is to filter the event stream to extract a stream of\n    // responses(s).\n    const /** @type {?} */ res$: Observable<HttpResponse<any>> =\n        filter.call(events$, (event: HttpEvent<any>) => event instanceof HttpResponse);\n\n    // Decide which stream to return.\n    switch (options.observe || 'body') {\n      case 'body':\n        // The requested stream is the body. Map the response stream to the response\n        // body. This could be done more simply, but a misbehaving interceptor might\n        // transform the response body into a different format and ignore the requested\n        // responseType. Guard against this by validating that the response is of the\n        // requested type.\n        switch (req.responseType) {\n          case 'arraybuffer':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is an ArrayBuffer.\n              if (res.body !== null && !(res.body instanceof ArrayBuffer)) {\n                throw new Error('Response is not an ArrayBuffer.');\n              }\n              return res.body;\n            });\n          case 'blob':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a Blob.\n              if (res.body !== null && !(res.body instanceof Blob)) {\n                throw new Error('Response is not a Blob.');\n              }\n              return res.body;\n            });\n          case 'text':\n            return map.call(res$, (res: HttpResponse<any>) => {\n              // Validate that the body is a string.\n              if (res.body !== null && typeof res.body !== 'string') {\n                throw new Error('Response is not a string.');\n              }\n              return res.body;\n            });\n          case 'json':\n          default:\n            // No validation needed for JSON responses, as they can be of any type.\n            return map.call(res$, (res: HttpResponse<any>) => res.body);\n        }\n      case 'response':\n        // The response stream was requested directly, so return it.\n        return res$;\n      default:\n        // Guard against new future observe types being added.\n        throw new Error(`Unreachable: unhandled observe type ${options.observe}}`);\n    }\n  }\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  delete (url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  delete<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  delete (url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a DELETE request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  delete<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * DELETE request to be executed on the server. See the individual overloads for\n * details of `delete()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\ndelete (url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('DELETE', url, /** @type {?} */(( options as any)));\n  }\n\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a GET request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a GET request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  get(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  get<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  get(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a GET request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  get<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * GET request to be executed on the server. See the individual overloads for\n * details of `get()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\nget(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('GET', url, /** @type {?} */(( options as any)));\n  }\n\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n\n    /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  }): Observable<ArrayBuffer>;\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a GET request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  head(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  head<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  head(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a HEAD request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  head<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * HEAD request to be executed on the server. See the individual overloads for\n * details of `head()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\nhead(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('HEAD', url, /** @type {?} */(( options as any)));\n  }\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as an `Object`\n   */\n  jsonp(url: string, callbackParam: string): Observable<Object>;\n\n  /**\n   * Construct a JSONP request for the given URL and name of the callback parameter.\n   *\n   * @return an `Observable` of the response object as type `T`.\n   */\n  jsonp<T>(url: string, callbackParam: string): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause a request\n * with the special method `JSONP` to be dispatched via the interceptor pipeline.\n * \n * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).\n * If no such interceptor is reached, then the `JSONP` request will likely be\n * rejected by the configured backend.\n * @template T\n * @param {?} url\n * @param {?} callbackParam\n * @return {?}\n */\njsonp<T>(url: string, callbackParam: string): Observable<T> {\n    return this.request<any>('JSONP', url, {\n      params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),\n      observe: 'body',\n      responseType: 'json',\n    });\n  }\n\n  /**\n   * Make an OPTIONS request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a OPTIONS request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  options(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  options<T>(url: string, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  options(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct an OPTIONS request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  options<T>(url: string, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * OPTIONS request to be executed on the server. See the individual overloads for\n * details of `options()`'s return type based on the provided options.\n * @param {?} url\n * @param {?=} options\n * @return {?}\n */\noptions(url: string, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('OPTIONS', url, /** @type {?} */(( options as any)));\n  }\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  patch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  patch<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  patch(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PATCH request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  patch<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * PATCH request to be executed on the server. See the individual overloads for\n * details of `patch()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\npatch(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PATCH', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PATCH request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a POST request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a POST request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  post(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  post<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  post(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a POST request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  post<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * POST request to be executed on the server. See the individual overloads for\n * details of `post()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\npost(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('POST', url, addBody(options, body));\n  }\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns it.\n   *\n   * @return an `Observable` of the body as an `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<ArrayBuffer>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns it.\n   *\n   * @return an `Observable` of the body as a `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<Blob>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns it.\n   *\n   * @return an `Observable` of the body as a `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<string>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpEvent<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpEvent<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpEvent<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpEvent<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full event stream.\n   *\n   * @return an `Observable` of all `HttpEvent`s for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'events', responseType?: 'json', withCredentials?: boolean,\n  }): Observable<HttpEvent<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as an `ArrayBuffer` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `ArrayBuffer`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'arraybuffer', withCredentials?: boolean,\n  }): Observable<HttpResponse<ArrayBuffer>>;\n\n  /**\n   * Construct a PUT request which interprets the body as a `Blob` and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Blob`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'blob', withCredentials?: boolean,\n  }): Observable<HttpResponse<Blob>>;\n\n  /**\n   * Construct a PUT request which interprets the body as text and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `string`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response', params?: HttpParams, reportProgress?: boolean,\n    responseType: 'text', withCredentials?: boolean,\n  }): Observable<HttpResponse<string>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `Object`.\n   */\n  put(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<Object>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns the full response.\n   *\n   * @return an `Observable` of the `HttpResponse` for the request, with a body type of `T`.\n   */\n  put<T>(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe: 'response',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<HttpResponse<T>>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as an `Object`.\n   */\n  put(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<Object>;\n\n  /**\n   * Construct a PUT request which interprets the body as JSON and returns it.\n   *\n   * @return an `Observable` of the body as type `T`.\n   */\n  put<T>(url: string, body: any|null, options?: {\n    headers?: HttpHeaders,\n    observe?: 'body',\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'json',\n    withCredentials?: boolean,\n  }): Observable<T>;\n/**\n * Constructs an `Observable` which, when subscribed, will cause the configured\n * POST request to be executed on the server. See the individual overloads for\n * details of `post()`'s return type based on the provided options.\n * @param {?} url\n * @param {?} body\n * @param {?=} options\n * @return {?}\n */\nput(url: string, body: any|null, options: {\n    headers?: HttpHeaders,\n    observe?: HttpObserve,\n    params?: HttpParams,\n    reportProgress?: boolean,\n    responseType?: 'arraybuffer'|'blob'|'json'|'text',\n    withCredentials?: boolean,\n  } = {}): Observable<any> {\n    return this.request<any>('PUT', url, addBody(options, body));\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: HttpHandler, },\n];\n}\n\nfunction HttpClient_tsickle_Closure_declarations() {\n/** @type {?} */\nHttpClient.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nHttpClient.ctorParameters;\n/** @type {?} */\nHttpClient.prototype.handler;\n}\n\n"]}