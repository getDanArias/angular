{"version":3,"sources":["../../../../../../packages/upgrade/static/src/static/upgrade_module.ts"],"names":[],"mappings":"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","file":"upgrade_module.js","sourceRoot":"","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, NgModule, NgZone, Testability} from '@angular/core';\n\nimport * as angular from '../common/angular1';\nimport {$$TESTABILITY, $DELEGATE, $INJECTOR, $INTERVAL, $PROVIDE, INJECTOR_KEY, LAZY_MODULE_REF, UPGRADE_MODULE_NAME} from '../common/constants';\nimport {controllerKey} from '../common/util';\n\nimport {angular1Providers, setTempInjectorRef} from './angular1_providers';\nimport {NgAdapterInjector} from './util';\n\n\n/**\n * @whatItDoes\n *\n * *Part of the [upgrade/static](api?query=upgrade%2Fstatic)\n * library for hybrid upgrade apps that support AoT compilation*\n *\n * Allows AngularJS and Angular components to be used together inside a hybrid upgrade\n * application, which supports AoT compilation.\n *\n * Specifically, the classes and functions in the `upgrade/static` module allow the following:\n * 1. Creation of an Angular directive that wraps and exposes an AngularJS component so\n *    that it can be used in an Angular template. See {@link UpgradeComponent}.\n * 2. Creation of an AngularJS directive that wraps and exposes an Angular component so\n *    that it can be used in an AngularJS template. See {@link downgradeComponent}.\n * 3. Creation of an Angular root injector provider that wraps and exposes an AngularJS\n *    service so that it can be injected into an Angular context. See\n *    {@link UpgradeModule#upgrading-an-angular-1-service Upgrading an AngularJS service} below.\n * 4. Creation of an AngularJS service that wraps and exposes an Angular injectable\n *    so that it can be injected into an AngularJS context. See {@link downgradeInjectable}.\n * 3. Bootstrapping of a hybrid Angular application which contains both of the frameworks\n *    coexisting in a single application. See the\n *    {@link UpgradeModule#example example} below.\n *\n * ## Mental Model\n *\n * When reasoning about how a hybrid application works it is useful to have a mental model which\n * describes what is happening and explains what is happening at the lowest level.\n *\n * 1. There are two independent frameworks running in a single application, each framework treats\n *    the other as a black box.\n * 2. Each DOM element on the page is owned exactly by one framework. Whichever framework\n *    instantiated the element is the owner. Each framework only updates/interacts with its own\n *    DOM elements and ignores others.\n * 3. AngularJS directives always execute inside the AngularJS framework codebase regardless of\n *    where they are instantiated.\n * 4. Angular components always execute inside the Angular framework codebase regardless of\n *    where they are instantiated.\n * 5. An AngularJS component can be \"upgraded\"\" to an Angular component. This is achieved by\n *    defining an Angular directive, which bootstraps the AngularJS component at its location\n *    in the DOM. See {@link UpgradeComponent}.\n * 6. An Angular component can be \"downgraded\"\" to an AngularJS component. This is achieved by\n *    defining an AngularJS directive, which bootstraps the Angular component at its location\n *    in the DOM. See {@link downgradeComponent}.\n * 7. Whenever an \"upgraded\"/\"downgraded\" component is instantiated the host element is owned by\n *    the framework doing the instantiation. The other framework then instantiates and owns the\n *    view for that component.\n *    a. This implies that the component bindings will always follow the semantics of the\n *       instantiation framework.\n *    b. The DOM attributes are parsed by the framework that owns the current template. So\n * attributes\n *       in AngularJS templates must use kebab-case, while AngularJS templates must use camelCase.\n *    c. However the template binding syntax will always use the Angular style, e.g. square\n *       brackets (`[...]`) for property binding.\n * 8. AngularJS is always bootstrapped first and owns the root component.\n * 9. The new application is running in an Angular zone, and therefore it no longer needs calls\n * to\n *    `$apply()`.\n *\n * @howToUse\n *\n * `import {UpgradeModule} from '@angular/upgrade/static';`\n *\n * ## Example\n * Import the {@link UpgradeModule} into your top level {@link NgModule Angular `NgModule`}.\n *\n * {@example upgrade/static/ts/module.ts region='ng2-module'}\n *\n * Then bootstrap the hybrid upgrade app's module, get hold of the {@link UpgradeModule} instance\n * and use it to bootstrap the top level [AngularJS\n * module](https://docs.angularjs.org/api/ng/type/angular.Module).\n *\n * {@example upgrade/static/ts/module.ts region='bootstrap'}\n *\n * {@a upgrading-an-angular-1-service}\n *\n * ## Upgrading an AngularJS service\n *\n * There is no specific API for upgrading an AngularJS service. Instead you should just follow the\n * following recipe:\n *\n * Let's say you have an AngularJS service:\n *\n * {@example upgrade/static/ts/module.ts region=\"ng1-title-case-service\"}\n *\n * Then you should define an Angular provider to be included in your {@link NgModule} `providers`\n * property.\n *\n * {@example upgrade/static/ts/module.ts region=\"upgrade-ng1-service\"}\n *\n * Then you can use the \"upgraded\" AngularJS service by injecting it into an Angular component\n * or service.\n *\n * {@example upgrade/static/ts/module.ts region=\"use-ng1-upgraded-service\"}\n *\n * @description\n *\n * This class is an `NgModule`, which you import to provide AngularJS core services,\n * and has an instance method used to bootstrap the hybrid upgrade application.\n *\n * ## Core AngularJS services\n * Importing this {@link NgModule} will add providers for the core\n * [AngularJS services](https://docs.angularjs.org/api/ng/service) to the root injector.\n *\n * ## Bootstrap\n * The runtime instance of this class contains a {@link UpgradeModule#bootstrap `bootstrap()`}\n * method, which you use to bootstrap the top level AngularJS module onto an element in the\n * DOM for the hybrid upgrade app.\n *\n * It also contains properties to access the {@link UpgradeModule#injector root injector}, the\n * bootstrap {@link NgZone} and the\n * [AngularJS $injector](https://docs.angularjs.org/api/auto/service/$injector).\n *\n * @experimental\n */\n\nexport class UpgradeModule {\n  /**\n   * The AngularJS `$injector` for the upgrade application.\n   */\n  public $injector: any /*angular.IInjectorService*/;\n  /** The Angular Injector **/\n  public injector: Injector;\n\n  constructor(\n      /** The root {@link Injector} for the upgrade application. */\n      injector: Injector,\n      /** The bootstrap zone for the upgrade application */\n      public ngZone: NgZone) {\n    this.injector = new NgAdapterInjector(injector);\n  }\n\n  /**\n   * Bootstrap an AngularJS application from this NgModule\n   * @param element the element on which to bootstrap the AngularJS application\n   * @param [modules] the AngularJS modules to bootstrap for this application\n   * @param [config] optional extra AngularJS bootstrap configuration\n   */\n  bootstrap(\n      element: Element, modules: string[] = [], config?: any /*angular.IAngularBootstrapConfig*/) {\n    const INIT_MODULE_NAME = UPGRADE_MODULE_NAME + '.init';\n\n    // Create an ng1 module to bootstrap\n    const initModule =\n        angular\n            .module(INIT_MODULE_NAME, [])\n\n            .value(INJECTOR_KEY, this.injector)\n\n            .factory(\n                LAZY_MODULE_REF,\n                [INJECTOR_KEY, (injector: Injector) => ({injector, needsNgZone: false})])\n\n            .config([\n              $PROVIDE, $INJECTOR,\n              ($provide: angular.IProvideService, $injector: angular.IInjectorService) => {\n                if ($injector.has($$TESTABILITY)) {\n                  $provide.decorator($$TESTABILITY, [\n                    $DELEGATE,\n                    (testabilityDelegate: angular.ITestabilityService) => {\n                      const originalWhenStable: Function = testabilityDelegate.whenStable;\n                      const injector = this.injector;\n                      // Cannot use arrow function below because we need the context\n                      const newWhenStable = function(callback: Function) {\n                        originalWhenStable.call(testabilityDelegate, function() {\n                          const ng2Testability: Testability = injector.get(Testability);\n                          if (ng2Testability.isStable()) {\n                            callback();\n                          } else {\n                            ng2Testability.whenStable(\n                                newWhenStable.bind(testabilityDelegate, callback));\n                          }\n                        });\n                      };\n\n                      testabilityDelegate.whenStable = newWhenStable;\n                      return testabilityDelegate;\n                    }\n                  ]);\n                }\n\n                if ($injector.has($INTERVAL)) {\n                  $provide.decorator($INTERVAL, [\n                    $DELEGATE,\n                    (intervalDelegate: angular.IIntervalService) => {\n                      // Wrap the $interval service so that setInterval is called outside NgZone,\n                      // but the callback is still invoked within it. This is so that $interval\n                      // won't block stability, which preserves the behavior from AngularJS.\n                      let wrappedInterval =\n                          (fn: Function, delay: number, count?: number, invokeApply?: boolean,\n                           ...pass: any[]) => {\n                            return this.ngZone.runOutsideAngular(() => {\n                              return intervalDelegate((...args: any[]) => {\n                                // Run callback in the next VM turn - $interval calls\n                                // $rootScope.$apply, and running the callback in NgZone will\n                                // cause a '$digest already in progress' error if it's in the\n                                // same vm turn.\n                                setTimeout(() => { this.ngZone.run(() => fn(...args)); });\n                              }, delay, count, invokeApply, ...pass);\n                            });\n                          };\n\n                      (wrappedInterval as any)['cancel'] = intervalDelegate.cancel;\n                      return wrappedInterval;\n                    }\n                  ]);\n                }\n              }\n            ])\n\n            .run([\n              $INJECTOR,\n              ($injector: angular.IInjectorService) => {\n                this.$injector = $injector;\n\n                // Initialize the ng1 $injector provider\n                setTempInjectorRef($injector);\n                this.injector.get($INJECTOR);\n\n                // Put the injector on the DOM, so that it can be \"required\"\n                angular.element(element).data !(controllerKey(INJECTOR_KEY), this.injector);\n\n                // Wire up the ng1 rootScope to run a digest cycle whenever the zone settles\n                // We need to do this in the next tick so that we don't prevent the bootup\n                // stabilizing\n                setTimeout(() => {\n                  const $rootScope = $injector.get('$rootScope');\n                  const subscription =\n                      this.ngZone.onMicrotaskEmpty.subscribe(() => $rootScope.$digest());\n                  $rootScope.$on('$destroy', () => { subscription.unsubscribe(); });\n                }, 0);\n              }\n            ]);\n\n    const upgradeModule = angular.module(UPGRADE_MODULE_NAME, [INIT_MODULE_NAME].concat(modules));\n\n    // Make sure resumeBootstrap() only exists if the current bootstrap is deferred\n    const windowAngular = (window as any)['angular'];\n    windowAngular.resumeBootstrap = undefined;\n\n    // Bootstrap the AngularJS application inside our zone\n    this.ngZone.run(() => { angular.bootstrap(element, [upgradeModule.name], config); });\n\n    // Patch resumeBootstrap() to run inside the ngZone\n    if (windowAngular.resumeBootstrap) {\n      const originalResumeBootstrap: () => void = windowAngular.resumeBootstrap;\n      const ngZone = this.ngZone;\n      windowAngular.resumeBootstrap = function() {\n        let args = arguments;\n        windowAngular.resumeBootstrap = originalResumeBootstrap;\n        ngZone.run(() => { windowAngular.resumeBootstrap.apply(this, args); });\n      };\n    }\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: NgModule, args: [{providers: [angular1Providers]}, ] },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: Injector, },\n{type: NgZone, },\n];\n}\n"]}