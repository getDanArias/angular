{"version":3,"sources":["../../../../../packages/core/src/zone/ng_zone.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAaH,OALO,EAAA,YAAE,EAAY,MAAA,kBAAA,CAAA;AAMrB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAuEG;AACH,MAJC;IA+BD;;OAEG;IACH,YADG,EAAY,oBAAC,GAAsB,KAAA,EAAM;QAhCjC,yBAAA,GAAgC,KAAA,CAAM;QACtC,yBAAA,GAAgC,KAAA,CAAM;QAKjD;;WAEG;QAFQ,aAAA,GAAoB,IAAA,CAAK;QAIpC;;WAEG;QADQ,eAAA,GAAgC,IAAI,YAAA,CAAa,KAAC,CAAK,CAAC;QAGnE;;;;WAIG;QAAQ,qBAAA,GAAsC,IAAI,YAAA,CAAa,KAAC,CAAK,CAAC;QAEzE;;;;WAIG;QACQ,aAAA,GAA8B,IAAI,YAAA,CAAa,KAAC,CAAK,CAAC;QACjE;;WAEG;QAEQ,YAAA,GAA6B,IAAI,YAAA,CAAa,KAAC,CAAK,CAAC;QAI5D,EAAE,CAAC,CAAC,OADO,IAAA,IAAQ,WAAA,CAAY,CAAC,CAAA;YAE9B,MADM,IAAI,KAAA,CAAM,qCAAC,CAAqC,CAAC;QAEzD,CAAC;QAED,IAAI,CADC,iBAAC,EAAiB,CAAE;QAEzB,MAAM,gBAAgB,CADhB,IAAA,GAAK,CAAA,CAAE,IAAQ,CAAO,CAAA,CAAc;QAE1C,IAAI,CADC,QAAC,GAAU,CAAA,CAAE;QAGlB,IAAI,CADC,MAAC,GAAQ,IAAA,CAAK,MAAC,GAAQ,IAAA,CAAK,OAAC,CAAO;QAGzC,EAAE,CAAC,CAAC,CADC,CAAA,IAAQ,CAAA,CAAI,CAAC,aAAC,CAAa,CAAC,CAAC,CAAA;YAEhC,IAAI,CADC,MAAC,GAAQ,IAAA,CAAK,MAAC,CAAM,IAAC,CAAI,CAAC,CAAA,IAAQ,CAAA,CAAI,CAAC,aAAC,CAAa,CAAC,CAAC;QAE/D,CAAC;QAED,EAAE,CAAC,CAAC,oBADC,IAAuB,CAAA,CAAA,IAAS,CAAA,CAAI,CAAC,wBAAC,CAAwB,CAAC,CAAC,CAAA;YAEnE,IAAI,CADC,MAAC,GAAQ,IAAA,CAAK,MAAC,CAAM,IAAC,CAAI,CAAC,CAAA,IAAQ,CAAA,CAAI,CAAC,wBAAC,CAAwB,CAAC,CAAC;QAE1E,CAAC;QAED,gCAAgC,CADC,IAAC,CAAI,CAAC;IAEzC,CAAC;IACH;;OAEG;IACH,MAHG,CAAM,eAAA,KAA6B,MAAA,CAAO,IAAA,CAAK,OAAC,CAAO,GAAC,CAAG,eAAC,CAAe,KAAK,IAAA,CAAK,CAAC,CAAA;IAIzF;;OAEG;IACH,MALG,CAAM,mBAAA;QAML,EAAE,CAAC,CAAC,CALC,MAAC,CAAM,eAAC,EAAe,CAAE,CAAC,CAAA;YAM7B,MALM,IAAI,KAAA,CAAM,gDAAC,CAAgD,CAAC;QAMpE,CAAC;IACH,CAAC;IACH;;OAEG;IACH,MAPG,CAAM,sBAAA;QAQL,EAAE,CAAC,CAAC,MAPC,CAAM,eAAC,EAAe,CAAE,CAAC,CAAA;YAQ5B,MAPM,IAAI,KAAA,CAAM,gDAAC,CAAgD,CAAC;QAQpE,CAAC;IACH,CAAC;IACH;;;;;;;;;;;;;;;;OAgBG;IACH,GAXG,CAAK,EAAyB,EAAG,SAAY,EAAK,SAAgB;QAYjE,MAAM,CAAiB,CAXhB,CAAA,CAAA,CAAA,IAAS,CAAO,CAAA,CAAc,CAAC,MAAC,CAAM,GAAC,CAAG,EAAC,EAAG,SAAA,EAAW,SAAA,CAAc,CAAA,CAAE;IAYlF,CAAC;IACH;;;;;;;;;;;;;;;;;OAiBG;IACH,OAhBG,CAAS,EAAyB,EAAG,SAAY,EAAK,SAAgB,EAAG,IAAO;QAiB/E,MAAM,gBAAgB,CAhBhB,IAAA,GAAO,CAAA,CAAA,CAAA,IAAS,CAAO,CAAA,CAAc,CAAC,MAAC,CAAM;QAiBnD,MAAM,gBAAgB,CAhBhB,IAAA,GAAO,IAAA,CAAK,iBAAC,CAAiB,eAAC,GAAiB,IAAA,EAAM,EAAA,EAAI,aAAA,EAAe,IAAA,EAAM,IAAA,CAAK,CAAC;QAiB3F,IAhBI,CAAA;YAiBF,MAAM,CAAiB,CAhBhB,IAAA,CAAK,OAAC,CAAO,IAAC,EAAK,SAAA,EAAW,SAAA,CAAc,CAAA,CAAE;QAiBvD,CAAC;gBAhBS,CAAA;YAiBR,IAAI,CAhBC,UAAC,CAAU,IAAC,CAAI,CAAC;QAiBxB,CAAC;IACH,CAAC;IACH;;;;;;;;OAQG;IACH,UApBG,CAAY,EAAyB,EAAG,SAAY,EAAK,SAAgB;QAqBxE,MAAM,CAAiB,CApBhB,CAAA,CAAA,CAAA,IAAS,CAAO,CAAA,CAAc,CAAC,MAAC,CAAM,UAAC,CAAU,EAAC,EAAG,SAAA,EAAW,SAAA,CAAc,CAAA,CAAE;IAqBzF,CAAC;IACH;;;;;;;;;;;;;;;OAeG;IACH,iBAtBG,CAAmB,EAAyB;QAuB3C,MAAM,CAAiB,CAtBhB,CAAA,CAAA,CAAA,IAAS,CAAO,CAAA,CAAc,CAAC,MAAC,CAAM,GAAC,CAAG,EAAC,CAAM,CAAA,CAAE;IAuB5D,CAAC;CArBF;AAwBD;IACA,gBAAgB;IAChB,MAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC;IACtC,gBAAgB;IAChB,MAAM,CAAC,SAAS,CAAC,oBAAoB,CAAC;IACtC;;;OAGG;IACH,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;IAC1B;;;OAGG;IACH,MAAM,CAAC,SAAS,CAAC,UAAU,CAAC;IAC5B;;;;;OAKG;IACH,MAAM,CAAC,SAAS,CAAC,gBAAgB,CAAC;IAClC;;;;;OAKG;IACH,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC;IAC1B;;;OAGG;IACH,MAAM,CAAC,SAAS,CAAC,OAAO,CAAC;AACzB,CAAC;AAED;;GAEG;AACH,kBA7DgB,CAAA;AAAA,CAAE;AA8DlB,MAAM,gBAAgB,CA7DhB,aAAA,GAAgB,EAAA,CAAG;AA8DzB;;GAEG;AACH,2BAA0B,CAAC;AAG3B;IACA,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,MAAM,CAAC;IAC/B,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC;IACjC,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,oBAAoB,CAAC;IAC7C,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,oBAAoB,CAAC;IAC7C,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,QAAQ,CAAC;AACjC,CAAC;AAaD;;;GAGG;AACH,qBArFqB,IAAM;IAsFzB,EAAE,CAAC,CAAC,IArFC,CAAI,QAAC,IAAW,CAAA,IAAK,CAAA,IAAE,CAAI,oBAAC,IAAuB,CAAA,IAAE,CAAI,QAAC,CAAQ,CAAC,CAAA;QAsFtE,IArFI,CAAA;YAsFF,IAAI,CArFC,QAAC,EAAQ,CAAE;YAsFhB,IAAI,CArFC,gBAAC,CAAgB,IAAC,CAAI,IAAC,CAAI,CAAC;QAsFnC,CAAC;gBArFS,CAAA;YAsFR,IAAI,CArFC,QAAC,EAAQ,CAAE;YAsFhB,EAAE,CAAC,CAAC,CArFC,IAAC,CAAI,oBAAC,CAAoB,CAAC,CAAA;gBAsF9B,IArFI,CAAA;oBAsFF,IAAI,CArFC,iBAAC,CAAiB,MAAM,IAAA,CAAK,QAAC,CAAQ,IAAC,CAAI,IAAC,CAAI,CAAC,CAAC;gBAsFzD,CAAC;wBArFS,CAAA;oBAsFR,IAAI,CArFC,QAAC,GAAU,IAAA,CAAK;gBAsFvB,CAAC;YACH,CAAC;QACH,CAAC;IACH,CAAC;AACH,CAAC;AACD;;;GAGG;AACH,0CAxF0C,IAAM;IAyF9C,IAAI,CAxFC,MAAC,GAAQ,IAAA,CAAK,MAAC,CAAM,IAAC,CAAI;QAyF7B,IAAI,EAxFE,SAAA;QAyFN,UAAU,EAxFC,gBAAA,CAAA,CAAM,EAAC,eAAC,EAAgB,IAAA,EAAK,CAAA;QAyFxC,YAAY,EAxFE,CAAA,QAAW,EAAc,OAAS,EAAM,MAAQ,EAAM,IAAM,EAAM,SAAW,EAyF5E,SAxFW;YAyFxB,IAxFI,CAAA;gBAyFF,OAAO,CAxFC,IAAC,CAAI,CAAC;gBAyFd,MAAM,CAxFC,QAAA,CAAS,UAAC,CAAU,MAAC,EAAO,IAAA,EAAM,SAAA,EAAW,SAAA,CAAU,CAAC;YAyFjE,CAAC;oBAxFS,CAAA;gBAyFR,OAAO,CAxFC,IAAC,CAAI,CAAC;YAyFhB,CAAC;QACH,CAAC;QAGD,QAAQ,EAxFE,CAAA,QAAW,EAAc,OAAS,EAAM,MAAQ,EAAM,QAAU,EAyF/D,SAxFW,EAAK,SAAe,EAAG,MAAQ;YAyFnD,IAxFI,CAAA;gBAyFF,OAAO,CAxFC,IAAC,CAAI,CAAC;gBAyFd,MAAM,CAxFC,QAAA,CAAS,MAAC,CAAM,MAAC,EAAO,QAAA,EAAU,SAAA,EAAW,SAAA,EAAW,MAAA,CAAO,CAAC;YAyFzE,CAAC;oBAxFS,CAAA;gBAyFR,OAAO,CAxFC,IAAC,CAAI,CAAC;YAyFhB,CAAC;QACH,CAAC;QAED,SAAS,EACL,CAAC,QAxFU,EAAc,OAAS,EAAM,MAAQ,EAAM,YAAc;YAyFlE,QAAQ,CAxFC,OAAC,CAAO,MAAC,EAAO,YAAA,CAAa,CAAC;YAyFvC,EAAE,CAAC,CAAC,OAxFC,KAAW,MAAA,CAAO,CAAC,CAAA;gBAyFtB,yEAAyE;gBACzE,mDAAmD;gBACnD,EAAE,CAAC,CAAC,YAxFC,CAAY,MAAC,IAAS,WAAA,CAAY,CAAC,CAAA;oBAyFtC,IAAI,CAxFC,oBAAC,GAAsB,YAAA,CAAa,SAAC,CAAS;oBAyFnD,WAAW,CAxFC,IAAC,CAAI,CAAC;gBAyFpB,CAAC;gBAxFC,IAAA,CAAK,EAAA,CAAA,CAAA,YAAK,CAAY,MAAC,IAAS,WAAA,CAAY,CAAC,CAAA;oBAyF7C,IAAI,CAxFC,oBAAC,GAAsB,YAAA,CAAa,SAAC,CAAS;gBAyFrD,CAAC;YACH,CAAC;QACH,CAAC;QAEL,aAAa,EAxFE,CAAA,QAAW,EAAc,OAAS,EAAM,MAAQ,EAAM,KAAO;YAyF1E,QAAQ,CAxFC,WAAC,CAAW,MAAC,EAAO,KAAA,CAAM,CAAC;YAyFpC,IAAI,CAxFC,iBAAC,CAAiB,MAAM,IAAA,CAAK,OAAC,CAAO,IAAC,CAAI,KAAC,CAAK,CAAC,CAAC;YAyFvD,MAAM,CAxFC,KAAA,CAAM;QAyFf,CAAC;KACF,CAxFC,CAAC;AAyFL,CAAC;AACD;;;GAGG;AACH,iBA3FiB,IAAM;IA4FrB,IAAI,CA3FC,QAAC,EAAQ,CAAE;IA4FhB,EAAE,CAAC,CAAC,IA3FC,CAAI,QAAC,CAAQ,CAAC,CAAA;QA4FjB,IAAI,CA3FC,QAAC,GAAU,KAAA,CAAM;QA4FtB,IAAI,CA3FC,UAAC,CAAU,IAAC,CAAI,IAAC,CAAI,CAAC;IA4F7B,CAAC;AACH,CAAC;AACD;;;GAGG;AACH,iBA9FiB,IAAM;IA+FrB,IAAI,CA9FC,QAAC,EAAQ,CAAE;IA+FhB,WAAW,CA9FC,IAAC,CAAI,CAAC;AA+FpB,CAAC","file":"ng_zone.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n// Import zero symbols from zone.js. This causes the zone ambient type to be\n// added to the type-checker, without emitting any runtime module load statement\nimport {} from 'zone.js';\nimport {EventEmitter} from '../event_emitter';\n/**\n * An injectable service for executing work inside or outside of the Angular zone.\n * \n * The most common use of this service is to optimize performance when starting a work consisting of\n * one or more asynchronous tasks that don't require UI updates or error handling to be handled by\n * Angular. Such tasks can be kicked off via {\\@link #runOutsideAngular} and if needed, these tasks\n * can reenter the Angular zone via {\\@link #run}.\n * \n * <!-- TODO: add/fix links to:\n *   - docs explaining zones and the use of zones in Angular and change-detection\n *   - link to runOutsideAngular/run (throughout this file!)\n *   -->\n * \n * ### Example\n * \n * ```\n * import {Component, NgZone} from '\\@angular/core';\n * import {NgIf} from '\\@angular/common';\n * \n * \\@Component({ \n *   selector: 'ng-zone-demo'.\n *   template: `\n *     <h2>Demo: NgZone</h2>\n * \n *     <p>Progress: {{progress}}%</p>\n *     <p *ngIf=\"progress >= 100\">Done processing {{label}} of Angular zone!</p>\n * \n *     <button (click)=\"processWithinAngularZone()\">Process within Angular zone</button>\n *     <button (click)=\"processOutsideOfAngularZone()\">Process outside of Angular zone</button>\n *   `,\n * })\n * export class NgZoneDemo {\n *   progress: number = 0;\n *   label: string;\n * \n *   constructor(private _ngZone: NgZone) {}\n * \n *   // Loop inside the Angular zone\n *   // so the UI DOES refresh after each setTimeout cycle\n *   processWithinAngularZone() {\n *     this.label = 'inside';\n *     this.progress = 0;\n *     this._increaseProgress(() => console.log('Inside Done!'));\n *   }\n * \n *   // Loop outside of the Angular zone\n *   // so the UI DOES NOT refresh after each setTimeout cycle\n *   processOutsideOfAngularZone() {\n *     this.label = 'outside';\n *     this.progress = 0;\n *     this._ngZone.runOutsideAngular(() => {\n *       this._increaseProgress(() => {\n *       // reenter the Angular zone and display done\n *       this._ngZone.run(() => {console.log('Outside Done!') });\n *     }}));\n *   }\n * \n *   _increaseProgress(doneCallback: () => void) {\n *     this.progress += 1;\n *     console.log(`Current progress: ${this.progress}%`);\n * \n *     if (this.progress < 100) {\n *       window.setTimeout(() => this._increaseProgress(doneCallback)), 10)\n *     } else {\n *       doneCallback();\n *     }\n *   }\n * }\n * ```\n * \n * \\@experimental\n */\nexport class NgZone {\n  readonly hasPendingMicrotasks: boolean = false;\n  readonly hasPendingMacrotasks: boolean = false;\n/**\n * Whether there are no outstanding microtasks or macrotasks.\n */\nreadonly isStable: boolean = true;\n/**\n * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n */\nreadonly onUnstable: EventEmitter<any> = new EventEmitter(false);\n/**\n * Notifies when there is no more microtasks enqueue in the current VM Turn.\n * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n * For this reason this event can fire multiple times per VM Turn.\n */\nreadonly onMicrotaskEmpty: EventEmitter<any> = new EventEmitter(false);\n/**\n * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n * implies we are about to relinquish VM turn.\n * This event gets called just once.\n */\nreadonly onStable: EventEmitter<any> = new EventEmitter(false);\n/**\n * Notifies that an error has been delivered.\n */\nreadonly onError: EventEmitter<any> = new EventEmitter(false);\n/**\n * @param {?} __0\n */\nconstructor({enableLongStackTrace = false}) {\n    if (typeof Zone == 'undefined') {\n      throw new Error('Angular requires Zone.js prolyfill.');\n    }\n\n    Zone.assertZonePatched();\n    const /** @type {?} */ self = /** @type {?} */(( /** @type {?} */(( this as any)) as NgZonePrivate));\n    self._nesting = 0;\n\n    self._outer = self._inner = Zone.current;\n\n    if (( /** @type {?} */((Zone as any)))['wtfZoneSpec']) {\n      self._inner = self._inner.fork(( /** @type {?} */((Zone as any)))['wtfZoneSpec']);\n    }\n\n    if (enableLongStackTrace && ( /** @type {?} */((Zone as any)))['longStackTraceZoneSpec']) {\n      self._inner = self._inner.fork(( /** @type {?} */((Zone as any)))['longStackTraceZoneSpec']);\n    }\n\n    forkInnerZoneWithAngularBehavior(self);\n  }\n/**\n * @return {?}\n */\nstatic isInAngularZone(): boolean { return Zone.current.get('isAngularZone') === true; }\n/**\n * @return {?}\n */\nstatic assertInAngularZone(): void {\n    if (!NgZone.isInAngularZone()) {\n      throw new Error('Expected to be in Angular Zone, but it is not!');\n    }\n  }\n/**\n * @return {?}\n */\nstatic assertNotInAngularZone(): void {\n    if (NgZone.isInAngularZone()) {\n      throw new Error('Expected to not be in Angular Zone, but it is!');\n    }\n  }\n/**\n * Executes the `fn` function synchronously within the Angular zone and returns value returned by\n * the function.\n * \n * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n * outside of the Angular zone (typically started via {\\@link #runOutsideAngular}).\n * \n * Any future tasks or microtasks scheduled from within this function will continue executing from\n * within the Angular zone.\n * \n * If a synchronous error happens it will be rethrown and not reported via `onError`.\n * @template T\n * @param {?} fn\n * @param {?=} applyThis\n * @param {?=} applyArgs\n * @return {?}\n */\nrun<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return /** @type {?} */(( ( /** @type {?} */(( /** @type {?} */((this as any)) as NgZonePrivate)))._inner.run(fn, applyThis, applyArgs) as T));\n  }\n/**\n * Executes the `fn` function synchronously within the Angular zone as a task and returns value\n * returned by the function.\n * \n * Running functions via `run` allows you to reenter Angular zone from a task that was executed\n * outside of the Angular zone (typically started via {\\@link #runOutsideAngular}).\n * \n * Any future tasks or microtasks scheduled from within this function will continue executing from\n * within the Angular zone.\n * \n * If a synchronous error happens it will be rethrown and not reported via `onError`.\n * @template T\n * @param {?} fn\n * @param {?=} applyThis\n * @param {?=} applyArgs\n * @param {?=} name\n * @return {?}\n */\nrunTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T {\n    const /** @type {?} */ zone = ( /** @type {?} */(( /** @type {?} */((this as any)) as NgZonePrivate)))._inner;\n    const /** @type {?} */ task = zone.scheduleEventTask('NgZoneEvent: ' + name, fn, EMPTY_PAYLOAD, noop, noop);\n    try {\n      return /** @type {?} */(( zone.runTask(task, applyThis, applyArgs) as T));\n    } finally {\n      zone.cancelTask(task);\n    }\n  }\n/**\n * Same as `run`, except that synchronous errors are caught and forwarded via `onError` and not\n * rethrown.\n * @template T\n * @param {?} fn\n * @param {?=} applyThis\n * @param {?=} applyArgs\n * @return {?}\n */\nrunGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T {\n    return /** @type {?} */(( ( /** @type {?} */(( /** @type {?} */((this as any)) as NgZonePrivate)))._inner.runGuarded(fn, applyThis, applyArgs) as T));\n  }\n/**\n * Executes the `fn` function synchronously in Angular's parent zone and returns value returned by\n * the function.\n * \n * Running functions via {\\@link #runOutsideAngular} allows you to escape Angular's zone and do\n * work that\n * doesn't trigger Angular change-detection or is subject to Angular's error handling.\n * \n * Any future tasks or microtasks scheduled from within this function will continue executing from\n * outside of the Angular zone.\n * \n * Use {\\@link #run} to reenter the Angular zone and do work that updates the application model.\n * @template T\n * @param {?} fn\n * @return {?}\n */\nrunOutsideAngular<T>(fn: (...args: any[]) => T): T {\n    return /** @type {?} */(( ( /** @type {?} */(( /** @type {?} */((this as any)) as NgZonePrivate)))._outer.run(fn) as T));\n  }\n}\n\nfunction NgZone_tsickle_Closure_declarations() {\n/** @type {?} */\nNgZone.prototype.hasPendingMicrotasks;\n/** @type {?} */\nNgZone.prototype.hasPendingMacrotasks;\n/**\n * Whether there are no outstanding microtasks or macrotasks.\n * @type {?}\n */\nNgZone.prototype.isStable;\n/**\n * Notifies when code enters Angular Zone. This gets fired first on VM Turn.\n * @type {?}\n */\nNgZone.prototype.onUnstable;\n/**\n * Notifies when there is no more microtasks enqueue in the current VM Turn.\n * This is a hint for Angular to do change detection, which may enqueue more microtasks.\n * For this reason this event can fire multiple times per VM Turn.\n * @type {?}\n */\nNgZone.prototype.onMicrotaskEmpty;\n/**\n * Notifies when the last `onMicrotaskEmpty` has run and there are no more microtasks, which\n * implies we are about to relinquish VM turn.\n * This event gets called just once.\n * @type {?}\n */\nNgZone.prototype.onStable;\n/**\n * Notifies that an error has been delivered.\n * @type {?}\n */\nNgZone.prototype.onError;\n}\n\n/**\n * @return {?}\n */\nfunction noop(){};\nconst /** @type {?} */ EMPTY_PAYLOAD = {};\n/**\n * @record\n */\nfunction NgZonePrivate() {}\n\n\nfunction NgZonePrivate_tsickle_Closure_declarations() {\n/** @type {?} */\nNgZonePrivate.prototype._outer;\n/** @type {?} */\nNgZonePrivate.prototype._inner;\n/** @type {?} */\nNgZonePrivate.prototype._nesting;\n/** @type {?} */\nNgZonePrivate.prototype.hasPendingMicrotasks;\n/** @type {?} */\nNgZonePrivate.prototype.hasPendingMacrotasks;\n/** @type {?} */\nNgZonePrivate.prototype.isStable;\n}\n\n\n\ninterface NgZonePrivate extends NgZone {\n  _outer: Zone;\n  _inner: Zone;\n  _nesting: number;\n\n  hasPendingMicrotasks: boolean;\n  hasPendingMacrotasks: boolean;\n  isStable: boolean;\n}\n/**\n * @param {?} zone\n * @return {?}\n */\nfunction checkStable(zone: NgZonePrivate) {\n  if (zone._nesting == 0 && !zone.hasPendingMicrotasks && !zone.isStable) {\n    try {\n      zone._nesting++;\n      zone.onMicrotaskEmpty.emit(null);\n    } finally {\n      zone._nesting--;\n      if (!zone.hasPendingMicrotasks) {\n        try {\n          zone.runOutsideAngular(() => zone.onStable.emit(null));\n        } finally {\n          zone.isStable = true;\n        }\n      }\n    }\n  }\n}\n/**\n * @param {?} zone\n * @return {?}\n */\nfunction forkInnerZoneWithAngularBehavior(zone: NgZonePrivate) {\n  zone._inner = zone._inner.fork({\n    name: 'angular',\n    properties: /** @type {?} */(( <any>{'isAngularZone': true})),\n    onInvokeTask: (delegate: ZoneDelegate, current: Zone, target: Zone, task: Task, applyThis: any,\n                   applyArgs: any): any => {\n      try {\n        onEnter(zone);\n        return delegate.invokeTask(target, task, applyThis, applyArgs);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n\n    onInvoke: (delegate: ZoneDelegate, current: Zone, target: Zone, callback: Function,\n               applyThis: any, applyArgs: any[], source: string): any => {\n      try {\n        onEnter(zone);\n        return delegate.invoke(target, callback, applyThis, applyArgs, source);\n      } finally {\n        onLeave(zone);\n      }\n    },\n\n    onHasTask:\n        (delegate: ZoneDelegate, current: Zone, target: Zone, hasTaskState: HasTaskState) => {\n          delegate.hasTask(target, hasTaskState);\n          if (current === target) {\n            // We are only interested in hasTask events which originate from our zone\n            // (A child hasTask event is not interesting to us)\n            if (hasTaskState.change == 'microTask') {\n              zone.hasPendingMicrotasks = hasTaskState.microTask;\n              checkStable(zone);\n            } else if (hasTaskState.change == 'macroTask') {\n              zone.hasPendingMacrotasks = hasTaskState.macroTask;\n            }\n          }\n        },\n\n    onHandleError: (delegate: ZoneDelegate, current: Zone, target: Zone, error: any): boolean => {\n      delegate.handleError(target, error);\n      zone.runOutsideAngular(() => zone.onError.emit(error));\n      return false;\n    }\n  });\n}\n/**\n * @param {?} zone\n * @return {?}\n */\nfunction onEnter(zone: NgZonePrivate) {\n  zone._nesting++;\n  if (zone.isStable) {\n    zone.isStable = false;\n    zone.onUnstable.emit(null);\n  }\n}\n/**\n * @param {?} zone\n * @return {?}\n */\nfunction onLeave(zone: NgZonePrivate) {\n  zone._nesting--;\n  checkStable(zone);\n}\n"]}