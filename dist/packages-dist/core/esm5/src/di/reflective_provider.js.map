{"version":3,"sources":["../../../../../../packages/core/src/di/reflective_provider.ts"],"names":[],"mappings":"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","file":"reflective_provider.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {reflector} from '../reflection/reflection';\nimport {Type} from '../type';\n\nimport {resolveForwardRef} from './forward_ref';\nimport {InjectionToken} from './injection_token';\nimport {Inject, Optional, Self, SkipSelf} from './metadata';\nimport {ClassProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ValueProvider} from './provider';\nimport {invalidProviderError, mixingMultiProvidersWithRegularProvidersError, noAnnotationError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\n/**\n * @record\n */\nfunction NormalizedProvider() {}\n\n\nfunction NormalizedProvider_tsickle_Closure_declarations() {\n}\n\n\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n    FactoryProvider {}\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport class ReflectiveDependency {\n/**\n * @param {?} key\n * @param {?} optional\n * @param {?} visibility\n */\nconstructor(\npublic key: ReflectiveKey,\npublic optional: boolean,\npublic visibility: Self|SkipSelf|null) {}\n/**\n * @param {?} key\n * @return {?}\n */\nstatic fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nfunction ReflectiveDependency_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectiveDependency.prototype.key;\n/** @type {?} */\nReflectiveDependency.prototype.optional;\n/** @type {?} */\nReflectiveDependency.prototype.visibility;\n}\n\n\nconst /** @type {?} */ _EMPTY_LIST: any[] = [];\n/**\n * An internal resolved representation of a {\\@link Provider} used by the {\\@link Injector}.\n * \n * It is usually created automatically by `Injector.resolveAndCreate`.\n * \n * It can be created manually, as follows:\n * \n * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))\n * \n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n * \n * expect(injector.get('message')).toEqual('Hello');\n * ```\n * \n * \\@experimental\n * @record\n */\nexport function ResolvedReflectiveProvider() {}\n\n\nfunction ResolvedReflectiveProvider_tsickle_Closure_declarations() {\n/**\n * A key, usually a `Type<any>`.\n * @type {?}\n */\nResolvedReflectiveProvider.prototype.key;\n/**\n * Factory function which can return an instance of an object represented by a key.\n * @type {?}\n */\nResolvedReflectiveProvider.prototype.resolvedFactories;\n/**\n * Indicates if the provider is a multi-provider or a regular provider.\n * @type {?}\n */\nResolvedReflectiveProvider.prototype.multiProvider;\n}\n\n\n/**\n * An internal resolved representation of a {@link Provider} used by the {@link Injector}.\n *\n * It is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @experimental\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n/**\n * @param {?} key\n * @param {?} resolvedFactories\n * @param {?} multiProvider\n */\nconstructor(\npublic key: ReflectiveKey,\npublic resolvedFactories: ResolvedReflectiveFactory[],\npublic multiProvider: boolean) {}\n/**\n * @return {?}\n */\nget resolvedFactory(): ResolvedReflectiveFactory { return this.resolvedFactories[0]; }\n}\n\nfunction ResolvedReflectiveProvider__tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.key;\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.resolvedFactories;\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.multiProvider;\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving {\\@link\n * Provider}.\n * \\@experimental\n */\nexport class ResolvedReflectiveFactory {\n/**\n * @param {?} factory\n * @param {?} dependencies\n */\nconstructor(\npublic factory: Function,\npublic dependencies: ReflectiveDependency[]) {}\n}\n\nfunction ResolvedReflectiveFactory_tsickle_Closure_declarations() {\n/**\n * Factory function which can return an instance of an object represented by a key.\n * @type {?}\n */\nResolvedReflectiveFactory.prototype.factory;\n/**\n * Arguments (dependencies) to the `factory` function.\n * @type {?}\n */\nResolvedReflectiveFactory.prototype.dependencies;\n}\n\n/**\n * Resolve a single provider.\n * @param {?} provider\n * @return {?}\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let /** @type {?} */ factoryFn: Function;\n  let /** @type {?} */ resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const /** @type {?} */ useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n/**\n * Converts the {\\@link Provider} into {\\@link ResolvedProvider}.\n * \n * {\\@link Injector} internally only uses {\\@link ResolvedProvider}, {\\@link Provider} contains\n * convenience provider syntax.\n * @param {?} provider\n * @return {?}\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n      ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)],\n      provider.multi || false);\n}\n/**\n * Resolve a list of Providers.\n * @param {?} providers\n * @return {?}\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const /** @type {?} */ normalized = _normalizeProviders(providers, []);\n  const /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);\n  const /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n/**\n * Merges a list of ResolvedProviders into a list where\n * each key is contained exactly once and multi providers\n * have been merged.\n * @param {?} providers\n * @param {?} normalizedProvidersMap\n * @return {?}\n */\nexport function mergeResolvedReflectiveProviders(\n    providers: ResolvedReflectiveProvider[],\n    normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n    Map<number, ResolvedReflectiveProvider> {\n  for (let /** @type {?} */ i = 0; i < providers.length; i++) {\n    const /** @type {?} */ provider = providers[i];\n    const /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let /** @type {?} */ resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n            provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n/**\n * @param {?} providers\n * @param {?} res\n * @return {?}\n */\nfunction _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({provide: b, useClass: b});\n\n    } else if (b && typeof b == 'object' && ( /** @type {?} */((b as any))).provide !== undefined) {\n      res.push( /** @type {?} */((b as NormalizedProvider)));\n\n    } else if (b instanceof Array) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n/**\n * @param {?} typeOrFunc\n * @param {?=} dependencies\n * @return {?}\n */\nexport function constructDependencies(\n    typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const /** @type {?} */ params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const /** @type {?} */ params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n/**\n * @param {?} typeOrFunc\n * @param {?} metadata\n * @param {?} params\n * @return {?}\n */\nfunction _extractToken(\n    typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let /** @type {?} */ token: any = null;\n  let /** @type {?} */ optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let /** @type {?} */ visibility: Self|SkipSelf|null = null;\n\n  for (let /** @type {?} */ i = 0; i < metadata.length; ++i) {\n    const /** @type {?} */ paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n/**\n * @param {?} token\n * @param {?} optional\n * @param {?} visibility\n * @return {?}\n */\nfunction _createDependency(\n    token: any, optional: boolean, visibility: Self | SkipSelf | null): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n"]}