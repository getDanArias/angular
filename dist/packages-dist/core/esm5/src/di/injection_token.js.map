{"version":3,"sources":["../../../../../../packages/core/src/di/injection_token.ts"],"names":[],"mappings":"AAAA;;;GAGG;;AAGH;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH;IACA;;OAEG;IACH,qBADwB,KAAO;QAAP,UAAA,GAAA,KAAA,CAAO;IAAQ,CAAA;IAEvC;;OAEG;IACH,8BAHG,GAGH,cAHuB,MAAA,CAAO,WAAA,IAAU,CAAI,KAAM,CAAE,CAAC,CAAA;IAIrD,kBAHC;AAGD,CATA,AAMC,IAAA;;AAKD;IACA,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,KAAK,CAAC;AAC5B,CAAC;AAED;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH;IARuC,0CAAA;IAUvC;;OAEG;IACH,wBATG,IAAiB;eAAU,kBAAM,IAAC,CAAI;IAAE,CAAA;IAU3C;;OAEG;IACH,iCAXG,GAWH,cAXuB,MAAA,CAAO,oBAAA,IAAmB,CAAI,KAAM,CAAE,CAAC,CAAA;IAY9D,qBAXC;AAWD,CAVA,AADC,CAPsC,WAAA,GAOtC;;AAaD;IACA,gBAAgB;IAChB,cAAc,CAAC,SAAS,CAAC,4CAA4C,CAAC;AACtE,CAAC","file":"injection_token.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n * \n * ```typescript\n * var t = new OpaqueToken(\"value\");\n * \n * var injector = Injector.resolveAndCreate([\n *   {provide: t, useValue: \"bindingValue\"}\n * ]);\n * \n * expect(injector.get(t)).toEqual(\"bindingValue\");\n * ```\n * \n * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n * caused by multiple providers using the same string as two different tokens.\n * \n * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n * error messages.\n * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`\n * instead.\n */\nexport class OpaqueToken {\n/**\n * @param {?} _desc\n */\nconstructor(protected _desc: string) {}\n/**\n * @return {?}\n */\ntoString(): string { return `Token ${this._desc}`; }\n}\n\nfunction OpaqueToken_tsickle_Closure_declarations() {\n/** @type {?} */\nOpaqueToken.prototype._desc;\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n * \n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n * \n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='InjectionToken'}\n * \n * \\@stable\n */\nexport class InjectionToken<T> extends OpaqueToken {\nprivate _differentiate_from_OpaqueToken_structurally: any;\n/**\n * @param {?} desc\n */\nconstructor(desc: string) { super(desc); }\n/**\n * @return {?}\n */\ntoString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nfunction InjectionToken_tsickle_Closure_declarations() {\n/** @type {?} */\nInjectionToken.prototype._differentiate_from_OpaqueToken_structurally;\n}\n\n"]}