{"version":3,"sources":["../../../../../packages/router/src/config.ts"],"names":[],"mappings":"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","file":"config.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {NgModuleFactory, NgModuleRef, Type} from '@angular/core';\nimport {Observable} from 'rxjs/Observable';\nimport {PRIMARY_OUTLET} from './shared';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n\n/**\n * @whatItDoes Represents router configuration.\n *\n * @description\n * `Routes` is an array of route configurations. Each one has the following properties:\n *\n * - `path` is a string that uses the route matcher DSL.\n * - `pathMatch` is a string that specifies the matching strategy.\n * - `matcher` defines a custom strategy for path matching and supersedes `path` and `pathMatch`.\n * - `component` is a component type.\n * - `redirectTo` is the url fragment which will replace the current matched segment.\n * - `outlet` is the name of the outlet the component should be placed into.\n * - `canActivate` is an array of DI tokens used to look up CanActivate handlers. See\n *   {@link CanActivate} for more info.\n * - `canActivateChild` is an array of DI tokens used to look up CanActivateChild handlers. See\n *   {@link CanActivateChild} for more info.\n * - `canDeactivate` is an array of DI tokens used to look up CanDeactivate handlers. See\n *   {@link CanDeactivate} for more info.\n * - `canLoad` is an array of DI tokens used to look up CanLoad handlers. See\n *   {@link CanLoad} for more info.\n * - `data` is additional data provided to the component via `ActivatedRoute`.\n * - `resolve` is a map of DI tokens used to look up data resolvers. See {@link Resolve} for more\n *   info.\n * - `runGuardsAndResolvers` defines when guards and resolvers will be run. By default they run only\n *    when the matrix parameters of the route change. When set to `paramsOrQueryParamsChange` they\n *    will also run when query params change. And when set to `always`, they will run every time.\n * - `children` is an array of child route definitions.\n * - `loadChildren` is a reference to lazy loaded child routes. See {@link LoadChildren} for more\n *   info.\n *\n * ### Simple Configuration\n *\n * ```\n * [{\n *   path: 'team/:id',\n  *  component: Team,\n *   children: [{\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/bob`, the router will create the team component with the user\n * component in it.\n *\n * ### Multiple Outlets\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team\n * }, {\n *   path: 'chat/:user',\n *   component: Chat\n *   outlet: 'aux'\n * }]\n * ```\n *\n * When navigating to `/team/11(aux:chat/jim)`, the router will create the team component next to\n * the chat component. The chat component will be placed into the aux outlet.\n *\n * ### Wild Cards\n *\n * ```\n * [{\n *   path: '**',\n *   component: Sink\n * }]\n * ```\n *\n * Regardless of where you navigate to, the router will instantiate the sink component.\n *\n * ### Redirects\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: 'legacy/user/:name',\n *     redirectTo: 'user/:name'\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to '/team/11/legacy/user/jim', the router will change the url to\n * '/team/11/user/jim', and then will instantiate the team component with the user component\n * in it.\n *\n * If the `redirectTo` value starts with a '/', then it is an absolute redirect. E.g., if in the\n * example above we change the `redirectTo` to `/user/:name`, the result url will be '/user/jim'.\n *\n * ### Empty Path\n *\n * Empty-path route configurations can be used to instantiate components that do not 'consume'\n * any url segments. Let's look at the following configuration:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: AllUsers\n *   }, {\n *     path: 'user/:name',\n *     component: User\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11`, the router will instantiate the AllUsers component.\n *\n * Empty-path routes can have children.\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   children: [{\n *     path: '',\n *     component: WrapperCmp,\n *     children: [{\n *       path: 'user/:name',\n *       component: User\n *     }]\n *   }]\n * }]\n * ```\n *\n * When navigating to `/team/11/user/jim`, the router will instantiate the wrapper component with\n * the user component in it.\n *\n * An empty path route inherits its parent's params and data. This is because it cannot have its\n * own params, and, as a result, it often uses its parent's params and data as its own.\n *\n * ### Matching Strategy\n *\n * By default the router will look at what is left in the url, and check if it starts with\n * the specified path (e.g., `/team/11/user` starts with `team/:id`).\n *\n * We can change the matching strategy to make sure that the path covers the whole unconsumed url,\n * which is akin to `unconsumedUrl === path` or `$` regular expressions.\n *\n * This is particularly important when redirecting empty-path routes.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'prefix', //default\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * Since an empty path is a prefix of any url, even when navigating to '/main', the router will\n * still apply the redirect.\n *\n * If `pathMatch: full` is provided, the router will apply the redirect if and only if navigating to\n * '/'.\n *\n * ```\n * [{\n *   path: '',\n *   pathMatch: 'full',\n *   redirectTo: 'main'\n * }, {\n *   path: 'main',\n *   component: Main\n * }]\n * ```\n *\n * ### Componentless Routes\n *\n * It is useful at times to have the ability to share parameters between sibling components.\n *\n * Say we have two components--ChildCmp and AuxCmp--that we want to put next to each other and both\n * of them require some id parameter.\n *\n * One way to do that would be to have a bogus parent component, so both the siblings can get the id\n * parameter from it. This is not ideal. Instead, you can use a componentless route.\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: 'a', component: MainChild },\n *      { path: 'b', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * So when navigating to `parent/10/(a//aux:b)`, the route will instantiate the main child and aux\n * child components next to each other. In this example, the application component\n * has to have the primary and aux outlets defined.\n *\n * The router will also merge the `params`, `data`, and `resolve` of the componentless parent into\n * the `params`, `data`, and `resolve` of the children. This is done because there is no component\n * that can inject the activated route of the componentless parent.\n *\n * This is especially useful when child components are defined as follows:\n *\n * ```\n * [{\n *    path: 'parent/:id',\n *    children: [\n *      { path: '', component: MainChild },\n *      { path: '', component: AuxChild, outlet: 'aux' }\n *    ]\n * }]\n * ```\n *\n * With this configuration in place, navigating to '/parent/10' will create the main child and aux\n * components.\n *\n * ### Lazy Loading\n *\n * Lazy loading speeds up our application load time by splitting it into multiple bundles, and\n * loading them on demand. The router is designed to make lazy loading simple and easy. Instead of\n * providing the children property, you can provide the `loadChildren` property, as follows:\n *\n * ```\n * [{\n *   path: 'team/:id',\n *   component: Team,\n *   loadChildren: 'team'\n * }]\n * ```\n *\n * The router will use registered NgModuleFactoryLoader to fetch an NgModule associated with 'team'.\n * Then it will extract the set of routes defined in that NgModule, and will transparently add\n * those routes to the main configuration.\n *\n * @stable use Routes\n */\nexport type Routes = Route[];\n\n/**\n * @whatItDoes Represents the results of the URL matching.\n *\n * * `consumed` is an array of the consumed URL segments.\n * * `posParams` is a map of positional parameters.\n *\n * @experimental\n */\nexport type UrlMatchResult = {\n  consumed: UrlSegment[]; posParams?: {[name: string]: UrlSegment};\n};\n\n/**\n * @whatItDoes A function matching URLs\n *\n * @description\n *\n * A custom URL matcher can be provided when a combination of `path` and `pathMatch` isn't\n * expressive enough.\n *\n * For instance, the following matcher matches html files.\n *\n * ```\n * function htmlFiles(url: UrlSegment[]) {\n *  return url.length === 1 && url[0].path.endsWith('.html') ? ({consumed: url}) : null;\n * }\n *\n * const routes = [{ matcher: htmlFiles, component: HtmlCmp }];\n * ```\n *\n * @experimental\n */\nexport type UrlMatcher = (segments: UrlSegment[], group: UrlSegmentGroup, route: Route) =>\n    UrlMatchResult;\n\n/**\n * @whatItDoes Represents the static data associated with a particular route.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type Data = {\n  [name: string]: any\n};\n\n/**\n * @whatItDoes Represents the resolved data associated with a particular route.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type ResolveData = {\n  [name: string]: any\n};\n\n/**\n * @whatItDoes The type of `loadChildren`.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type LoadChildrenCallback = () =>\n    Type<any>| NgModuleFactory<any>| Promise<Type<any>>| Observable<Type<any>>;\n\n/**\n * @whatItDoes The type of `loadChildren`.\n * See {@link Routes} for more details.\n * @stable\n */\nexport type LoadChildren = string | LoadChildrenCallback;\n\n/**\n * @whatItDoes The type of `queryParamsHandling`.\n * See {@link RouterLink} for more details.\n * @stable\n */\nexport type QueryParamsHandling = 'merge' | 'preserve' | '';\n\n/**\n * @whatItDoes The type of `runGuardsAndResolvers`.\n * See {@link Routes} for more details.\n * @experimental\n */\nexport type RunGuardsAndResolvers = 'paramsChange' | 'paramsOrQueryParamsChange' | 'always';\n/**\n * See {\\@link Routes} for more details.\n * \\@stable\n * @record\n */\nexport function Route() {}\n\n\nfunction Route_tsickle_Closure_declarations() {\n/** @type {?|undefined} */\nRoute.prototype.path;\n/** @type {?|undefined} */\nRoute.prototype.pathMatch;\n/** @type {?|undefined} */\nRoute.prototype.matcher;\n/** @type {?|undefined} */\nRoute.prototype.component;\n/** @type {?|undefined} */\nRoute.prototype.redirectTo;\n/** @type {?|undefined} */\nRoute.prototype.outlet;\n/** @type {?|undefined} */\nRoute.prototype.canActivate;\n/** @type {?|undefined} */\nRoute.prototype.canActivateChild;\n/** @type {?|undefined} */\nRoute.prototype.canDeactivate;\n/** @type {?|undefined} */\nRoute.prototype.canLoad;\n/** @type {?|undefined} */\nRoute.prototype.data;\n/** @type {?|undefined} */\nRoute.prototype.resolve;\n/** @type {?|undefined} */\nRoute.prototype.children;\n/** @type {?|undefined} */\nRoute.prototype.loadChildren;\n/** @type {?|undefined} */\nRoute.prototype.runGuardsAndResolvers;\n/**\n * Filled for routes with `loadChildren` once the module has been loaded\n * \\@internal\n * @type {?|undefined}\n */\nRoute.prototype._loadedConfig;\n}\n\n\n/**\n * See {@link Routes} for more details.\n * @stable\n */\nexport interface Route {\n  path?: string;\n  pathMatch?: string;\n  matcher?: UrlMatcher;\n  component?: Type<any>;\n  redirectTo?: string;\n  outlet?: string;\n  canActivate?: any[];\n  canActivateChild?: any[];\n  canDeactivate?: any[];\n  canLoad?: any[];\n  data?: Data;\n  resolve?: ResolveData;\n  children?: Routes;\n  loadChildren?: LoadChildren;\n  runGuardsAndResolvers?: RunGuardsAndResolvers;\n  /**\n   * Filled for routes with `loadChildren` once the module has been loaded\n   * @internal\n   */\n  _loadedConfig?: LoadedRouterConfig;\n}\nexport class LoadedRouterConfig {\n/**\n * @param {?} routes\n * @param {?} module\n */\nconstructor(public routes: Route[],\npublic module: NgModuleRef<any>) {}\n}\n\nfunction LoadedRouterConfig_tsickle_Closure_declarations() {\n/** @type {?} */\nLoadedRouterConfig.prototype.routes;\n/** @type {?} */\nLoadedRouterConfig.prototype.module;\n}\n\n/**\n * @param {?} config\n * @param {?=} parentPath\n * @return {?}\n */\nexport function validateConfig(config: Routes, parentPath: string = ''): void {\n  // forEach doesn't iterate undefined values\n  for (let /** @type {?} */ i = 0; i < config.length; i++) {\n    const /** @type {?} */ route: Route = config[i];\n    const /** @type {?} */ fullPath: string = getFullPath(parentPath, route);\n    validateNode(route, fullPath);\n  }\n}\n/**\n * @param {?} route\n * @param {?} fullPath\n * @return {?}\n */\nfunction validateNode(route: Route, fullPath: string): void {\n  if (!route) {\n    throw new Error(`\n      Invalid configuration of route '${fullPath}': Encountered undefined route.\n      The reason might be an extra comma.\n\n      Example:\n      const routes: Routes = [\n        { path: '', redirectTo: '/dashboard', pathMatch: 'full' },\n        { path: 'dashboard',  component: DashboardComponent },, << two commas\n        { path: 'detail/:id', component: HeroDetailComponent }\n      ];\n    `);\n  }\n  if (Array.isArray(route)) {\n    throw new Error(`Invalid configuration of route '${fullPath}': Array cannot be specified`);\n  }\n  if (!route.component && (route.outlet && route.outlet !== PRIMARY_OUTLET)) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': a componentless route cannot have a named outlet set`);\n  }\n  if (route.redirectTo && route.children) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and children cannot be used together`);\n  }\n  if (route.redirectTo && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and loadChildren cannot be used together`);\n  }\n  if (route.children && route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': children and loadChildren cannot be used together`);\n  }\n  if (route.redirectTo && route.component) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': redirectTo and component cannot be used together`);\n  }\n  if (route.path && route.matcher) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': path and matcher cannot be used together`);\n  }\n  if (route.redirectTo === void 0 && !route.component && !route.children && !route.loadChildren) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}'. One of the following must be provided: component, redirectTo, children or loadChildren`);\n  }\n  if (route.path === void 0 && route.matcher === void 0) {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': routes must have either a path or a matcher specified`);\n  }\n  if (typeof route.path === 'string' && route.path.charAt(0) === '/') {\n    throw new Error(`Invalid configuration of route '${fullPath}': path cannot start with a slash`);\n  }\n  if (route.path === '' && route.redirectTo !== void 0 && route.pathMatch === void 0) {\n    const /** @type {?} */ exp =\n        `The default value of 'pathMatch' is 'prefix', but often the intent is to use 'full'.`;\n    throw new Error(\n        `Invalid configuration of route '{path: \"${fullPath}\", redirectTo: \"${route.redirectTo}\"}': please provide 'pathMatch'. ${exp}`);\n  }\n  if (route.pathMatch !== void 0 && route.pathMatch !== 'full' && route.pathMatch !== 'prefix') {\n    throw new Error(\n        `Invalid configuration of route '${fullPath}': pathMatch can only be set to 'prefix' or 'full'`);\n  }\n  if (route.children) {\n    validateConfig(route.children, fullPath);\n  }\n}\n/**\n * @param {?} parentPath\n * @param {?} currentRoute\n * @return {?}\n */\nfunction getFullPath(parentPath: string, currentRoute: Route): string {\n  if (!currentRoute) {\n    return parentPath;\n  }\n  if (!parentPath && !currentRoute.path) {\n    return '';\n  } else if (parentPath && !currentRoute.path) {\n    return `${parentPath}/`;\n  } else if (!parentPath && currentRoute.path) {\n    return currentRoute.path;\n  } else {\n    return `${parentPath}/${currentRoute.path}`;\n  }\n}\n"]}