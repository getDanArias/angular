{"version":3,"sources":["../../../../packages/router/src/route_reuse_strategy.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAgCH;;;;;GAKG;AACH,MALC;CAmBA;AAOD;IAEA;;;;;OAKG;IACH,kBAAkB,CAAC,SAAS,CAAC,YAAY,GAAG,UAAS,KAAK,IAAG,CAAC,CAAC;IAE/D;;;;;;;;OAQG;IACH,kBAAkB,CAAC,SAAS,CAAC,KAAK,GAAG,UAAS,KAAK,EAAE,MAAM,IAAG,CAAC,CAAC;IAEhE;;;;;OAKG;IACH,kBAAkB,CAAC,SAAS,CAAC,YAAY,GAAG,UAAS,KAAK,IAAG,CAAC,CAAC;IAE/D;;;;;OAKG;IACH,kBAAkB,CAAC,SAAS,CAAC,QAAQ,GAAG,UAAS,KAAK,IAAG,CAAC,CAAC;IAE3D;;;;;;OAMG;IACH,kBAAkB,CAAC,SAAS,CAAC,gBAAgB,GAAG,UAAS,MAAM,EAAE,IAAI,IAAG,CAAC,CAAC;AAC1E,CAAC;AAED;;GAEG;AACH,MApDC;IAqDD;;;OAGG;IACH,YAxDG,CAAY,KAAO,IAAmC,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA;IAyDvE;;;;OAIG;IACH,KA7DG,CAAK,KAAO,EAAwB,YAAc,IAA2B,CAAA;IA8DhF;;;OAGG;IACH,YAjEG,CAAY,KAAO,IAAmC,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA;IAkEvE;;;OAGG;IACH,QArEG,CAAQ,KAAO,IAAoD,MAAA,CAAO,IAAA,CAAK,CAAC,CAAA;IAsEnF;;;;OAIG;IACH,gBA1EG,CAAgB,MAAQ,EAAwB,IAAM;QA2ErD,MAAM,CA1EC,MAAA,CAAO,WAAC,KAAe,IAAA,CAAK,WAAC,CAAW;IA2EjD,CAAC;CAzEF","file":"route_reuse_strategy.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {ComponentRef} from '@angular/core';\n\nimport {OutletContext} from './router_outlet_context';\nimport {ActivatedRoute, ActivatedRouteSnapshot} from './router_state';\nimport {TreeNode} from './utils/tree';\n\n/**\n * @whatItDoes Represents the detached route tree.\n *\n * This is an opaque value the router will give to a custom route reuse strategy\n * to store and retrieve later on.\n *\n * @experimental\n */\nexport type DetachedRouteHandle = {};\n\n/** @internal */\nexport type DetachedRouteHandleInternal = {\n  contexts: Map<string, OutletContext>,\n  componentRef: ComponentRef<any>,\n  route: TreeNode<ActivatedRoute>,\n};\n/**\n * \\@whatItDoes Provides a way to customize when activated routes get reused.\n * \n * \\@experimental\n * @abstract\n */\nexport abstract class RouteReuseStrategy {\n  /** Determines if this route (and its subtree) should be detached to be reused later */\n  abstract shouldDetach(route: ActivatedRouteSnapshot): boolean;\n\n  /**\n   * Stores the detached route.\n   *\n   * Storing a `null` value should erase the previously stored value.\n   */\n  abstract store(route: ActivatedRouteSnapshot, handle: DetachedRouteHandle|null): void;\n\n  /** Determines if this route (and its subtree) should be reattached */\n  abstract shouldAttach(route: ActivatedRouteSnapshot): boolean;\n\n  /** Retrieves the previously stored route */\n  abstract retrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null;\n\n  /** Determines if a route should be reused */\n  abstract shouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean;\n}\n\nfunction RouteReuseStrategy_tsickle_Closure_declarations() {\n\n/**\n * Determines if this route (and its subtree) should be detached to be reused later\n * @abstract\n * @param {?} route\n * @return {?}\n */\nRouteReuseStrategy.prototype.shouldDetach = function(route) {};\n\n/**\n * Stores the detached route.\n * \n * Storing a `null` value should erase the previously stored value.\n * @abstract\n * @param {?} route\n * @param {?} handle\n * @return {?}\n */\nRouteReuseStrategy.prototype.store = function(route, handle) {};\n\n/**\n * Determines if this route (and its subtree) should be reattached\n * @abstract\n * @param {?} route\n * @return {?}\n */\nRouteReuseStrategy.prototype.shouldAttach = function(route) {};\n\n/**\n * Retrieves the previously stored route\n * @abstract\n * @param {?} route\n * @return {?}\n */\nRouteReuseStrategy.prototype.retrieve = function(route) {};\n\n/**\n * Determines if a route should be reused\n * @abstract\n * @param {?} future\n * @param {?} curr\n * @return {?}\n */\nRouteReuseStrategy.prototype.shouldReuseRoute = function(future, curr) {};\n}\n\n/**\n * Does not detach any subtrees. Reuses routes as long as their route config is the same.\n */\nexport class DefaultRouteReuseStrategy implements RouteReuseStrategy {\n/**\n * @param {?} route\n * @return {?}\n */\nshouldDetach(route: ActivatedRouteSnapshot): boolean { return false; }\n/**\n * @param {?} route\n * @param {?} detachedTree\n * @return {?}\n */\nstore(route: ActivatedRouteSnapshot, detachedTree: DetachedRouteHandle): void {}\n/**\n * @param {?} route\n * @return {?}\n */\nshouldAttach(route: ActivatedRouteSnapshot): boolean { return false; }\n/**\n * @param {?} route\n * @return {?}\n */\nretrieve(route: ActivatedRouteSnapshot): DetachedRouteHandle|null { return null; }\n/**\n * @param {?} future\n * @param {?} curr\n * @return {?}\n */\nshouldReuseRoute(future: ActivatedRouteSnapshot, curr: ActivatedRouteSnapshot): boolean {\n    return future.routeConfig === curr.routeConfig;\n  }\n}\n"]}