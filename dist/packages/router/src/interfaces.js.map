{"version":3,"sources":["../../../../packages/router/src/interfaces.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAcH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAkEG;AACH,MAAM,0BAAyB,CAAC;AAGhC;IACA,gBAAgB;IAChB,WAAW,CAAC,SAAS,CAAC,WAAW,CAAC;AAClC,CAAC;AA0ED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GA4EG;AACH,MAAM,+BAA8B,CAAC;AAGrC;IACA,gBAAgB;IAChB,gBAAgB,CAAC,SAAS,CAAC,gBAAgB,CAAC;AAC5C,CAAC;AAmFD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAqEG;AACH,MAAM,4BAA2B,CAAC;AAGlC;IACA,gBAAgB;IAChB,aAAa,CAAC,SAAS,CAAC,aAAa,CAAC;AACtC,CAAC;AA6ED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmEG;AACH,MAAM,sBAAqB,CAAC;AAG5B;IACA,gBAAgB;IAChB,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC;AAC1B,CAAC;AAyED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiEG;AACH,MAAM,sBAAqB,CAAC;AAG5B;IACA,gBAAgB;IAChB,OAAO,CAAC,SAAS,CAAC,OAAO,CAAC;AAC1B,CAAC","file":"interfaces.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Observable} from 'rxjs/Observable';\n\nimport {Route} from './config';\nimport {ActivatedRouteSnapshot, RouterStateSnapshot} from './router_state';\n/**\n * \\@whatItDoes Interface that a class can implement to be a guard deciding if a route can be\n * activated.\n * \n * \\@howToUse \n * \n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * \n * \\@Injectable() \n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n * \n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * \n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n * \n * You can alternatively provide a function with the `canActivate` signature:\n * \n * ```\n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canActivate: ['canActivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n * \n * \\@stable\n * @record\n */\nexport function CanActivate() {}\n\n\nfunction CanActivate_tsickle_Closure_declarations() {\n/** @type {?} */\nCanActivate.prototype.canActivate;\n}\n\n\n\n/**\n * @whatItDoes Interface that a class can implement to be a guard deciding if a route can be\n * activated.\n *\n * @howToUse\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivate {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivate(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canActivate: [CanActivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canActivate` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canActivate: ['canActivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @stable\n */\nexport interface CanActivate {\n  canActivate(route: ActivatedRouteSnapshot, state: RouterStateSnapshot):\n      Observable<boolean>|Promise<boolean>|boolean;\n}\n/**\n * \\@whatItDoes Interface that a class can implement to be a guard deciding if a child route can be\n * activated.\n * \n * \\@howToUse \n * \n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * \n * \\@Injectable() \n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n * \n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n * \n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: Team\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n * \n * You can alternatively provide a function with the `canActivateChild` signature:\n * \n * ```\n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: ['canActivateTeam'],\n *         children: [\n *           {\n *             path: 'team/:id',\n *             component: Team\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n * \n * \\@stable\n * @record\n */\nexport function CanActivateChild() {}\n\n\nfunction CanActivateChild_tsickle_Closure_declarations() {\n/** @type {?} */\nCanActivateChild.prototype.canActivateChild;\n}\n\n\n/**\n * @whatItDoes Interface that a class can implement to be a guard deciding if a child route can be\n * activated.\n *\n * @howToUse\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canActivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanActivateTeam implements CanActivateChild {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canActivateChild(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canActivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: [CanActivateTeam],\n *         children: [\n *           {\n *              path: 'team/:id',\n *              component: Team\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [CanActivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canActivateChild` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'root',\n *         canActivateChild: ['canActivateTeam'],\n *         children: [\n *           {\n *             path: 'team/:id',\n *             component: Team\n *           }\n *         ]\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canActivateTeam',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @stable\n */\nexport interface CanActivateChild {\n  canActivateChild(childRoute: ActivatedRouteSnapshot, state: RouterStateSnapshot):\n      Observable<boolean>|Promise<boolean>|boolean;\n}\n/**\n * \\@whatItDoes Interface that a class can implement to be a guard deciding if a route can be\n * deactivated.\n * \n * \\@howToUse \n * \n * ```\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * \n * \\@Injectable() \n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n * \n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n * \n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n * \n * You can alternatively provide a function with the `canDeactivate` signature:\n * \n * ```\n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canDeactivate: ['canDeactivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canDeactivateTeam',\n *       useValue: (component: TeamComponent, currentRoute: ActivatedRouteSnapshot, currentState:\n * RouterStateSnapshot, nextState: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n * \n * \\@stable\n * @record\n */\nexport function CanDeactivate() {}\n\n\nfunction CanDeactivate_tsickle_Closure_declarations() {\n/** @type {?} */\nCanDeactivate.prototype.canDeactivate;\n}\n\n\n/**\n * @whatItDoes Interface that a class can implement to be a guard deciding if a route can be\n * deactivated.\n *\n * @howToUse\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canDeactivate(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanDeactivateTeam implements CanDeactivate<TeamComponent> {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canDeactivate(\n *     component: TeamComponent,\n *     currentRoute: ActivatedRouteSnapshot,\n *     currentState: RouterStateSnapshot,\n *     nextState: RouterStateSnapshot\n *   ): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canDeactivate(this.currentUser, route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canDeactivate: [CanDeactivateTeam]\n *       }\n *     ])\n *   ],\n *   providers: [CanDeactivateTeam, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canDeactivate` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         canDeactivate: ['canDeactivateTeam']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canDeactivateTeam',\n *       useValue: (component: TeamComponent, currentRoute: ActivatedRouteSnapshot, currentState:\n * RouterStateSnapshot, nextState: RouterStateSnapshot) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @stable\n */\nexport interface CanDeactivate<T> {\n  canDeactivate(\n      component: T, currentRoute: ActivatedRouteSnapshot, currentState: RouterStateSnapshot,\n      nextState?: RouterStateSnapshot): Observable<boolean>|Promise<boolean>|boolean;\n}\n/**\n * \\@whatItDoes Interface that class can implement to be a data provider.\n * \n * \\@howToUse \n * \n * ```\n * class Backend {\n *   fetchTeam(id: string) {\n *     return 'someTeam';\n *   }\n * }\n * \n * \\@Injectable() \n * class TeamResolver implements Resolve<Team> {\n *   constructor(private backend: Backend) {}\n * \n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<any>|Promise<any>|any {\n *     return this.backend.fetchTeam(route.params.id);\n *   }\n * }\n * \n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         resolve: {\n *           team: TeamResolver\n *         }\n *       }\n *     ])\n *   ],\n *   providers: [TeamResolver]\n * })\n * class AppModule {}\n * ```\n * \n * You can alternatively provide a function with the `resolve` signature:\n * \n * ```\n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         resolve: {\n *           team: 'teamResolver'\n *         }\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'teamResolver',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => 'team'\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n * \\@stable\n * @record\n */\nexport function Resolve() {}\n\n\nfunction Resolve_tsickle_Closure_declarations() {\n/** @type {?} */\nResolve.prototype.resolve;\n}\n\n\n/**\n * @whatItDoes Interface that class can implement to be a data provider.\n *\n * @howToUse\n *\n * ```\n * class Backend {\n *   fetchTeam(id: string) {\n *     return 'someTeam';\n *   }\n * }\n *\n * @Injectable()\n * class TeamResolver implements Resolve<Team> {\n *   constructor(private backend: Backend) {}\n *\n *   resolve(\n *     route: ActivatedRouteSnapshot,\n *     state: RouterStateSnapshot\n *   ): Observable<any>|Promise<any>|any {\n *     return this.backend.fetchTeam(route.params.id);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         resolve: {\n *           team: TeamResolver\n *         }\n *       }\n *     ])\n *   ],\n *   providers: [TeamResolver]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `resolve` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         resolve: {\n *           team: 'teamResolver'\n *         }\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'teamResolver',\n *       useValue: (route: ActivatedRouteSnapshot, state: RouterStateSnapshot) => 'team'\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n * @stable\n */\nexport interface Resolve<T> {\n  resolve(route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<T>|Promise<T>|T;\n}\n/**\n * \\@whatItDoes Interface that a class can implement to be a guard deciding if a children can be\n * loaded.\n * \n * \\@howToUse \n * \n * ```\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n * \n * \\@Injectable() \n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n * \n *   canLoad(route: Route): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route);\n *   }\n * }\n * \n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         loadChildren: 'team.js',\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n * \n * You can alternatively provide a function with the `canLoad` signature:\n * \n * ```\n * \\@NgModule({ \n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         loadChildren: 'team.js',\n *         canLoad: ['canLoadTeamSection']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canLoadTeamSection',\n *       useValue: (route: Route) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n * \n * \\@stable\n * @record\n */\nexport function CanLoad() {}\n\n\nfunction CanLoad_tsickle_Closure_declarations() {\n/** @type {?} */\nCanLoad.prototype.canLoad;\n}\n\n\n\n/**\n * @whatItDoes Interface that a class can implement to be a guard deciding if a children can be\n * loaded.\n *\n * @howToUse\n *\n * ```\n * class UserToken {}\n * class Permissions {\n *   canLoadChildren(user: UserToken, id: string): boolean {\n *     return true;\n *   }\n * }\n *\n * @Injectable()\n * class CanLoadTeamSection implements CanLoad {\n *   constructor(private permissions: Permissions, private currentUser: UserToken) {}\n *\n *   canLoad(route: Route): Observable<boolean>|Promise<boolean>|boolean {\n *     return this.permissions.canLoadChildren(this.currentUser, route);\n *   }\n * }\n *\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         loadChildren: 'team.js',\n *         canLoad: [CanLoadTeamSection]\n *       }\n *     ])\n *   ],\n *   providers: [CanLoadTeamSection, UserToken, Permissions]\n * })\n * class AppModule {}\n * ```\n *\n * You can alternatively provide a function with the `canLoad` signature:\n *\n * ```\n * @NgModule({\n *   imports: [\n *     RouterModule.forRoot([\n *       {\n *         path: 'team/:id',\n *         component: TeamCmp,\n *         loadChildren: 'team.js',\n *         canLoad: ['canLoadTeamSection']\n *       }\n *     ])\n *   ],\n *   providers: [\n *     {\n *       provide: 'canLoadTeamSection',\n *       useValue: (route: Route) => true\n *     }\n *   ]\n * })\n * class AppModule {}\n * ```\n *\n * @stable\n */\nexport interface CanLoad { canLoad(route: Route): Observable<boolean>|Promise<boolean>|boolean; }\n"]}