{"version":3,"sources":["../../../../packages/router/src/shared.ts"],"names":[],"mappings":"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","file":"shared.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Route, UrlMatchResult} from './config';\nimport {UrlSegment, UrlSegmentGroup} from './url_tree';\n/**\n * \\@whatItDoes Name of the primary outlet.\n * \n * \\@stable\n */\nexport const /** @type {?} */ PRIMARY_OUTLET = 'primary';\n\n/**\n * A collection of parameters.\n *\n * @stable\n */\nexport type Params = {\n  [key: string]: any\n};\n/**\n * Matrix and Query parameters.\n * \n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n * \n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n * \n * \\@stable\n * @record\n */\nexport function ParamMap() {}\n\n\nfunction ParamMap_tsickle_Closure_declarations() {\n/** @type {?} */\nParamMap.prototype.has;\n/**\n * Return a single value for the given parameter name:\n * - the value when the parameter has a single value,\n * - the first value if the parameter has multiple values,\n * - `null` when there is no such parameter.\n * @type {?}\n */\nParamMap.prototype.get;\n/**\n * Return an array of values for the given parameter name.\n * \n * If there is no such parameter, an empty array is returned.\n * @type {?}\n */\nParamMap.prototype.getAll;\n/**\n * Name of the parameters\n * @type {?}\n */\nParamMap.prototype.keys;\n}\n\n\n/**\n * Matrix and Query parameters.\n *\n * `ParamMap` makes it easier to work with parameters as they could have either a single value or\n * multiple value. Because this should be known by the user, calling `get` or `getAll` returns the\n * correct type (either `string` or `string[]`).\n *\n * The API is inspired by the URLSearchParams interface.\n * see https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n *\n * @stable\n */\nexport interface ParamMap {\n  has(name: string): boolean;\n  /**\n   * Return a single value for the given parameter name:\n   * - the value when the parameter has a single value,\n   * - the first value if the parameter has multiple values,\n   * - `null` when there is no such parameter.\n   */\n  get(name: string): string|null;\n  /**\n   * Return an array of values for the given parameter name.\n   *\n   * If there is no such parameter, an empty array is returned.\n   */\n  getAll(name: string): string[];\n\n  /** Name of the parameters */\n  readonly keys: string[];\n}\nclass ParamsAsMap implements ParamMap {\nprivate params: Params;\n/**\n * @param {?} params\n */\nconstructor(params: Params) { this.params = params || {}; }\n/**\n * @param {?} name\n * @return {?}\n */\nhas(name: string): boolean { return this.params.hasOwnProperty(name); }\n/**\n * @param {?} name\n * @return {?}\n */\nget(name: string): string|null {\n    if (this.has(name)) {\n      const /** @type {?} */ v = this.params[name];\n      return Array.isArray(v) ? v[0] : v;\n    }\n\n    return null;\n  }\n/**\n * @param {?} name\n * @return {?}\n */\ngetAll(name: string): string[] {\n    if (this.has(name)) {\n      const /** @type {?} */ v = this.params[name];\n      return Array.isArray(v) ? v : [v];\n    }\n\n    return [];\n  }\n/**\n * @return {?}\n */\nget keys(): string[] { return Object.keys(this.params); }\n}\n\nfunction ParamsAsMap_tsickle_Closure_declarations() {\n/** @type {?} */\nParamsAsMap.prototype.params;\n}\n\n/**\n * Convert a {\\@link Params} instance to a {\\@link ParamMap}.\n * \n * \\@stable\n * @param {?} params\n * @return {?}\n */\nexport function convertToParamMap(params: Params): ParamMap {\n  return new ParamsAsMap(params);\n}\n\nconst /** @type {?} */ NAVIGATION_CANCELING_ERROR = 'ngNavigationCancelingError';\n/**\n * @param {?} message\n * @return {?}\n */\nexport function navigationCancelingError(message: string) {\n  const /** @type {?} */ error = Error('NavigationCancelingError: ' + message);\n  ( /** @type {?} */((error as any)))[NAVIGATION_CANCELING_ERROR] = true;\n  return error;\n}\n/**\n * @param {?} error\n * @return {?}\n */\nexport function isNavigationCancelingError(error: Error) {\n  return ( /** @type {?} */((error as any)))[NAVIGATION_CANCELING_ERROR];\n}\n/**\n * @param {?} segments\n * @param {?} segmentGroup\n * @param {?} route\n * @return {?}\n */\nexport function defaultUrlMatcher(\n    segments: UrlSegment[], segmentGroup: UrlSegmentGroup, route: Route): UrlMatchResult|null {\n  const /** @type {?} */ parts = /** @type {?} */(( route.path)).split('/');\n\n  if (parts.length > segments.length) {\n    // The actual URL is shorter than the config, no match\n    return null;\n  }\n\n  if (route.pathMatch === 'full' &&\n      (segmentGroup.hasChildren() || parts.length < segments.length)) {\n    // The config is longer than the actual URL but we are looking for a full match, return null\n    return null;\n  }\n\n  const /** @type {?} */ posParams: {[key: string]: UrlSegment} = {};\n\n  // Check each config part against the actual URL\n  for (let /** @type {?} */ index = 0; index < parts.length; index++) {\n    const /** @type {?} */ part = parts[index];\n    const /** @type {?} */ segment = segments[index];\n    const /** @type {?} */ isParameter = part.startsWith(':');\n    if (isParameter) {\n      posParams[part.substring(1)] = segment;\n    } else if (part !== segment.path) {\n      // The actual URL part does not match the config, no match\n      return null;\n    }\n  }\n\n  return {consumed: segments.slice(0, parts.length), posParams};\n}\n"]}