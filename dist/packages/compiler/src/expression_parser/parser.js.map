{"version":3,"sources":["../../../../../packages/compiler/src/expression_parser/parser.ts"],"names":[],"mappings":"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","file":"parser.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport * as chars from '../chars';\nimport {CompilerInjectable} from '../injectable';\nimport {DEFAULT_INTERPOLATION_CONFIG, InterpolationConfig} from '../ml_parser/interpolation_config';\nimport {escapeRegExp} from '../util';\n\nimport {AST, ASTWithSource, AstVisitor, Binary, BindingPipe, Chain, Conditional, EmptyExpr, FunctionCall, ImplicitReceiver, Interpolation, KeyedRead, KeyedWrite, LiteralArray, LiteralMap, LiteralMapKey, LiteralPrimitive, MethodCall, NonNullAssert, ParseSpan, ParserError, PrefixNot, PropertyRead, PropertyWrite, Quote, SafeMethodCall, SafePropertyRead, TemplateBinding} from './ast';\nimport {EOF, Lexer, Token, TokenType, isIdentifier, isQuote} from './lexer';\nexport class SplitInterpolation {\n/**\n * @param {?} strings\n * @param {?} expressions\n * @param {?} offsets\n */\nconstructor(public strings: string[],\npublic expressions: string[],\npublic offsets: number[]) {}\n}\n\nfunction SplitInterpolation_tsickle_Closure_declarations() {\n/** @type {?} */\nSplitInterpolation.prototype.strings;\n/** @type {?} */\nSplitInterpolation.prototype.expressions;\n/** @type {?} */\nSplitInterpolation.prototype.offsets;\n}\n\nexport class TemplateBindingParseResult {\n/**\n * @param {?} templateBindings\n * @param {?} warnings\n * @param {?} errors\n */\nconstructor(\npublic templateBindings: TemplateBinding[],\npublic warnings: string[],\npublic errors: ParserError[]) {}\n}\n\nfunction TemplateBindingParseResult_tsickle_Closure_declarations() {\n/** @type {?} */\nTemplateBindingParseResult.prototype.templateBindings;\n/** @type {?} */\nTemplateBindingParseResult.prototype.warnings;\n/** @type {?} */\nTemplateBindingParseResult.prototype.errors;\n}\n\n/**\n * @param {?} config\n * @return {?}\n */\nfunction _createInterpolateRegExp(config: InterpolationConfig): RegExp {\n  const /** @type {?} */ pattern = escapeRegExp(config.start) + '([\\\\s\\\\S]*?)' + escapeRegExp(config.end);\n  return new RegExp(pattern, 'g');\n}\nexport class Parser {\nprivate errors: ParserError[] = [];\n/**\n * @param {?} _lexer\n */\nconstructor(private _lexer: Lexer) {}\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseAction(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const /** @type {?} */ sourceToLex = this._stripComments(input);\n    const /** @type {?} */ tokens = this._lexer.tokenize(this._stripComments(input));\n    const /** @type {?} */ ast = new _ParseAST(\n                    input, location, tokens, sourceToLex.length, true, this.errors,\n                    input.length - sourceToLex.length)\n                    .parseChain();\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseBinding(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseSimpleBinding(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource {\n    const /** @type {?} */ ast = this._parseBindingAst(input, location, interpolationConfig);\n    const /** @type {?} */ errors = SimpleExpressionChecker.check(ast);\n    if (errors.length > 0) {\n      this._reportError(\n          `Host binding expression cannot contain ${errors.join(' ')}`, input, location);\n    }\n    return new ASTWithSource(ast, input, location, this.errors);\n  }\n/**\n * @param {?} message\n * @param {?} input\n * @param {?} errLocation\n * @param {?=} ctxLocation\n * @return {?}\n */\n\nprivate _reportError(message: string, input: string, errLocation: string, ctxLocation?: any) {\n    this.errors.push(new ParserError(message, input, errLocation, ctxLocation));\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?} interpolationConfig\n * @return {?}\n */\n\nprivate _parseBindingAst(\n      input: string, location: string, interpolationConfig: InterpolationConfig): AST {\n    // Quotes expressions use 3rd-party expression language. We don't want to use\n    // our lexer or parser for that, so we check for that ahead of time.\n    const /** @type {?} */ quote = this._parseQuote(input, location);\n\n    if (quote != null) {\n      return quote;\n    }\n\n    this._checkNoInterpolation(input, location, interpolationConfig);\n    const /** @type {?} */ sourceToLex = this._stripComments(input);\n    const /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n    return new _ParseAST(\n               input, location, tokens, sourceToLex.length, false, this.errors,\n               input.length - sourceToLex.length)\n        .parseChain();\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @return {?}\n */\n\nprivate _parseQuote(input: string|null, location: any): AST|null {\n    if (input == null) return null;\n    const /** @type {?} */ prefixSeparatorIndex = input.indexOf(':');\n    if (prefixSeparatorIndex == -1) return null;\n    const /** @type {?} */ prefix = input.substring(0, prefixSeparatorIndex).trim();\n    if (!isIdentifier(prefix)) return null;\n    const /** @type {?} */ uninterpretedExpression = input.substring(prefixSeparatorIndex + 1);\n    return new Quote(new ParseSpan(0, input.length), prefix, uninterpretedExpression, location);\n  }\n/**\n * @param {?} prefixToken\n * @param {?} input\n * @param {?} location\n * @return {?}\n */\nparseTemplateBindings(prefixToken: string|null, input: string, location: any):\n      TemplateBindingParseResult {\n    const /** @type {?} */ tokens = this._lexer.tokenize(input);\n    if (prefixToken) {\n      // Prefix the tokens with the tokens from prefixToken but have them take no space (0 index).\n      const /** @type {?} */ prefixTokens = this._lexer.tokenize(prefixToken).map(t => {\n        t.index = 0;\n        return t;\n      });\n      tokens.unshift(...prefixTokens);\n    }\n    return new _ParseAST(input, location, tokens, input.length, false, this.errors, 0)\n        .parseTemplateBindings();\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nparseInterpolation(\n      input: string, location: any,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): ASTWithSource|null {\n    const /** @type {?} */ split = this.splitInterpolation(input, location, interpolationConfig);\n    if (split == null) return null;\n\n    const /** @type {?} */ expressions: AST[] = [];\n\n    for (let /** @type {?} */ i = 0; i < split.expressions.length; ++i) {\n      const /** @type {?} */ expressionText = split.expressions[i];\n      const /** @type {?} */ sourceToLex = this._stripComments(expressionText);\n      const /** @type {?} */ tokens = this._lexer.tokenize(sourceToLex);\n      const /** @type {?} */ ast = new _ParseAST(\n                      input, location, tokens, sourceToLex.length, false, this.errors,\n                      split.offsets[i] + (expressionText.length - sourceToLex.length))\n                      .parseChain();\n      expressions.push(ast);\n    }\n\n    return new ASTWithSource(\n        new Interpolation(\n            new ParseSpan(0, input == null ? 0 : input.length), split.strings, expressions),\n        input, location, this.errors);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?=} interpolationConfig\n * @return {?}\n */\nsplitInterpolation(\n      input: string, location: string,\n      interpolationConfig: InterpolationConfig = DEFAULT_INTERPOLATION_CONFIG): SplitInterpolation\n      |null {\n    const /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n    const /** @type {?} */ parts = input.split(regexp);\n    if (parts.length <= 1) {\n      return null;\n    }\n    const /** @type {?} */ strings: string[] = [];\n    const /** @type {?} */ expressions: string[] = [];\n    const /** @type {?} */ offsets: number[] = [];\n    let /** @type {?} */ offset = 0;\n    for (let /** @type {?} */ i = 0; i < parts.length; i++) {\n      const /** @type {?} */ part: string = parts[i];\n      if (i % 2 === 0) {\n        // fixed string\n        strings.push(part);\n        offset += part.length;\n      } else if (part.trim().length > 0) {\n        offset += interpolationConfig.start.length;\n        expressions.push(part);\n        offsets.push(offset);\n        offset += part.length + interpolationConfig.end.length;\n      } else {\n        this._reportError(\n            'Blank expressions are not allowed in interpolated strings', input,\n            `at column ${this._findInterpolationErrorColumn(parts, i, interpolationConfig)} in`,\n            location);\n        expressions.push('$implict');\n        offsets.push(offset);\n      }\n    }\n    return new SplitInterpolation(strings, expressions, offsets);\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @return {?}\n */\nwrapLiteralPrimitive(input: string|null, location: any): ASTWithSource {\n    return new ASTWithSource(\n        new LiteralPrimitive(new ParseSpan(0, input == null ? 0 : input.length), input), input,\n        location, this.errors);\n  }\n/**\n * @param {?} input\n * @return {?}\n */\n\nprivate _stripComments(input: string): string {\n    const /** @type {?} */ i = this._commentStart(input);\n    return i != null ? input.substring(0, i).trim() : input;\n  }\n/**\n * @param {?} input\n * @return {?}\n */\n\nprivate _commentStart(input: string): number|null {\n    let /** @type {?} */ outerQuote: number|null = null;\n    for (let /** @type {?} */ i = 0; i < input.length - 1; i++) {\n      const /** @type {?} */ char = input.charCodeAt(i);\n      const /** @type {?} */ nextChar = input.charCodeAt(i + 1);\n\n      if (char === chars.$SLASH && nextChar == chars.$SLASH && outerQuote == null) return i;\n\n      if (outerQuote === char) {\n        outerQuote = null;\n      } else if (outerQuote == null && isQuote(char)) {\n        outerQuote = char;\n      }\n    }\n    return null;\n  }\n/**\n * @param {?} input\n * @param {?} location\n * @param {?} interpolationConfig\n * @return {?}\n */\n\nprivate _checkNoInterpolation(\n      input: string, location: any, interpolationConfig: InterpolationConfig): void {\n    const /** @type {?} */ regexp = _createInterpolateRegExp(interpolationConfig);\n    const /** @type {?} */ parts = input.split(regexp);\n    if (parts.length > 1) {\n      this._reportError(\n          `Got interpolation (${interpolationConfig.start}${interpolationConfig.end}) where expression was expected`,\n          input,\n          `at column ${this._findInterpolationErrorColumn(parts, 1, interpolationConfig)} in`,\n          location);\n    }\n  }\n/**\n * @param {?} parts\n * @param {?} partInErrIdx\n * @param {?} interpolationConfig\n * @return {?}\n */\n\nprivate _findInterpolationErrorColumn(\n      parts: string[], partInErrIdx: number, interpolationConfig: InterpolationConfig): number {\n    let /** @type {?} */ errLocation = '';\n    for (let /** @type {?} */ j = 0; j < partInErrIdx; j++) {\n      errLocation += j % 2 === 0 ?\n          parts[j] :\n          `${interpolationConfig.start}${parts[j]}${interpolationConfig.end}`;\n    }\n\n    return errLocation.length;\n  }\nstatic decorators: {type: Function, args?: any[]}[] = [\n{ type: CompilerInjectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: {type: Function, args?: any[]}[]}|null)[] = () => [\n{type: Lexer, },\n];\n}\n\nfunction Parser_tsickle_Closure_declarations() {\n/** @type {?} */\nParser.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nParser.ctorParameters;\n/** @type {?} */\nParser.prototype.errors;\n/** @type {?} */\nParser.prototype._lexer;\n}\n\nexport class _ParseAST {\nprivate rparensExpected = 0;\nprivate rbracketsExpected = 0;\nprivate rbracesExpected = 0;\n\n  index: number = 0;\n/**\n * @param {?} input\n * @param {?} location\n * @param {?} tokens\n * @param {?} inputLength\n * @param {?} parseAction\n * @param {?} errors\n * @param {?} offset\n */\nconstructor(\npublic input: string,\npublic location: any,\npublic tokens: Token[],\npublic inputLength: number,\npublic parseAction: boolean,\nprivate errors: ParserError[],\nprivate offset: number) {}\n/**\n * @param {?} offset\n * @return {?}\n */\npeek(offset: number): Token {\n    const /** @type {?} */ i = this.index + offset;\n    return i < this.tokens.length ? this.tokens[i] : EOF;\n  }\n/**\n * @return {?}\n */\nget next(): Token { return this.peek(0); }\n/**\n * @return {?}\n */\nget inputIndex(): number {\n    return (this.index < this.tokens.length) ? this.next.index + this.offset :\n                                               this.inputLength + this.offset;\n  }\n/**\n * @param {?} start\n * @return {?}\n */\nspan(start: number) { return new ParseSpan(start, this.inputIndex); }\n/**\n * @return {?}\n */\nadvance() { this.index++; }\n/**\n * @param {?} code\n * @return {?}\n */\noptionalCharacter(code: number): boolean {\n    if (this.next.isCharacter(code)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n/**\n * @return {?}\n */\npeekKeywordLet(): boolean { return this.next.isKeywordLet(); }\n/**\n * @return {?}\n */\npeekKeywordAs(): boolean { return this.next.isKeywordAs(); }\n/**\n * @param {?} code\n * @return {?}\n */\nexpectCharacter(code: number) {\n    if (this.optionalCharacter(code)) return;\n    this.error(`Missing expected ${String.fromCharCode(code)}`);\n  }\n/**\n * @param {?} op\n * @return {?}\n */\noptionalOperator(op: string): boolean {\n    if (this.next.isOperator(op)) {\n      this.advance();\n      return true;\n    } else {\n      return false;\n    }\n  }\n/**\n * @param {?} operator\n * @return {?}\n */\nexpectOperator(operator: string) {\n    if (this.optionalOperator(operator)) return;\n    this.error(`Missing expected operator ${operator}`);\n  }\n/**\n * @return {?}\n */\nexpectIdentifierOrKeyword(): string {\n    const /** @type {?} */ n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword()) {\n      this.error(`Unexpected token ${n}, expected identifier or keyword`);\n      return '';\n    }\n    this.advance();\n    return /** @type {?} */(( n.toString() as string));\n  }\n/**\n * @return {?}\n */\nexpectIdentifierOrKeywordOrString(): string {\n    const /** @type {?} */ n = this.next;\n    if (!n.isIdentifier() && !n.isKeyword() && !n.isString()) {\n      this.error(`Unexpected token ${n}, expected identifier, keyword, or string`);\n      return '';\n    }\n    this.advance();\n    return /** @type {?} */(( n.toString() as string));\n  }\n/**\n * @return {?}\n */\nparseChain(): AST {\n    const /** @type {?} */ exprs: AST[] = [];\n    const /** @type {?} */ start = this.inputIndex;\n    while (this.index < this.tokens.length) {\n      const /** @type {?} */ expr = this.parsePipe();\n      exprs.push(expr);\n\n      if (this.optionalCharacter(chars.$SEMICOLON)) {\n        if (!this.parseAction) {\n          this.error('Binding expression cannot contain chained expression');\n        }\n        while (this.optionalCharacter(chars.$SEMICOLON)) {\n        }  // read all semicolons\n      } else if (this.index < this.tokens.length) {\n        this.error(`Unexpected token '${this.next}'`);\n      }\n    }\n    if (exprs.length == 0) return new EmptyExpr(this.span(start));\n    if (exprs.length == 1) return exprs[0];\n    return new Chain(this.span(start), exprs);\n  }\n/**\n * @return {?}\n */\nparsePipe(): AST {\n    let /** @type {?} */ result = this.parseExpression();\n    if (this.optionalOperator('|')) {\n      if (this.parseAction) {\n        this.error('Cannot have a pipe in an action expression');\n      }\n\n      do {\n        const /** @type {?} */ name = this.expectIdentifierOrKeyword();\n        const /** @type {?} */ args: AST[] = [];\n        while (this.optionalCharacter(chars.$COLON)) {\n          args.push(this.parseExpression());\n        }\n        result = new BindingPipe(this.span(result.span.start), result, name, args);\n      } while (this.optionalOperator('|'));\n    }\n\n    return result;\n  }\n/**\n * @return {?}\n */\nparseExpression(): AST { return this.parseConditional(); }\n/**\n * @return {?}\n */\nparseConditional(): AST {\n    const /** @type {?} */ start = this.inputIndex;\n    const /** @type {?} */ result = this.parseLogicalOr();\n\n    if (this.optionalOperator('?')) {\n      const /** @type {?} */ yes = this.parsePipe();\n      let /** @type {?} */ no: AST;\n      if (!this.optionalCharacter(chars.$COLON)) {\n        const /** @type {?} */ end = this.inputIndex;\n        const /** @type {?} */ expression = this.input.substring(start, end);\n        this.error(`Conditional expression ${expression} requires all 3 expressions`);\n        no = new EmptyExpr(this.span(start));\n      } else {\n        no = this.parsePipe();\n      }\n      return new Conditional(this.span(start), result, yes, no);\n    } else {\n      return result;\n    }\n  }\n/**\n * @return {?}\n */\nparseLogicalOr(): AST {\n    // '||'\n    let /** @type {?} */ result = this.parseLogicalAnd();\n    while (this.optionalOperator('||')) {\n      const /** @type {?} */ right = this.parseLogicalAnd();\n      result = new Binary(this.span(result.span.start), '||', result, right);\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseLogicalAnd(): AST {\n    // '&&'\n    let /** @type {?} */ result = this.parseEquality();\n    while (this.optionalOperator('&&')) {\n      const /** @type {?} */ right = this.parseEquality();\n      result = new Binary(this.span(result.span.start), '&&', result, right);\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseEquality(): AST {\n    // '==','!=','===','!=='\n    let /** @type {?} */ result = this.parseRelational();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '==':\n        case '===':\n        case '!=':\n        case '!==':\n          this.advance();\n          const /** @type {?} */ right = this.parseRelational();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseRelational(): AST {\n    // '<', '>', '<=', '>='\n    let /** @type {?} */ result = this.parseAdditive();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '<':\n        case '>':\n        case '<=':\n        case '>=':\n          this.advance();\n          const /** @type {?} */ right = this.parseAdditive();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseAdditive(): AST {\n    // '+', '-'\n    let /** @type {?} */ result = this.parseMultiplicative();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '+':\n        case '-':\n          this.advance();\n          let /** @type {?} */ right = this.parseMultiplicative();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseMultiplicative(): AST {\n    // '*', '%', '/'\n    let /** @type {?} */ result = this.parsePrefix();\n    while (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ operator = this.next.strValue;\n      switch (operator) {\n        case '*':\n        case '%':\n        case '/':\n          this.advance();\n          let /** @type {?} */ right = this.parsePrefix();\n          result = new Binary(this.span(result.span.start), operator, result, right);\n          continue;\n      }\n      break;\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparsePrefix(): AST {\n    if (this.next.type == TokenType.Operator) {\n      const /** @type {?} */ start = this.inputIndex;\n      const /** @type {?} */ operator = this.next.strValue;\n      let /** @type {?} */ result: AST;\n      switch (operator) {\n        case '+':\n          this.advance();\n          return this.parsePrefix();\n        case '-':\n          this.advance();\n          result = this.parsePrefix();\n          return new Binary(\n              this.span(start), operator, new LiteralPrimitive(new ParseSpan(start, start), 0),\n              result);\n        case '!':\n          this.advance();\n          result = this.parsePrefix();\n          return new PrefixNot(this.span(start), result);\n      }\n    }\n    return this.parseCallChain();\n  }\n/**\n * @return {?}\n */\nparseCallChain(): AST {\n    let /** @type {?} */ result = this.parsePrimary();\n    while (true) {\n      if (this.optionalCharacter(chars.$PERIOD)) {\n        result = this.parseAccessMemberOrMethodCall(result, false);\n\n      } else if (this.optionalOperator('?.')) {\n        result = this.parseAccessMemberOrMethodCall(result, true);\n\n      } else if (this.optionalCharacter(chars.$LBRACKET)) {\n        this.rbracketsExpected++;\n        const /** @type {?} */ key = this.parsePipe();\n        this.rbracketsExpected--;\n        this.expectCharacter(chars.$RBRACKET);\n        if (this.optionalOperator('=')) {\n          const /** @type {?} */ value = this.parseConditional();\n          result = new KeyedWrite(this.span(result.span.start), result, key, value);\n        } else {\n          result = new KeyedRead(this.span(result.span.start), result, key);\n        }\n\n      } else if (this.optionalCharacter(chars.$LPAREN)) {\n        this.rparensExpected++;\n        const /** @type {?} */ args = this.parseCallArguments();\n        this.rparensExpected--;\n        this.expectCharacter(chars.$RPAREN);\n        result = new FunctionCall(this.span(result.span.start), result, args);\n\n      } else if (this.optionalOperator('!')) {\n        result = new NonNullAssert(this.span(result.span.start), result);\n\n      } else {\n        return result;\n      }\n    }\n  }\n/**\n * @return {?}\n */\nparsePrimary(): AST {\n    const /** @type {?} */ start = this.inputIndex;\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const /** @type {?} */ result = this.parsePipe();\n      this.rparensExpected--;\n      this.expectCharacter(chars.$RPAREN);\n      return result;\n\n    } else if (this.next.isKeywordNull()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), null);\n\n    } else if (this.next.isKeywordUndefined()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), void 0);\n\n    } else if (this.next.isKeywordTrue()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), true);\n\n    } else if (this.next.isKeywordFalse()) {\n      this.advance();\n      return new LiteralPrimitive(this.span(start), false);\n\n    } else if (this.next.isKeywordThis()) {\n      this.advance();\n      return new ImplicitReceiver(this.span(start));\n\n    } else if (this.optionalCharacter(chars.$LBRACKET)) {\n      this.rbracketsExpected++;\n      const /** @type {?} */ elements = this.parseExpressionList(chars.$RBRACKET);\n      this.rbracketsExpected--;\n      this.expectCharacter(chars.$RBRACKET);\n      return new LiteralArray(this.span(start), elements);\n\n    } else if (this.next.isCharacter(chars.$LBRACE)) {\n      return this.parseLiteralMap();\n\n    } else if (this.next.isIdentifier()) {\n      return this.parseAccessMemberOrMethodCall(new ImplicitReceiver(this.span(start)), false);\n\n    } else if (this.next.isNumber()) {\n      const /** @type {?} */ value = this.next.toNumber();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), value);\n\n    } else if (this.next.isString()) {\n      const /** @type {?} */ literalValue = this.next.toString();\n      this.advance();\n      return new LiteralPrimitive(this.span(start), literalValue);\n\n    } else if (this.index >= this.tokens.length) {\n      this.error(`Unexpected end of expression: ${this.input}`);\n      return new EmptyExpr(this.span(start));\n    } else {\n      this.error(`Unexpected token ${this.next}`);\n      return new EmptyExpr(this.span(start));\n    }\n  }\n/**\n * @param {?} terminator\n * @return {?}\n */\nparseExpressionList(terminator: number): AST[] {\n    const /** @type {?} */ result: AST[] = [];\n    if (!this.next.isCharacter(terminator)) {\n      do {\n        result.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n    }\n    return result;\n  }\n/**\n * @return {?}\n */\nparseLiteralMap(): LiteralMap {\n    const /** @type {?} */ keys: LiteralMapKey[] = [];\n    const /** @type {?} */ values: AST[] = [];\n    const /** @type {?} */ start = this.inputIndex;\n    this.expectCharacter(chars.$LBRACE);\n    if (!this.optionalCharacter(chars.$RBRACE)) {\n      this.rbracesExpected++;\n      do {\n        const /** @type {?} */ quoted = this.next.isString();\n        const /** @type {?} */ key = this.expectIdentifierOrKeywordOrString();\n        keys.push({key, quoted});\n        this.expectCharacter(chars.$COLON);\n        values.push(this.parsePipe());\n      } while (this.optionalCharacter(chars.$COMMA));\n      this.rbracesExpected--;\n      this.expectCharacter(chars.$RBRACE);\n    }\n    return new LiteralMap(this.span(start), keys, values);\n  }\n/**\n * @param {?} receiver\n * @param {?=} isSafe\n * @return {?}\n */\nparseAccessMemberOrMethodCall(receiver: AST, isSafe: boolean = false): AST {\n    const /** @type {?} */ start = receiver.span.start;\n    const /** @type {?} */ id = this.expectIdentifierOrKeyword();\n\n    if (this.optionalCharacter(chars.$LPAREN)) {\n      this.rparensExpected++;\n      const /** @type {?} */ args = this.parseCallArguments();\n      this.expectCharacter(chars.$RPAREN);\n      this.rparensExpected--;\n      const /** @type {?} */ span = this.span(start);\n      return isSafe ? new SafeMethodCall(span, receiver, id, args) :\n                      new MethodCall(span, receiver, id, args);\n\n    } else {\n      if (isSafe) {\n        if (this.optionalOperator('=')) {\n          this.error('The \\'?.\\' operator cannot be used in the assignment');\n          return new EmptyExpr(this.span(start));\n        } else {\n          return new SafePropertyRead(this.span(start), receiver, id);\n        }\n      } else {\n        if (this.optionalOperator('=')) {\n          if (!this.parseAction) {\n            this.error('Bindings cannot contain assignments');\n            return new EmptyExpr(this.span(start));\n          }\n\n          const /** @type {?} */ value = this.parseConditional();\n          return new PropertyWrite(this.span(start), receiver, id, value);\n        } else {\n          return new PropertyRead(this.span(start), receiver, id);\n        }\n      }\n    }\n  }\n/**\n * @return {?}\n */\nparseCallArguments(): BindingPipe[] {\n    if (this.next.isCharacter(chars.$RPAREN)) return [];\n    const /** @type {?} */ positionals: AST[] = [];\n    do {\n      positionals.push(this.parsePipe());\n    } while (this.optionalCharacter(chars.$COMMA));\n    return /** @type {?} */(( positionals as BindingPipe[]));\n  }\n/**\n * An identifier, a keyword, a string with an optional `-` inbetween.\n * @return {?}\n */\nexpectTemplateBindingKey(): string {\n    let /** @type {?} */ result = '';\n    let /** @type {?} */ operatorFound = false;\n    do {\n      result += this.expectIdentifierOrKeywordOrString();\n      operatorFound = this.optionalOperator('-');\n      if (operatorFound) {\n        result += '-';\n      }\n    } while (operatorFound);\n\n    return result.toString();\n  }\n/**\n * @return {?}\n */\nparseTemplateBindings(): TemplateBindingParseResult {\n    const /** @type {?} */ bindings: TemplateBinding[] = [];\n    let /** @type {?} */ prefix: string = /** @type {?} */(( null));\n    const /** @type {?} */ warnings: string[] = [];\n    while (this.index < this.tokens.length) {\n      const /** @type {?} */ start = this.inputIndex;\n      let /** @type {?} */ keyIsVar: boolean = this.peekKeywordLet();\n      if (keyIsVar) {\n        this.advance();\n      }\n      let /** @type {?} */ rawKey = this.expectTemplateBindingKey();\n      let /** @type {?} */ key = rawKey;\n      if (!keyIsVar) {\n        if (prefix == null) {\n          prefix = key;\n        } else {\n          key = prefix + key[0].toUpperCase() + key.substring(1);\n        }\n      }\n      this.optionalCharacter(chars.$COLON);\n      let /** @type {?} */ name: string = /** @type {?} */(( null));\n      let /** @type {?} */ expression: ASTWithSource = /** @type {?} */(( null));\n      if (keyIsVar) {\n        if (this.optionalOperator('=')) {\n          name = this.expectTemplateBindingKey();\n        } else {\n          name = '\\$implicit';\n        }\n      } else if (this.peekKeywordAs()) {\n        const /** @type {?} */ letStart = this.inputIndex;\n        this.advance();  // consume `as`\n        name = rawKey;\n        key = this.expectTemplateBindingKey();  // read local var name\n        keyIsVar = true;\n      } else if (this.next !== EOF && !this.peekKeywordLet()) {\n        const /** @type {?} */ start = this.inputIndex;\n        const /** @type {?} */ ast = this.parsePipe();\n        const /** @type {?} */ source = this.input.substring(start - this.offset, this.inputIndex - this.offset);\n        expression = new ASTWithSource(ast, source, this.location, this.errors);\n      }\n      bindings.push(new TemplateBinding(this.span(start), key, keyIsVar, name, expression));\n      if (this.peekKeywordAs() && !keyIsVar) {\n        const /** @type {?} */ letStart = this.inputIndex;\n        this.advance();                                   // consume `as`\n        const /** @type {?} */ letName = this.expectTemplateBindingKey();  // read local var name\n        bindings.push(new TemplateBinding(this.span(letStart), letName, true, key, /** @type {?} */(( null))));\n      }\n      if (!this.optionalCharacter(chars.$SEMICOLON)) {\n        this.optionalCharacter(chars.$COMMA);\n      }\n    }\n    return new TemplateBindingParseResult(bindings, warnings, this.errors);\n  }\n/**\n * @param {?} message\n * @param {?=} index\n * @return {?}\n */\nerror(message: string, index: number|null = null) {\n    this.errors.push(new ParserError(message, this.input, this.locationText(index), this.location));\n    this.skip();\n  }\n/**\n * @param {?=} index\n * @return {?}\n */\n\nprivate locationText(index: number|null = null) {\n    if (index == null) index = this.index;\n    return (index < this.tokens.length) ? `at column ${this.tokens[index].index + 1} in` :\n                                          `at the end of the expression`;\n  }\n/**\n * @return {?}\n */\n\nprivate skip() {\n    let /** @type {?} */ n = this.next;\n    while (this.index < this.tokens.length && !n.isCharacter(chars.$SEMICOLON) &&\n           (this.rparensExpected <= 0 || !n.isCharacter(chars.$RPAREN)) &&\n           (this.rbracesExpected <= 0 || !n.isCharacter(chars.$RBRACE)) &&\n           (this.rbracketsExpected <= 0 || !n.isCharacter(chars.$RBRACKET))) {\n      if (this.next.isError()) {\n        this.errors.push(new ParserError( /** @type {?} */((\n            this.next.toString())), this.input, this.locationText(), this.location));\n      }\n      this.advance();\n      n = this.next;\n    }\n  }\n}\n\nfunction _ParseAST_tsickle_Closure_declarations() {\n/** @type {?} */\n_ParseAST.prototype.rparensExpected;\n/** @type {?} */\n_ParseAST.prototype.rbracketsExpected;\n/** @type {?} */\n_ParseAST.prototype.rbracesExpected;\n/** @type {?} */\n_ParseAST.prototype.index;\n/** @type {?} */\n_ParseAST.prototype.input;\n/** @type {?} */\n_ParseAST.prototype.location;\n/** @type {?} */\n_ParseAST.prototype.tokens;\n/** @type {?} */\n_ParseAST.prototype.inputLength;\n/** @type {?} */\n_ParseAST.prototype.parseAction;\n/** @type {?} */\n_ParseAST.prototype.errors;\n/** @type {?} */\n_ParseAST.prototype.offset;\n}\n\nclass SimpleExpressionChecker implements AstVisitor {\n/**\n * @param {?} ast\n * @return {?}\n */\nstatic check(ast: AST): string[] {\n    const /** @type {?} */ s = new SimpleExpressionChecker();\n    ast.visit(s);\n    return s.errors;\n  }\n\n  errors: string[] = [];\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitImplicitReceiver(ast: ImplicitReceiver, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitInterpolation(ast: Interpolation, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralPrimitive(ast: LiteralPrimitive, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPropertyRead(ast: PropertyRead, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPropertyWrite(ast: PropertyWrite, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSafePropertyRead(ast: SafePropertyRead, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitMethodCall(ast: MethodCall, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitSafeMethodCall(ast: SafeMethodCall, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitFunctionCall(ast: FunctionCall, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralArray(ast: LiteralArray, context: any) { this.visitAll(ast.expressions); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitLiteralMap(ast: LiteralMap, context: any) { this.visitAll(ast.values); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitBinary(ast: Binary, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPrefixNot(ast: PrefixNot, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitNonNullAssert(ast: NonNullAssert, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitConditional(ast: Conditional, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitPipe(ast: BindingPipe, context: any) { this.errors.push('pipes'); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyedRead(ast: KeyedRead, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitKeyedWrite(ast: KeyedWrite, context: any) {}\n/**\n * @param {?} asts\n * @return {?}\n */\nvisitAll(asts: any[]): any[] { return asts.map(node => node.visit(this)); }\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitChain(ast: Chain, context: any) {}\n/**\n * @param {?} ast\n * @param {?} context\n * @return {?}\n */\nvisitQuote(ast: Quote, context: any) {}\n}\n\nfunction SimpleExpressionChecker_tsickle_Closure_declarations() {\n/** @type {?} */\nSimpleExpressionChecker.prototype.errors;\n}\n\n"]}