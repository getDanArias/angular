{"version":3,"sources":["../../../../../packages/core/src/di/reflective_injector.ts"],"names":[],"mappings":"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","file":"reflective_injector.js","sourceRoot":"","sourcesContent":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\n\n/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport {Injector, THROW_IF_NOT_FOUND} from './injector';\nimport {Self, SkipSelf} from './metadata';\nimport {Provider} from './provider';\nimport {cyclicDependencyError, instantiationError, noProviderError, outOfBoundsError} from './reflective_errors';\nimport {ReflectiveKey} from './reflective_key';\nimport {ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider, resolveReflectiveProviders} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst /** @type {?} */ UNDEFINED = new Object();\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n * \n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n * \n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n * \n * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n * \n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n * \n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n * \n * @deprecated from v5 - slow and brings in a lot of code, Use `Injector.create` instead.\n * @abstract\n */\nexport abstract class ReflectiveInjector implements Injector {\n/**\n * Turns an array of provider definitions into an array of resolved providers.\n * \n * A resolution is a process of flattening multiple nested arrays and converting individual\n * providers into an array of {\\@link ResolvedReflectiveProvider}s.\n * \n * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n * \n * expect(providers.length).toEqual(2);\n * \n * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n * expect(providers[0].key.displayName).toBe(\"Car\");\n * expect(providers[0].dependencies.length).toEqual(1);\n * expect(providers[0].factory).toBeDefined();\n * \n * expect(providers[1].key.displayName).toBe(\"Engine\");\n * });\n * ```\n * \n * See {\\@link ReflectiveInjector#fromResolvedProviders} for more info.\n * @param {?} providers\n * @return {?}\n */\nstatic resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n/**\n * Resolves an array of providers and creates an injector from those providers.\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \n * This function is slower than the corresponding `fromResolvedProviders`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link ReflectiveInjector#resolve} and {\\@link ReflectiveInjector#fromResolvedProviders}.\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic resolveAndCreate(providers: Provider[], parent?: Injector): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n/**\n * Creates an injector from previously resolved providers.\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, Engine]);\n * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \\@experimental\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent?: Injector):\n      ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n\n\n  /**\n   * Parent of this injector.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n   *\n   * ```typescript\n   * var parent = ReflectiveInjector.resolveAndCreate([]);\n   * var child = parent.resolveAndCreateChild([]);\n   * expect(child.parent).toBe(parent);\n   * ```\n   */\n  abstract get parent(): Injector|null;\n\n  /**\n   * Resolves an array of providers and creates a child injector from those providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * The passed-in providers can be an array of `Type`, {@link Provider},\n   * or a recursive array of more providers.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n   * var child = parent.resolveAndCreateChild([ChildProvider]);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   *\n   * This function is slower than the corresponding `createChildFromResolved`\n   * because it needs to resolve the passed-in providers first.\n   * See {@link ReflectiveInjector#resolve} and {@link ReflectiveInjector#createChildFromResolved}.\n   */\n  abstract resolveAndCreateChild(providers: Provider[]): ReflectiveInjector;\n\n  /**\n   * Creates a child injector from previously resolved providers.\n   *\n   * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n   * -->\n   *\n   * This API is the recommended way to construct injectors in performance-sensitive parts.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n   *\n   * ```typescript\n   * class ParentProvider {}\n   * class ChildProvider {}\n   *\n   * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n   * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n   *\n   * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n   * var child = parent.createChildFromResolved(childProviders);\n   *\n   * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n   * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n   * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n   * ```\n   */\n  abstract createChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector;\n\n  /**\n   * Resolves a provider and instantiates an object in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   *\n   * var car = injector.resolveAndInstantiate(Car);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n   * ```\n   */\n  abstract resolveAndInstantiate(provider: Provider): any;\n\n  /**\n   * Instantiates an object using a resolved provider in the context of the injector.\n   *\n   * The created object does not get cached by the injector.\n   *\n   * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n   *\n   * ```typescript\n   * @Injectable()\n   * class Engine {\n   * }\n   *\n   * @Injectable()\n   * class Car {\n   *   constructor(public engine:Engine) {}\n   * }\n   *\n   * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n   * var carProvider = ReflectiveInjector.resolve([Car])[0];\n   * var car = injector.instantiateResolved(carProvider);\n   * expect(car.engine).toBe(injector.get(Engine));\n   * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n   * ```\n   */\n  abstract instantiateResolved(provider: ResolvedReflectiveProvider): any;\n\n  abstract get(token: any, notFoundValue?: any): any;\n}\n\nfunction ReflectiveInjector_tsickle_Closure_declarations() {\n\n/**\n * Parent of this injector.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n * \n * ```typescript\n * var parent = ReflectiveInjector.resolveAndCreate([]);\n * var child = parent.resolveAndCreateChild([]);\n * expect(child.parent).toBe(parent);\n * ```\n * @abstract\n * @return {?}\n */\nReflectiveInjector.prototype.parent = function() {};\n\n/**\n * Resolves an array of providers and creates a child injector from those providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n * var child = parent.resolveAndCreateChild([ChildProvider]);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * \n * This function is slower than the corresponding `createChildFromResolved`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link ReflectiveInjector#resolve} and {\\@link ReflectiveInjector#createChildFromResolved}.\n * @abstract\n * @param {?} providers\n * @return {?}\n */\nReflectiveInjector.prototype.resolveAndCreateChild = function(providers) {};\n\n/**\n * Creates a child injector from previously resolved providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n * \n * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n * var child = parent.createChildFromResolved(childProviders);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * @abstract\n * @param {?} providers\n * @return {?}\n */\nReflectiveInjector.prototype.createChildFromResolved = function(providers) {};\n\n/**\n * Resolves a provider and instantiates an object in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * \n * var car = injector.resolveAndInstantiate(Car);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\nReflectiveInjector.prototype.resolveAndInstantiate = function(provider) {};\n\n/**\n * Instantiates an object using a resolved provider in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * var carProvider = ReflectiveInjector.resolve([Car])[0];\n * var car = injector.instantiateResolved(carProvider);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\nReflectiveInjector.prototype.instantiateResolved = function(provider) {};\n\n/**\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nReflectiveInjector.prototype.get = function(token, notFoundValue) {};\n}\n\nexport class ReflectiveInjector_ implements ReflectiveInjector {\nprivate static INJECTOR_KEY = ReflectiveKey.get(Injector);\n/**\n * \\@internal\n */\n_constructionCounter: number = 0;\n/**\n * \\@internal\n */\n\npublic _providers: ResolvedReflectiveProvider[];\n/**\n * \\@internal\n */\n\npublic _parent: Injector|null;\n\n  keyIds: number[];\n  objs: any[];\n/**\n * Private\n * @param {?} _providers\n * @param {?=} _parent\n */\nconstructor(_providers: ResolvedReflectiveProvider[], _parent?: Injector) {\n    this._providers = _providers;\n    this._parent = _parent || null;\n\n    const /** @type {?} */ len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let /** @type {?} */ i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n/**\n * @return {?}\n */\nget parent(): Injector|null { return this._parent; }\n/**\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n/**\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const /** @type {?} */ inj = new ReflectiveInjector_(providers);\n    inj._parent = this;\n    return inj;\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\ngetProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw outOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n/**\n * \\@internal\n * @param {?} provider\n * @return {?}\n */\n_new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw cyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n/**\n * @return {?}\n */\n\nprivate _getMaxNumberOfObjects(): number { return this.objs.length; }\n/**\n * @param {?} provider\n * @return {?}\n */\n\nprivate _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const /** @type {?} */ res = new Array(provider.resolvedFactories.length);\n      for (let /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n/**\n * @param {?} provider\n * @param {?} ResolvedReflectiveFactory\n * @return {?}\n */\n\nprivate _instantiate(\n      provider: ResolvedReflectiveProvider,\n      ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const /** @type {?} */ factory = ResolvedReflectiveFactory.factory;\n\n    let /** @type {?} */ deps: any[];\n    try {\n      deps =\n          ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch ( /** @type {?} */e) {\n      if (e.addKey) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let /** @type {?} */ obj: any;\n    try {\n      obj = factory(...deps);\n    } catch ( /** @type {?} */e) {\n      throw instantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n/**\n * @param {?} dep\n * @return {?}\n */\n\nprivate _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n/**\n * @param {?} key\n * @param {?} visibility\n * @param {?} notFoundValue\n * @return {?}\n */\n\nprivate _getByKey(key: ReflectiveKey, visibility: Self|SkipSelf|null, notFoundValue: any): any {\n    if (key === ReflectiveInjector_.INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n/**\n * @param {?} keyId\n * @return {?}\n */\n\nprivate _getObjByKeyId(keyId: number): any {\n    for (let /** @type {?} */ i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw noProviderError(this, key);\n    }\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const /** @type {?} */ obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @param {?} visibility\n * @return {?}\n */\n_getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self|SkipSelf|null): any {\n    let /** @type {?} */ inj: Injector|null;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this._parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const /** @type {?} */ inj_ = /** @type {?} */(( <ReflectiveInjector_>inj));\n      const /** @type {?} */ obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_._parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n/**\n * @return {?}\n */\nget displayName(): string {\n    const /** @type {?} */ providers =\n        _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n            .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n/**\n * @return {?}\n */\ntoString(): string { return this.displayName; }\n}\n\nfunction ReflectiveInjector__tsickle_Closure_declarations() {\n/** @type {?} */\nReflectiveInjector_.INJECTOR_KEY;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._constructionCounter;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._providers;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._parent;\n/** @type {?} */\nReflectiveInjector_.prototype.keyIds;\n/** @type {?} */\nReflectiveInjector_.prototype.objs;\n}\n\n/**\n * @param {?} injector\n * @param {?} fn\n * @return {?}\n */\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const /** @type {?} */ res: any[] = new Array(injector._providers.length);\n  for (let /** @type {?} */ i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n"]}